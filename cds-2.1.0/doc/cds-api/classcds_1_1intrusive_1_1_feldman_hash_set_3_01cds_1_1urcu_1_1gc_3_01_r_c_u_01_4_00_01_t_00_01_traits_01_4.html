<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>cds: cds::intrusive::FeldmanHashSet&lt; cds::urcu::gc&lt; RCU &gt;, T, Traits &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">cds
   &#160;<span id="projectnumber">2.1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="classes.html"><span>Data&#160;Structure&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Data&#160;Fields</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classcds_1_1intrusive_1_1_feldman_hash_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a>  </div>
  <div class="headertitle">
<div class="title">cds::intrusive::FeldmanHashSet&lt; cds::urcu::gc&lt; RCU &gt;, T, Traits &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__cds__intrusive__containers.html">Intrusive containers</a> &raquo; <a class="el" href="group__cds__intrusive__map.html">Set</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Intrusive hash set based on multi-level array, <a class="el" href="namespacecds_1_1urcu.html#cds_urcu_desc">RCU</a> specialization.  
 <a href="classcds_1_1intrusive_1_1_feldman_hash_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#details">More...</a></p>

<p><code>#include &lt;cds/intrusive/feldman_hashset_rcu.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for cds::intrusive::FeldmanHashSet&lt; cds::urcu::gc&lt; RCU &gt;, T, Traits &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classcds_1_1intrusive_1_1_feldman_hash_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.png" usemap="#cds::intrusive::FeldmanHashSet&lt; cds::urcu::gc&lt; RCU &gt;, T, Traits &gt;_map" alt=""/>
  <map id="cds::intrusive::FeldmanHashSet&lt; cds::urcu::gc&lt; RCU &gt;, T, Traits &gt;_map" name="cds::intrusive::FeldmanHashSet&lt; cds::urcu::gc&lt; RCU &gt;, T, Traits &gt;_map">
<area href="classcds_1_1container_1_1_feldman_hash_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html" title="Hash set based on multi-level array, RCU specialization. " alt="cds::container::FeldmanHashSet&lt; cds::urcu::gc&lt; RCU &gt;, T, Traits &gt;" shape="rect" coords="0,112,393,136"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ab9df5a1b19c327f8acb5317d46977eaa"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab9df5a1b19c327f8acb5317d46977eaa"></a>
typedef cds::urcu::gc&lt; RCU &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#ab9df5a1b19c327f8acb5317d46977eaa">gc</a></td></tr>
<tr class="memdesc:ab9df5a1b19c327f8acb5317d46977eaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">RCU garbage collector. <br /></td></tr>
<tr class="separator:ab9df5a1b19c327f8acb5317d46977eaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a436fcafecec43d0985ca2ba3a651cf01"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a436fcafecec43d0985ca2ba3a651cf01"></a>
typedef T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a436fcafecec43d0985ca2ba3a651cf01">value_type</a></td></tr>
<tr class="memdesc:a436fcafecec43d0985ca2ba3a651cf01"><td class="mdescLeft">&#160;</td><td class="mdescRight">type of value stored in the set <br /></td></tr>
<tr class="separator:a436fcafecec43d0985ca2ba3a651cf01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fecf9f7aec3e34c5e5a5cbe33ab9ef4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8fecf9f7aec3e34c5e5a5cbe33ab9ef4"></a>
typedef Traits&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a8fecf9f7aec3e34c5e5a5cbe33ab9ef4">traits</a></td></tr>
<tr class="memdesc:a8fecf9f7aec3e34c5e5a5cbe33ab9ef4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traits template parameter. <br /></td></tr>
<tr class="separator:a8fecf9f7aec3e34c5e5a5cbe33ab9ef4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fa65f18f80ba101e5e2e1bda056ee1c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2fa65f18f80ba101e5e2e1bda056ee1c"></a>
typedef traits::hash_accessor&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a2fa65f18f80ba101e5e2e1bda056ee1c">hash_accessor</a></td></tr>
<tr class="memdesc:a2fa65f18f80ba101e5e2e1bda056ee1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hash accessor functor. <br /></td></tr>
<tr class="separator:a2fa65f18f80ba101e5e2e1bda056ee1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7eabcbb66ee3808ad3dfee864f90f407"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7eabcbb66ee3808ad3dfee864f90f407"></a>
typedef base_class::hash_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a7eabcbb66ee3808ad3dfee864f90f407">hash_type</a></td></tr>
<tr class="memdesc:a7eabcbb66ee3808ad3dfee864f90f407"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hash type deduced from <code>hash_accessor</code> return type. <br /></td></tr>
<tr class="separator:a7eabcbb66ee3808ad3dfee864f90f407"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f82187512125ef31e08f55a0d4d86b7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5f82187512125ef31e08f55a0d4d86b7"></a>
typedef traits::disposer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a5f82187512125ef31e08f55a0d4d86b7">disposer</a></td></tr>
<tr class="memdesc:a5f82187512125ef31e08f55a0d4d86b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">data node disposer <br /></td></tr>
<tr class="separator:a5f82187512125ef31e08f55a0d4d86b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0520ddec08b96c8add71bf6037d7b7ad"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0520ddec08b96c8add71bf6037d7b7ad"></a>
typedef base_class::hash_comparator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a0520ddec08b96c8add71bf6037d7b7ad">hash_comparator</a></td></tr>
<tr class="memdesc:a0520ddec08b96c8add71bf6037d7b7ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">hash compare functor based on <code>traits::compare</code> and <code>traits::less</code> options <br /></td></tr>
<tr class="separator:a0520ddec08b96c8add71bf6037d7b7ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d3ce475eb2ce26acbf2fca6bf9848f0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0d3ce475eb2ce26acbf2fca6bf9848f0"></a>
typedef traits::item_counter&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a0d3ce475eb2ce26acbf2fca6bf9848f0">item_counter</a></td></tr>
<tr class="memdesc:a0d3ce475eb2ce26acbf2fca6bf9848f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Item counter type. <br /></td></tr>
<tr class="separator:a0d3ce475eb2ce26acbf2fca6bf9848f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3de1174c1e30497864857df4dea2203"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af3de1174c1e30497864857df4dea2203"></a>
typedef traits::node_allocator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#af3de1174c1e30497864857df4dea2203">node_allocator</a></td></tr>
<tr class="memdesc:af3de1174c1e30497864857df4dea2203"><td class="mdescLeft">&#160;</td><td class="mdescRight">Array node allocator. <br /></td></tr>
<tr class="separator:af3de1174c1e30497864857df4dea2203"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e50c806854567b5a3aa771f2be42873"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2e50c806854567b5a3aa771f2be42873"></a>
typedef traits::memory_model&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a2e50c806854567b5a3aa771f2be42873">memory_model</a></td></tr>
<tr class="memdesc:a2e50c806854567b5a3aa771f2be42873"><td class="mdescLeft">&#160;</td><td class="mdescRight">Memory model. <br /></td></tr>
<tr class="separator:a2e50c806854567b5a3aa771f2be42873"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9512163a7fe41c3da89e51d0fc5b9904"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9512163a7fe41c3da89e51d0fc5b9904"></a>
typedef traits::back_off&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a9512163a7fe41c3da89e51d0fc5b9904">back_off</a></td></tr>
<tr class="memdesc:a9512163a7fe41c3da89e51d0fc5b9904"><td class="mdescLeft">&#160;</td><td class="mdescRight">Backoff strategy. <br /></td></tr>
<tr class="separator:a9512163a7fe41c3da89e51d0fc5b9904"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e132ac57dc6bf9820229355e7376819"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2e132ac57dc6bf9820229355e7376819"></a>
typedef traits::stat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a2e132ac57dc6bf9820229355e7376819">stat</a></td></tr>
<tr class="memdesc:a2e132ac57dc6bf9820229355e7376819"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal statistics type. <br /></td></tr>
<tr class="separator:a2e132ac57dc6bf9820229355e7376819"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad74b2b840c4fa15350f834701c978069"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad74b2b840c4fa15350f834701c978069"></a>
typedef traits::rcu_check_deadlock&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#ad74b2b840c4fa15350f834701c978069">rcu_check_deadlock</a></td></tr>
<tr class="memdesc:ad74b2b840c4fa15350f834701c978069"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deadlock checking policy. <br /></td></tr>
<tr class="separator:ad74b2b840c4fa15350f834701c978069"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ae3a181865d25f62c3f6a984d077d64"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4ae3a181865d25f62c3f6a984d077d64"></a>
typedef gc::scoped_lock&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a4ae3a181865d25f62c3f6a984d077d64">rcu_lock</a></td></tr>
<tr class="memdesc:a4ae3a181865d25f62c3f6a984d077d64"><td class="mdescLeft">&#160;</td><td class="mdescRight">RCU scoped lock. <br /></td></tr>
<tr class="separator:a4ae3a181865d25f62c3f6a984d077d64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ab7acb9b825e2af49051f7d459faf63"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7ab7acb9b825e2af49051f7d459faf63"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a7ab7acb9b825e2af49051f7d459faf63">exempt_ptr</a> = <a class="el" href="classcds_1_1urcu_1_1exempt__ptr.html">cds::urcu::exempt_ptr</a>&lt; <a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#ab9df5a1b19c327f8acb5317d46977eaa">gc</a>, <a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a436fcafecec43d0985ca2ba3a651cf01">value_type</a>, <a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a436fcafecec43d0985ca2ba3a651cf01">value_type</a>, <a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a5f82187512125ef31e08f55a0d4d86b7">disposer</a>, void &gt;</td></tr>
<tr class="memdesc:a7ab7acb9b825e2af49051f7d459faf63"><td class="mdescLeft">&#160;</td><td class="mdescRight">pointer to extracted node <br /></td></tr>
<tr class="separator:a7ab7acb9b825e2af49051f7d459faf63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab753ba63ca6592e3bd6d1b048316df32"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab753ba63ca6592e3bd6d1b048316df32"></a>
typedef implementation_defined&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#ab753ba63ca6592e3bd6d1b048316df32">iterator</a></td></tr>
<tr class="memdesc:ab753ba63ca6592e3bd6d1b048316df32"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#cds_intrusive_FeldmanHashSet_rcu_iterators">bidirectional iterator</a> type <br /></td></tr>
<tr class="separator:ab753ba63ca6592e3bd6d1b048316df32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91bc3155f01ef75b2c1abbd93f8b9a9d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a91bc3155f01ef75b2c1abbd93f8b9a9d"></a>
typedef implementation_defined&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a91bc3155f01ef75b2c1abbd93f8b9a9d">const_iterator</a></td></tr>
<tr class="memdesc:a91bc3155f01ef75b2c1abbd93f8b9a9d"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#cds_intrusive_FeldmanHashSet_rcu_iterators">bidirectional const iterator</a> type <br /></td></tr>
<tr class="separator:a91bc3155f01ef75b2c1abbd93f8b9a9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac86d5bf552346ebfdfb0b4f9b3341387"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac86d5bf552346ebfdfb0b4f9b3341387"></a>
typedef implementation_defined&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#ac86d5bf552346ebfdfb0b4f9b3341387">reverse_iterator</a></td></tr>
<tr class="memdesc:ac86d5bf552346ebfdfb0b4f9b3341387"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#cds_intrusive_FeldmanHashSet_rcu_iterators">bidirectional reverse iterator</a> type <br /></td></tr>
<tr class="separator:ac86d5bf552346ebfdfb0b4f9b3341387"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a911e21a152fe148f596f8ac83c233145"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a911e21a152fe148f596f8ac83c233145"></a>
typedef implementation_defined&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a911e21a152fe148f596f8ac83c233145">const_reverse_iterator</a></td></tr>
<tr class="memdesc:a911e21a152fe148f596f8ac83c233145"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#cds_intrusive_FeldmanHashSet_rcu_iterators">bidirectional reverse const iterator</a> type <br /></td></tr>
<tr class="separator:a911e21a152fe148f596f8ac83c233145"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a9794b380100d87c105735ded92151df5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a9794b380100d87c105735ded92151df5">FeldmanHashSet</a> (size_t head_bits=8, size_t array_bits=4)</td></tr>
<tr class="memdesc:a9794b380100d87c105735ded92151df5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates empty set.  <a href="#a9794b380100d87c105735ded92151df5">More...</a><br /></td></tr>
<tr class="separator:a9794b380100d87c105735ded92151df5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb68b520eac5a65e907451cbd24ccd41"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acb68b520eac5a65e907451cbd24ccd41"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#acb68b520eac5a65e907451cbd24ccd41">~FeldmanHashSet</a> ()</td></tr>
<tr class="memdesc:acb68b520eac5a65e907451cbd24ccd41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructs the set and frees all data. <br /></td></tr>
<tr class="separator:acb68b520eac5a65e907451cbd24ccd41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4538127071b47dd6d7d475bbaaf029e9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a4538127071b47dd6d7d475bbaaf029e9">insert</a> (<a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a436fcafecec43d0985ca2ba3a651cf01">value_type</a> &amp;val)</td></tr>
<tr class="memdesc:a4538127071b47dd6d7d475bbaaf029e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new node.  <a href="#a4538127071b47dd6d7d475bbaaf029e9">More...</a><br /></td></tr>
<tr class="separator:a4538127071b47dd6d7d475bbaaf029e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ecf10d278980c4885fd86472ee660d9"><td class="memTemplParams" colspan="2">template&lt;typename Func &gt; </td></tr>
<tr class="memitem:a8ecf10d278980c4885fd86472ee660d9"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a8ecf10d278980c4885fd86472ee660d9">insert</a> (<a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a436fcafecec43d0985ca2ba3a651cf01">value_type</a> &amp;val, Func f)</td></tr>
<tr class="memdesc:a8ecf10d278980c4885fd86472ee660d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new node.  <a href="#a8ecf10d278980c4885fd86472ee660d9">More...</a><br /></td></tr>
<tr class="separator:a8ecf10d278980c4885fd86472ee660d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad515bc67e591341c91063a01f7586273"><td class="memItemLeft" align="right" valign="top">std::pair&lt; bool, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#ad515bc67e591341c91063a01f7586273">update</a> (<a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a436fcafecec43d0985ca2ba3a651cf01">value_type</a> &amp;val, bool bInsert=true)</td></tr>
<tr class="memdesc:ad515bc67e591341c91063a01f7586273"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the node.  <a href="#ad515bc67e591341c91063a01f7586273">More...</a><br /></td></tr>
<tr class="separator:ad515bc67e591341c91063a01f7586273"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae64d8b9ead20e7130cca3d11cfb76d2c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#ae64d8b9ead20e7130cca3d11cfb76d2c">unlink</a> (<a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a436fcafecec43d0985ca2ba3a651cf01">value_type</a> const &amp;val)</td></tr>
<tr class="memdesc:ae64d8b9ead20e7130cca3d11cfb76d2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlinks the item <code>val</code> from the set.  <a href="#ae64d8b9ead20e7130cca3d11cfb76d2c">More...</a><br /></td></tr>
<tr class="separator:ae64d8b9ead20e7130cca3d11cfb76d2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d44403b71d78b9f52a8e4c797b1a047"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a2d44403b71d78b9f52a8e4c797b1a047">erase</a> (<a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a7eabcbb66ee3808ad3dfee864f90f407">hash_type</a> const &amp;hash)</td></tr>
<tr class="memdesc:a2d44403b71d78b9f52a8e4c797b1a047"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the item from the set.  <a href="#a2d44403b71d78b9f52a8e4c797b1a047">More...</a><br /></td></tr>
<tr class="separator:a2d44403b71d78b9f52a8e4c797b1a047"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a336144c3b9ef30873da716277f617527"><td class="memTemplParams" colspan="2">template&lt;typename Func &gt; </td></tr>
<tr class="memitem:a336144c3b9ef30873da716277f617527"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a336144c3b9ef30873da716277f617527">erase</a> (<a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a7eabcbb66ee3808ad3dfee864f90f407">hash_type</a> const &amp;hash, Func f)</td></tr>
<tr class="memdesc:a336144c3b9ef30873da716277f617527"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the item from the set.  <a href="#a336144c3b9ef30873da716277f617527">More...</a><br /></td></tr>
<tr class="separator:a336144c3b9ef30873da716277f617527"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdcc102e63adf30c70c786713fa3f411"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a7ab7acb9b825e2af49051f7d459faf63">exempt_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#afdcc102e63adf30c70c786713fa3f411">extract</a> (<a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a7eabcbb66ee3808ad3dfee864f90f407">hash_type</a> const &amp;hash)</td></tr>
<tr class="memdesc:afdcc102e63adf30c70c786713fa3f411"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the item with specified <code>hash</code>.  <a href="#afdcc102e63adf30c70c786713fa3f411">More...</a><br /></td></tr>
<tr class="separator:afdcc102e63adf30c70c786713fa3f411"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b78c7058b1b8ac0a725bf055b3452ae"><td class="memTemplParams" colspan="2">template&lt;typename Func &gt; </td></tr>
<tr class="memitem:a0b78c7058b1b8ac0a725bf055b3452ae"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a0b78c7058b1b8ac0a725bf055b3452ae">find</a> (<a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a7eabcbb66ee3808ad3dfee864f90f407">hash_type</a> const &amp;hash, Func f)</td></tr>
<tr class="memdesc:a0b78c7058b1b8ac0a725bf055b3452ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds an item by it's <code>hash</code>.  <a href="#a0b78c7058b1b8ac0a725bf055b3452ae">More...</a><br /></td></tr>
<tr class="separator:a0b78c7058b1b8ac0a725bf055b3452ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e62e0e52edcfae98b3f9f7432e0b368"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a8e62e0e52edcfae98b3f9f7432e0b368">contains</a> (<a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a7eabcbb66ee3808ad3dfee864f90f407">hash_type</a> const &amp;hash)</td></tr>
<tr class="memdesc:a8e62e0e52edcfae98b3f9f7432e0b368"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the set contains <code>hash</code>.  <a href="#a8e62e0e52edcfae98b3f9f7432e0b368">More...</a><br /></td></tr>
<tr class="separator:a8e62e0e52edcfae98b3f9f7432e0b368"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63b8dbb1cb0e7dc355392ec8a29660a3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a436fcafecec43d0985ca2ba3a651cf01">value_type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a63b8dbb1cb0e7dc355392ec8a29660a3">get</a> (<a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a7eabcbb66ee3808ad3dfee864f90f407">hash_type</a> const &amp;hash)</td></tr>
<tr class="memdesc:a63b8dbb1cb0e7dc355392ec8a29660a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds an item by it's <code>hash</code> and returns the item found.  <a href="#a63b8dbb1cb0e7dc355392ec8a29660a3">More...</a><br /></td></tr>
<tr class="separator:a63b8dbb1cb0e7dc355392ec8a29660a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae21837fc8f2a3220e1acc8a81785f1b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#ae21837fc8f2a3220e1acc8a81785f1b0">clear</a> ()</td></tr>
<tr class="memdesc:ae21837fc8f2a3220e1acc8a81785f1b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the set (non-atomic)  <a href="#ae21837fc8f2a3220e1acc8a81785f1b0">More...</a><br /></td></tr>
<tr class="separator:ae21837fc8f2a3220e1acc8a81785f1b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1b5ff9d36b3e81cde94a94593745926"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#ab1b5ff9d36b3e81cde94a94593745926">empty</a> () const </td></tr>
<tr class="memdesc:ab1b5ff9d36b3e81cde94a94593745926"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the set is empty.  <a href="#ab1b5ff9d36b3e81cde94a94593745926">More...</a><br /></td></tr>
<tr class="separator:ab1b5ff9d36b3e81cde94a94593745926"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a544c4527dfd5c4c160472f4d852143e2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a544c4527dfd5c4c160472f4d852143e2"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a544c4527dfd5c4c160472f4d852143e2">size</a> () const </td></tr>
<tr class="memdesc:a544c4527dfd5c4c160472f4d852143e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns item count in the set. <br /></td></tr>
<tr class="separator:a544c4527dfd5c4c160472f4d852143e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d2dba8b34b9377cb6dc033d64e1e0c8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6d2dba8b34b9377cb6dc033d64e1e0c8"></a>
<a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a2e132ac57dc6bf9820229355e7376819">stat</a> const &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a6d2dba8b34b9377cb6dc033d64e1e0c8">statistics</a> () const </td></tr>
<tr class="memdesc:a6d2dba8b34b9377cb6dc033d64e1e0c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns const reference to internal statistics. <br /></td></tr>
<tr class="separator:a6d2dba8b34b9377cb6dc033d64e1e0c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7965078c29fe15f65b3e8bd31a0d4b16"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a7965078c29fe15f65b3e8bd31a0d4b16">get_level_statistics</a> (std::vector&lt; <a class="el" href="structcds_1_1intrusive_1_1feldman__hashset_1_1level__statistics.html">feldman_hashset::level_statistics</a> &gt; &amp;<a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a2e132ac57dc6bf9820229355e7376819">stat</a>) const </td></tr>
<tr class="memdesc:a7965078c29fe15f65b3e8bd31a0d4b16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collects tree level statistics into <code>stat</code>.  <a href="#a7965078c29fe15f65b3e8bd31a0d4b16">More...</a><br /></td></tr>
<tr class="separator:a7965078c29fe15f65b3e8bd31a0d4b16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Thread-safe iterators</div></td></tr>
<tr class="memitem:a9c97fdc4e1ee28705eb7c94d267d9a97"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#ab753ba63ca6592e3bd6d1b048316df32">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a9c97fdc4e1ee28705eb7c94d267d9a97">begin</a> ()</td></tr>
<tr class="memdesc:a9c97fdc4e1ee28705eb7c94d267d9a97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the beginning of the set.  <a href="#a9c97fdc4e1ee28705eb7c94d267d9a97">More...</a><br /></td></tr>
<tr class="separator:a9c97fdc4e1ee28705eb7c94d267d9a97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42d4a178893a64af207517c125422806"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a42d4a178893a64af207517c125422806"></a>
<a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a91bc3155f01ef75b2c1abbd93f8b9a9d">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a42d4a178893a64af207517c125422806">begin</a> () const </td></tr>
<tr class="memdesc:a42d4a178893a64af207517c125422806"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an const iterator to the beginning of the set. <br /></td></tr>
<tr class="separator:a42d4a178893a64af207517c125422806"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad90ebf5f0f5acfaf6b4880ea720ac7d5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad90ebf5f0f5acfaf6b4880ea720ac7d5"></a>
<a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a91bc3155f01ef75b2c1abbd93f8b9a9d">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#ad90ebf5f0f5acfaf6b4880ea720ac7d5">cbegin</a> ()</td></tr>
<tr class="memdesc:ad90ebf5f0f5acfaf6b4880ea720ac7d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an const iterator to the beginning of the set. <br /></td></tr>
<tr class="separator:ad90ebf5f0f5acfaf6b4880ea720ac7d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae11013fd43008bf9f405a79b2504d58f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae11013fd43008bf9f405a79b2504d58f"></a>
<a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#ab753ba63ca6592e3bd6d1b048316df32">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#ae11013fd43008bf9f405a79b2504d58f">end</a> ()</td></tr>
<tr class="memdesc:ae11013fd43008bf9f405a79b2504d58f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the element following the last element of the set. This element acts as a placeholder; attempting to access it results in undefined behavior. <br /></td></tr>
<tr class="separator:ae11013fd43008bf9f405a79b2504d58f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad14bb5b43515d20d775ee5650fef2e5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aad14bb5b43515d20d775ee5650fef2e5"></a>
<a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a91bc3155f01ef75b2c1abbd93f8b9a9d">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#aad14bb5b43515d20d775ee5650fef2e5">end</a> () const </td></tr>
<tr class="memdesc:aad14bb5b43515d20d775ee5650fef2e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const iterator to the element following the last element of the set. This element acts as a placeholder; attempting to access it results in undefined behavior. <br /></td></tr>
<tr class="separator:aad14bb5b43515d20d775ee5650fef2e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95fb541cd486ed85e2b923cc30ffa401"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a95fb541cd486ed85e2b923cc30ffa401"></a>
<a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a91bc3155f01ef75b2c1abbd93f8b9a9d">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a95fb541cd486ed85e2b923cc30ffa401">cend</a> ()</td></tr>
<tr class="memdesc:a95fb541cd486ed85e2b923cc30ffa401"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const iterator to the element following the last element of the set. This element acts as a placeholder; attempting to access it results in undefined behavior. <br /></td></tr>
<tr class="separator:a95fb541cd486ed85e2b923cc30ffa401"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a247121f9590f961dcb7e42c8e993913b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a247121f9590f961dcb7e42c8e993913b"></a>
<a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#ac86d5bf552346ebfdfb0b4f9b3341387">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a247121f9590f961dcb7e42c8e993913b">rbegin</a> ()</td></tr>
<tr class="memdesc:a247121f9590f961dcb7e42c8e993913b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the first element of the reversed set. <br /></td></tr>
<tr class="separator:a247121f9590f961dcb7e42c8e993913b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd89936ea881bb6b7b3a370e7ee26c6c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abd89936ea881bb6b7b3a370e7ee26c6c"></a>
<a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a911e21a152fe148f596f8ac83c233145">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#abd89936ea881bb6b7b3a370e7ee26c6c">rbegin</a> () const </td></tr>
<tr class="memdesc:abd89936ea881bb6b7b3a370e7ee26c6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const reverse iterator to the first element of the reversed set. <br /></td></tr>
<tr class="separator:abd89936ea881bb6b7b3a370e7ee26c6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78e9f98e02ed2fdd785c7f325734a9b6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a78e9f98e02ed2fdd785c7f325734a9b6"></a>
<a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a911e21a152fe148f596f8ac83c233145">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a78e9f98e02ed2fdd785c7f325734a9b6">crbegin</a> ()</td></tr>
<tr class="memdesc:a78e9f98e02ed2fdd785c7f325734a9b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const reverse iterator to the first element of the reversed set. <br /></td></tr>
<tr class="separator:a78e9f98e02ed2fdd785c7f325734a9b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45b8533dc27c7f1d582f45c90a00ec73"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#ac86d5bf552346ebfdfb0b4f9b3341387">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a45b8533dc27c7f1d582f45c90a00ec73">rend</a> ()</td></tr>
<tr class="memdesc:a45b8533dc27c7f1d582f45c90a00ec73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reverse iterator to the element following the last element of the reversed set.  <a href="#a45b8533dc27c7f1d582f45c90a00ec73">More...</a><br /></td></tr>
<tr class="separator:a45b8533dc27c7f1d582f45c90a00ec73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1528e14abfe9ba9545354fcfb4dbb1e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a911e21a152fe148f596f8ac83c233145">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#af1528e14abfe9ba9545354fcfb4dbb1e">rend</a> () const </td></tr>
<tr class="memdesc:af1528e14abfe9ba9545354fcfb4dbb1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const reverse iterator to the element following the last element of the reversed set.  <a href="#af1528e14abfe9ba9545354fcfb4dbb1e">More...</a><br /></td></tr>
<tr class="separator:af1528e14abfe9ba9545354fcfb4dbb1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ce5e7966b689978ceff3d98cd596e39"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a911e21a152fe148f596f8ac83c233145">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a8ce5e7966b689978ceff3d98cd596e39">crend</a> ()</td></tr>
<tr class="memdesc:a8ce5e7966b689978ceff3d98cd596e39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const reverse iterator to the element following the last element of the reversed set.  <a href="#a8ce5e7966b689978ceff3d98cd596e39">More...</a><br /></td></tr>
<tr class="separator:a8ce5e7966b689978ceff3d98cd596e39"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a23069c2f11db195a2915ca8b871b35f2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a23069c2f11db195a2915ca8b871b35f2"></a>
static constexpr const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a23069c2f11db195a2915ca8b871b35f2">c_bExtractLockExternal</a> = false</td></tr>
<tr class="memdesc:a23069c2f11db195a2915ca8b871b35f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Group of <code>extract_xxx</code> functions does not require external locking. <br /></td></tr>
<tr class="separator:a23069c2f11db195a2915ca8b871b35f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class RCU, class T, class Traits = feldman_hashset::traits&gt;<br />
class cds::intrusive::FeldmanHashSet&lt; cds::urcu::gc&lt; RCU &gt;, T, Traits &gt;</h3>

<p>Intrusive hash set based on multi-level array, <a class="el" href="namespacecds_1_1urcu.html#cds_urcu_desc">RCU</a> specialization. </p>
<p><a class="anchor" id="cds_intrusive_FeldmanHashSet_rcu"></a> Source:</p><ul>
<li>[2013] Steven Feldman, Pierre LaBorde, Damian Dechev "Concurrent Multi-level Arrays:
    Wait-free Extensible Hash Maps"</li>
</ul>
<p>See algorithm short description <a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set.html#cds_intrusive_FeldmanHashSet_hp">here</a></p>
<dl class="section note"><dt>Note</dt><dd>Two important things you should keep in mind when you're using <code>FeldmanHashSet</code>:<ul>
<li>all keys must be fixed-size. It means that you cannot use <code>std::string</code> as a key for <code>FeldmanHashSet</code>. Instead, for the strings you should use well-known hashing algorithms like <a href="https://en.wikipedia.org/wiki/Secure_Hash_Algorithm">SHA1, SHA2</a>, <a href="https://en.wikipedia.org/wiki/MurmurHash">MurmurHash</a>, <a href="https://en.wikipedia.org/wiki/CityHash">CityHash</a> or its successor <a href="https://code.google.com/p/farmhash/">FarmHash</a> and so on, which converts variable-length strings to fixed-length bit-strings, and use that hash as a key in <code>FeldmanHashSet</code>.</li>
<li><code>FeldmanHashSet</code> uses a perfect hashing. It means that if two different keys, for example, of type <code>std::string</code>, have identical hash then you cannot insert both that keys in the set. <code>FeldmanHashSet</code> does not maintain the key, it maintains its fixed-size hash value.</li>
</ul>
</dd></dl>
<p>Template parameters:</p><ul>
<li><code>RCU</code> - one of <a class="el" href="namespacecds_1_1urcu.html#cds_urcu_gc">RCU type</a></li>
<li><code>T</code> - a value type to be stored in the set</li>
<li><code>Traits</code> - type traits, the structure based on <code><a class="el" href="structcds_1_1intrusive_1_1feldman__hashset_1_1traits.html" title="FeldmanHashSet traits ">feldman_hashset::traits</a></code> or result of <code><a class="el" href="structcds_1_1intrusive_1_1feldman__hashset_1_1make__traits.html" title="Metafunction converting option list to feldman_hashset::traits. ">feldman_hashset::make_traits</a></code> metafunction. <code>Traits</code> is the mandatory argument because it has one mandatory type - an <a class="el" href="structcds_1_1intrusive_1_1feldman__hashset_1_1traits.html#a8135cdf1f6605dce0c0c24dcb6d0a9e7">accessor</a> to hash value of <code>T</code>. The set algorithm does not calculate that hash value.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>Before including <code>&lt;cds/intrusive/feldman_hashset_rcu.h&gt;</code> you should include appropriate RCU header file, see <a class="el" href="namespacecds_1_1urcu.html#cds_urcu_gc">RCU type</a> for list of existing RCU class and corresponding header files.</dd></dl>
<p>The set supports <a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#cds_intrusive_FeldmanHashSet_rcu_iterators">bidirectional thread-safe iterators</a></p>
<p>with some restrictions. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a9794b380100d87c105735ded92151df5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , class T , class Traits  = feldman_hashset::traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set.html">cds::intrusive::FeldmanHashSet</a>&lt; cds::urcu::gc&lt; RCU &gt;, T, Traits &gt;::<a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set.html">FeldmanHashSet</a> </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>head_bits</em> = <code>8</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>array_bits</em> = <code>4</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates empty set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">head_bits</td><td>2<sup>head_bits</sup> specifies the size of head array, minimum is 4. </td></tr>
    <tr><td class="paramname">array_bits</td><td>2<sup>array_bits</sup> specifies the size of array node, minimum is 2.</td></tr>
  </table>
  </dd>
</dl>
<p>Equation for <code>head_bits</code> and <code>array_bits:</code> </p><div class="fragment"><div class="line"><span class="keyword">sizeof</span>(<a class="code" href="classcds_1_1intrusive_1_1_feldman_hash_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a7eabcbb66ee3808ad3dfee864f90f407">hash_type</a>) * 8 == head_bits + N * array_bits</div>
</div><!-- fragment --><p> where <code>N</code> is multi-level array depth. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a9c97fdc4e1ee28705eb7c94d267d9a97"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , class T , class Traits  = feldman_hashset::traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#ab753ba63ca6592e3bd6d1b048316df32">iterator</a> <a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set.html">cds::intrusive::FeldmanHashSet</a>&lt; cds::urcu::gc&lt; RCU &gt;, T, Traits &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the beginning of the set. </p>
<p><a class="anchor" id="cds_intrusive_FeldmanHashSet_rcu_iterators"></a>The set supports thread-safe iterators: you may iterate over the set in multi-threaded environment under explicit RCU lock. RCU lock requirement means that inserting or searching is allowed but you must not erase the items from the set since erasing under RCU lock can lead to a deadlock. However, another thread can call <code><a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a2d44403b71d78b9f52a8e4c797b1a047" title="Deletes the item from the set. ">erase()</a></code> safely while your thread is iterating.</p>
<p>A typical example is: </p><div class="fragment"><div class="line"><span class="keyword">struct </span>foo {</div>
<div class="line">    uint32_t    hash;</div>
<div class="line">    <span class="comment">// ... other fields</span></div>
<div class="line">    uint32_t    payload; <span class="comment">// only for example</span></div>
<div class="line">};</div>
<div class="line"><span class="keyword">struct </span>set_traits: <a class="code" href="structcds_1_1intrusive_1_1feldman__hashset_1_1traits.html">cds::intrusive::feldman_hashset::traits</a></div>
<div class="line">{</div>
<div class="line">    <span class="keyword">struct </span><a class="code" href="classcds_1_1intrusive_1_1_feldman_hash_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a2fa65f18f80ba101e5e2e1bda056ee1c">hash_accessor</a> {</div>
<div class="line">        uint32_t operator()( foo <span class="keyword">const</span>&amp; src )<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">        </span>{</div>
<div class="line">            retur src.hash;</div>
<div class="line">        }</div>
<div class="line">    };</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keyword">typedef</span> cds::urcu::gc&lt; cds::urcu::general_buffered&lt;&gt;&gt; rcu;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="classcds_1_1intrusive_1_1_feldman_hash_set.html">cds::intrusive::FeldmanHashSet&lt; rcu, foo, set_traits &gt;</a> set_type;</div>
<div class="line"></div>
<div class="line">set_type s;</div>
<div class="line"></div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// iterate over the set</span></div>
<div class="line">{</div>
<div class="line">    <span class="comment">// lock the RCU.</span></div>
<div class="line">    <span class="keyword">typename</span> set_type::rcu_lock l; <span class="comment">// scoped RCU lock</span></div>
<div class="line"></div>
<div class="line">    <span class="comment">// traverse the set</span></div>
<div class="line">    <span class="keywordflow">for</span> ( <span class="keyword">auto</span> i = s.begin(); i != s.end(); ++i ) {</div>
<div class="line">        <span class="comment">// deal with i. Remember, erasing is prohibited here!</span></div>
<div class="line">        i-&gt;payload++;</div>
<div class="line">    }</div>
<div class="line">} <span class="comment">// at this point RCU lock is released</span></div>
</div><!-- fragment --><p>Each iterator object supports the common interface:</p><ul>
<li>dereference operators: <div class="fragment"><div class="line"><a class="code" href="classcds_1_1intrusive_1_1_feldman_hash_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a436fcafecec43d0985ca2ba3a651cf01">value_type</a> [<span class="keyword">const</span>] * operator -&gt;() noexcept</div>
<div class="line"><a class="code" href="classcds_1_1intrusive_1_1_feldman_hash_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a436fcafecec43d0985ca2ba3a651cf01">value_type</a> [const] &amp; operator *() noexcept</div>
</div><!-- fragment --></li>
<li>pre-increment and pre-decrement. Post-operators is not supported</li>
<li>equality operators <code>==</code> and <code>!=</code>. Iterators are equal iff they point to the same cell of the same array node. Note that for two iterators <code>it1</code> and <code>it2</code> the condition <code> it1 == it2 </code> does not entail <code> &amp;(*it1) == &amp;(*it2) </code>: welcome to concurrent containers</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>It is possible the item can be iterated more that once, for example, if an iterator points to the item in an array node that is being splitted. </dd></dl>

</div>
</div>
<a class="anchor" id="ae21837fc8f2a3220e1acc8a81785f1b0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , class T , class Traits  = feldman_hashset::traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set.html">cds::intrusive::FeldmanHashSet</a>&lt; cds::urcu::gc&lt; RCU &gt;, T, Traits &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clears the set (non-atomic) </p>
<p>The function unlink all data node from the set. The function is not atomic but is thread-safe. After <code>clear</code>() the set may not be empty because another threads may insert items.</p>
<p>For each item the <code>disposer</code> is called after unlinking. </p>

</div>
</div>
<a class="anchor" id="a8e62e0e52edcfae98b3f9f7432e0b368"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , class T , class Traits  = feldman_hashset::traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set.html">cds::intrusive::FeldmanHashSet</a>&lt; cds::urcu::gc&lt; RCU &gt;, T, Traits &gt;::contains </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a7eabcbb66ee3808ad3dfee864f90f407">hash_type</a> const &amp;&#160;</td>
          <td class="paramname"><em>hash</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether the set contains <code>hash</code>. </p>
<p>The function searches the item by its <code>hash</code> and returns <code>true</code> if it is found, or <code>false</code> otherwise.</p>
<p>The function applies RCU lock internally. </p>

</div>
</div>
<a class="anchor" id="a8ce5e7966b689978ceff3d98cd596e39"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , class T , class Traits  = feldman_hashset::traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a911e21a152fe148f596f8ac83c233145">const_reverse_iterator</a> <a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set.html">cds::intrusive::FeldmanHashSet</a>&lt; cds::urcu::gc&lt; RCU &gt;, T, Traits &gt;::crend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a const reverse iterator to the element following the last element of the reversed set. </p>
<p>It corresponds to the element preceding the first element of the non-reversed container. This element acts as a placeholder, attempting to access it results in undefined behavior. </p>

</div>
</div>
<a class="anchor" id="ab1b5ff9d36b3e81cde94a94593745926"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , class T , class Traits  = feldman_hashset::traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set.html">cds::intrusive::FeldmanHashSet</a>&lt; cds::urcu::gc&lt; RCU &gt;, T, Traits &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the set is empty. </p>
<p>Emptiness is checked by item counting: if item count is zero then the set is empty. Thus, the correct item counting feature is an important part of the set implementation. </p>

</div>
</div>
<a class="anchor" id="a2d44403b71d78b9f52a8e4c797b1a047"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , class T , class Traits  = feldman_hashset::traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set.html">cds::intrusive::FeldmanHashSet</a>&lt; cds::urcu::gc&lt; RCU &gt;, T, Traits &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a7eabcbb66ee3808ad3dfee864f90f407">hash_type</a> const &amp;&#160;</td>
          <td class="paramname"><em>hash</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deletes the item from the set. </p>
<p>The function searches <code>hash</code> in the set, unlinks the item found, and returns <code>true</code>. If that item is not found the function returns <code>false</code>.</p>
<p>The <a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a5f82187512125ef31e08f55a0d4d86b7">disposer</a> specified in <code>Traits</code> is called by garbage collector <code>GC</code> asynchronously.</p>
<p>RCU should not be locked. The function locks RCU internally. </p>

</div>
</div>
<a class="anchor" id="a336144c3b9ef30873da716277f617527"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , class T , class Traits  = feldman_hashset::traits&gt; </div>
<div class="memtemplate">
template&lt;typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set.html">cds::intrusive::FeldmanHashSet</a>&lt; cds::urcu::gc&lt; RCU &gt;, T, Traits &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a7eabcbb66ee3808ad3dfee864f90f407">hash_type</a> const &amp;&#160;</td>
          <td class="paramname"><em>hash</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deletes the item from the set. </p>
<p>The function searches <code>hash</code> in the set, call <code>f</code> functor with item found, and unlinks it from the set. The <a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a5f82187512125ef31e08f55a0d4d86b7">disposer</a> specified in <code>Traits</code> is called by garbage collector <code>GC</code> asynchronously.</p>
<p>The <code>Func</code> interface is </p><div class="fragment"><div class="line"><span class="keyword">struct </span>functor {</div>
<div class="line">    <span class="keywordtype">void</span> operator()( <a class="code" href="classcds_1_1intrusive_1_1_feldman_hash_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a436fcafecec43d0985ca2ba3a651cf01">value_type</a>&amp; item );</div>
<div class="line">};</div>
</div><!-- fragment --><p>If <code>hash</code> is not found the function returns <code>false</code>.</p>
<p>RCU should not be locked. The function locks RCU internally. </p>

</div>
</div>
<a class="anchor" id="afdcc102e63adf30c70c786713fa3f411"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , class T , class Traits  = feldman_hashset::traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a7ab7acb9b825e2af49051f7d459faf63">exempt_ptr</a> <a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set.html">cds::intrusive::FeldmanHashSet</a>&lt; cds::urcu::gc&lt; RCU &gt;, T, Traits &gt;::extract </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a7eabcbb66ee3808ad3dfee864f90f407">hash_type</a> const &amp;&#160;</td>
          <td class="paramname"><em>hash</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extracts the item with specified <code>hash</code>. </p>
<p>The function searches <code>hash</code> in the set, unlinks it from the set, and returns <a class="el" href="classcds_1_1urcu_1_1exempt__ptr.html">exempt_ptr</a> pointer to the item found. If the item with key equal to <code>key</code> is not found the function returns an empty <code>exempt_ptr</code>.</p>
<p>RCU <code>synchronize</code> method can be called. RCU should NOT be locked. The function does not call the disposer for the item found. The disposer will be implicitly invoked when the returned object is destroyed or when its <code>release()</code> member function is called. Example: </p><div class="fragment"><div class="line"><span class="keyword">typedef</span> <a class="code" href="classcds_1_1intrusive_1_1_feldman_hash_set.html">cds::intrusive::FeldmanHashSet&lt; cds::urcu::gc&lt; cds::urcu::general_buffered&lt;&gt;</a> &gt;, foo, my_traits &gt; set_type;</div>
<div class="line">set_type theSet;</div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">typename</span> set_type::exempt_ptr ep( theSet.extract( 5 ));</div>
<div class="line"><span class="keywordflow">if</span> ( ep ) {</div>
<div class="line">    <span class="comment">// Deal with ep</span></div>
<div class="line">    <span class="comment">//...</span></div>
<div class="line"></div>
<div class="line">    <span class="comment">// Dispose returned item.</span></div>
<div class="line">    ep.release();</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a0b78c7058b1b8ac0a725bf055b3452ae"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , class T , class Traits  = feldman_hashset::traits&gt; </div>
<div class="memtemplate">
template&lt;typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set.html">cds::intrusive::FeldmanHashSet</a>&lt; cds::urcu::gc&lt; RCU &gt;, T, Traits &gt;::find </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a7eabcbb66ee3808ad3dfee864f90f407">hash_type</a> const &amp;&#160;</td>
          <td class="paramname"><em>hash</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds an item by it's <code>hash</code>. </p>
<p>The function searches the item by <code>hash</code> and calls the functor <code>f</code> for item found. The interface of <code>Func</code> functor is: </p><div class="fragment"><div class="line"><span class="keyword">struct </span>functor {</div>
<div class="line">    <span class="keywordtype">void</span> operator()( <a class="code" href="classcds_1_1intrusive_1_1_feldman_hash_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a436fcafecec43d0985ca2ba3a651cf01">value_type</a>&amp; item );</div>
<div class="line">};</div>
</div><!-- fragment --><p> where <code>item</code> is the item found.</p>
<p>The functor may change non-key fields of <code>item</code>. Note that the functor is only guarantee that <code>item</code> cannot be disposed during the functor is executing. The functor does not serialize simultaneous access to the set's <code>item</code>. If such access is possible you must provide your own synchronization schema on item level to prevent unsafe item modifications.</p>
<p>The function returns <code>true</code> if <code>hash</code> is found, <code>false</code> otherwise.</p>
<p>The function applies RCU lock internally. </p>

</div>
</div>
<a class="anchor" id="a63b8dbb1cb0e7dc355392ec8a29660a3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , class T , class Traits  = feldman_hashset::traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a436fcafecec43d0985ca2ba3a651cf01">value_type</a>* <a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set.html">cds::intrusive::FeldmanHashSet</a>&lt; cds::urcu::gc&lt; RCU &gt;, T, Traits &gt;::get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a7eabcbb66ee3808ad3dfee864f90f407">hash_type</a> const &amp;&#160;</td>
          <td class="paramname"><em>hash</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds an item by it's <code>hash</code> and returns the item found. </p>
<p>The function searches the item by its <code>hash</code> and returns the pointer to the item found. If <code>hash</code> is not found the function returns <code>nullptr</code>.</p>
<p>RCU should be locked before the function invocation. Returned pointer is valid only while RCU is locked.</p>
<p>Usage: </p><div class="fragment"><div class="line"><span class="keyword">typedef</span> <a class="code" href="classcds_1_1intrusive_1_1_feldman_hash_set.html">cds::intrusive::FeldmanHashSet&lt; your_template_params &gt;</a>  my_set;</div>
<div class="line">my_set theSet;</div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line">{</div>
<div class="line">    <span class="comment">// lock RCU</span></div>
<div class="line">    my_set::rcu_lock;</div>
<div class="line"></div>
<div class="line">    foo * p = theSet.<a class="code" href="classcds_1_1intrusive_1_1_feldman_hash_set.html#a9fd9909832c40c32e6ce0cb83594543f">get</a>( 5 );</div>
<div class="line">    <span class="keywordflow">if</span> ( p ) {</div>
<div class="line">        <span class="comment">// Deal with p</span></div>
<div class="line">        <span class="comment">//...</span></div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a7965078c29fe15f65b3e8bd31a0d4b16"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , class T , class Traits  = feldman_hashset::traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set.html">cds::intrusive::FeldmanHashSet</a>&lt; cds::urcu::gc&lt; RCU &gt;, T, Traits &gt;::get_level_statistics </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structcds_1_1intrusive_1_1feldman__hashset_1_1level__statistics.html">feldman_hashset::level_statistics</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>stat</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Collects tree level statistics into <code>stat</code>. </p>
<p><a class="anchor" id="cds_intrusive_FeldmanHashSet_hp_get_level_statistics"></a>The function traverses the set and collects staistics for each level of the tree into <code><a class="el" href="structcds_1_1intrusive_1_1feldman__hashset_1_1level__statistics.html" title="One-level statistics, see FeldmanHashSet::get_level_statistics. ">feldman_hashset::level_statistics</a></code> struct. The element of <code>stat</code>[i] represents statistics for level <code>i</code>, level 0 is head array. The function is thread-safe and may be called in multi-threaded environment.</p>
<p>Result can be useful for estimating efficiency of hash functor you use. </p>

</div>
</div>
<a class="anchor" id="a4538127071b47dd6d7d475bbaaf029e9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , class T , class Traits  = feldman_hashset::traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set.html">cds::intrusive::FeldmanHashSet</a>&lt; cds::urcu::gc&lt; RCU &gt;, T, Traits &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a436fcafecec43d0985ca2ba3a651cf01">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts new node. </p>
<p>The function inserts <code>val</code> in the set if it does not contain an item with that hash.</p>
<p>Returns <code>true</code> if <code>val</code> is placed into the set, <code>false</code> otherwise.</p>
<p>The function locks RCU internally. </p>

</div>
</div>
<a class="anchor" id="a8ecf10d278980c4885fd86472ee660d9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , class T , class Traits  = feldman_hashset::traits&gt; </div>
<div class="memtemplate">
template&lt;typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set.html">cds::intrusive::FeldmanHashSet</a>&lt; cds::urcu::gc&lt; RCU &gt;, T, Traits &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a436fcafecec43d0985ca2ba3a651cf01">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts new node. </p>
<p>This function is intended for derived non-intrusive containers.</p>
<p>The function allows to split creating of new item into two part:</p><ul>
<li>create item with key only</li>
<li>insert new item into the set</li>
<li>if inserting is success, calls <code>f</code> functor to initialize <code>val</code>.</li>
</ul>
<p>The functor signature is: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> func( <a class="code" href="classcds_1_1intrusive_1_1_feldman_hash_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a436fcafecec43d0985ca2ba3a651cf01">value_type</a>&amp; val );</div>
</div><!-- fragment --><p> where <code>val</code> is the item inserted.</p>
<p>The user-defined functor is called only if the inserting is success.</p>
<p>The function locks RCU internally. </p><dl class="section warning"><dt>Warning</dt><dd>See <a class="el" href="namespacecds_1_1intrusive.html#cds_intrusive_item_creating">insert item troubleshooting</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a45b8533dc27c7f1d582f45c90a00ec73"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , class T , class Traits  = feldman_hashset::traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#ac86d5bf552346ebfdfb0b4f9b3341387">reverse_iterator</a> <a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set.html">cds::intrusive::FeldmanHashSet</a>&lt; cds::urcu::gc&lt; RCU &gt;, T, Traits &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reverse iterator to the element following the last element of the reversed set. </p>
<p>It corresponds to the element preceding the first element of the non-reversed container. This element acts as a placeholder, attempting to access it results in undefined behavior. </p>

</div>
</div>
<a class="anchor" id="af1528e14abfe9ba9545354fcfb4dbb1e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , class T , class Traits  = feldman_hashset::traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a911e21a152fe148f596f8ac83c233145">const_reverse_iterator</a> <a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set.html">cds::intrusive::FeldmanHashSet</a>&lt; cds::urcu::gc&lt; RCU &gt;, T, Traits &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a const reverse iterator to the element following the last element of the reversed set. </p>
<p>It corresponds to the element preceding the first element of the non-reversed container. This element acts as a placeholder, attempting to access it results in undefined behavior. </p>

</div>
</div>
<a class="anchor" id="ae64d8b9ead20e7130cca3d11cfb76d2c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , class T , class Traits  = feldman_hashset::traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set.html">cds::intrusive::FeldmanHashSet</a>&lt; cds::urcu::gc&lt; RCU &gt;, T, Traits &gt;::unlink </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a436fcafecec43d0985ca2ba3a651cf01">value_type</a> const &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unlinks the item <code>val</code> from the set. </p>
<p>The function searches the item <code>val</code> in the set and unlink it if it is found and its address is equal to <code>&amp;val</code>.</p>
<p>The function returns <code>true</code> if success and <code>false</code> otherwise.</p>
<p>RCU should not be locked. The function locks RCU internally. </p>

</div>
</div>
<a class="anchor" id="ad515bc67e591341c91063a01f7586273"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , class T , class Traits  = feldman_hashset::traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;bool, bool&gt; <a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set.html">cds::intrusive::FeldmanHashSet</a>&lt; cds::urcu::gc&lt; RCU &gt;, T, Traits &gt;::update </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#a436fcafecec43d0985ca2ba3a651cf01">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bInsert</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Updates the node. </p>
<p>Performs inserting or updating the item with hash value equal to <code>val</code>.</p><ul>
<li>If hash value is found then existing item is replaced with <code>val</code>, old item is disposed with <code>Traits::disposer</code>. Note that the disposer is called by <code>GC</code> asynchronously. The function returns <code> std::pair&lt;true, false&gt; </code></li>
<li>If hash value is not found and <code>bInsert</code> is <code>true</code> then <code>val</code> is inserted, the function returns <code> std::pair&lt;true, true&gt; </code></li>
<li>If hash value is not found and <code>bInsert</code> is <code>false</code> then the set is unchanged, the function returns <code> std::pair&lt;false, false&gt; </code></li>
</ul>
<p>Returns <code> std::pair&lt;bool, bool&gt; </code> where <code>first</code> is <code>true</code> if operation is successfull (i.e. the item has been inserted or updated), <code>second</code> is <code>true</code> if new item has been added or <code>false</code> if the set contains that hash.</p>
<p>The function locks RCU internally. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>cds/intrusive/feldman_hashset_rcu.h</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<hr/>
<div align="right">
  <b>cds</b> <b>2.1.0</b> 
  Developed by <i>Maxim Khizhinsky aka khizmax</i> 2007 - 2015
  <br/>
  <i>Autogenerated Wed Jan 6 2016 16:00:43 by Doxygen 1.8.10</i>
</div>
</body>
</html>
