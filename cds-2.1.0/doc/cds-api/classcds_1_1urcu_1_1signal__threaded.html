<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>cds: cds::urcu::signal_threaded&lt; Buffer, Lock, DisposerThread, Backoff &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">cds
   &#160;<span id="projectnumber">2.1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="classes.html"><span>Data&#160;Structure&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Data&#160;Fields</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classcds_1_1urcu_1_1signal__threaded.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a>  </div>
  <div class="headertitle">
<div class="title">cds::urcu::signal_threaded&lt; Buffer, Lock, DisposerThread, Backoff &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>User-space signal-handled RCU with deferred threaded reclamation.  
 <a href="classcds_1_1urcu_1_1signal__threaded.html#details">More...</a></p>

<p><code>#include &lt;cds/urcu/signal_threaded.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for cds::urcu::signal_threaded&lt; Buffer, Lock, DisposerThread, Backoff &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classcds_1_1urcu_1_1signal__threaded.png" usemap="#cds::urcu::signal_threaded&lt; Buffer, Lock, DisposerThread, Backoff &gt;_map" alt=""/>
  <map id="cds::urcu::signal_threaded&lt; Buffer, Lock, DisposerThread, Backoff &gt;_map" name="cds::urcu::signal_threaded&lt; Buffer, Lock, DisposerThread, Backoff &gt;_map">
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a503fb04b6967aaa1e178cf5620ec44bb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a503fb04b6967aaa1e178cf5620ec44bb"></a>
typedef Buffer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1urcu_1_1signal__threaded.html#a503fb04b6967aaa1e178cf5620ec44bb">buffer_type</a></td></tr>
<tr class="memdesc:a503fb04b6967aaa1e178cf5620ec44bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Buffer type. <br /></td></tr>
<tr class="separator:a503fb04b6967aaa1e178cf5620ec44bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d5fc7eacdbf937a2408d2d022bdde5b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8d5fc7eacdbf937a2408d2d022bdde5b"></a>
typedef Lock&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1urcu_1_1signal__threaded.html#a8d5fc7eacdbf937a2408d2d022bdde5b">lock_type</a></td></tr>
<tr class="memdesc:a8d5fc7eacdbf937a2408d2d022bdde5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lock type. <br /></td></tr>
<tr class="separator:a8d5fc7eacdbf937a2408d2d022bdde5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae00f185a57534e8b682ea1d2f7d2c0be"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae00f185a57534e8b682ea1d2f7d2c0be"></a>
typedef Backoff&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1urcu_1_1signal__threaded.html#ae00f185a57534e8b682ea1d2f7d2c0be">back_off</a></td></tr>
<tr class="memdesc:ae00f185a57534e8b682ea1d2f7d2c0be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Back-off scheme. <br /></td></tr>
<tr class="separator:ae00f185a57534e8b682ea1d2f7d2c0be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25acf582f90d1fe5d8440ac47354f605"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a25acf582f90d1fe5d8440ac47354f605"></a>
typedef DisposerThread&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1urcu_1_1signal__threaded.html#a25acf582f90d1fe5d8440ac47354f605">disposer_thread</a></td></tr>
<tr class="memdesc:a25acf582f90d1fe5d8440ac47354f605"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disposer thread type. <br /></td></tr>
<tr class="separator:a25acf582f90d1fe5d8440ac47354f605"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a655fe9272e8dddbf5e2290b96feca463"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a655fe9272e8dddbf5e2290b96feca463"></a>
typedef <a class="el" href="structcds_1_1urcu_1_1signal__threaded__tag.html">signal_threaded_tag</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1urcu_1_1signal__threaded.html#a655fe9272e8dddbf5e2290b96feca463">rcu_tag</a></td></tr>
<tr class="memdesc:a655fe9272e8dddbf5e2290b96feca463"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thread-side RCU part. <br /></td></tr>
<tr class="separator:a655fe9272e8dddbf5e2290b96feca463"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4de28aedc6ce358d48a5e4bb0c9253a6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4de28aedc6ce358d48a5e4bb0c9253a6"></a>
typedef base_class::thread_gc&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1urcu_1_1signal__threaded.html#a4de28aedc6ce358d48a5e4bb0c9253a6">thread_gc</a></td></tr>
<tr class="memdesc:a4de28aedc6ce358d48a5e4bb0c9253a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access lock class. <br /></td></tr>
<tr class="separator:a4de28aedc6ce358d48a5e4bb0c9253a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88f55a8e3cf37c6f1ccc021eafd22399"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a88f55a8e3cf37c6f1ccc021eafd22399"></a>
typedef thread_gc::scoped_lock&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1urcu_1_1signal__threaded.html#a88f55a8e3cf37c6f1ccc021eafd22399">scoped_lock</a></td></tr>
<tr class="memdesc:a88f55a8e3cf37c6f1ccc021eafd22399"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access lock class. <br /></td></tr>
<tr class="separator:a88f55a8e3cf37c6f1ccc021eafd22399"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:abcc93e3859a57be91e5d17d0f2213042"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1urcu_1_1signal__threaded.html#abcc93e3859a57be91e5d17d0f2213042">retire_ptr</a> (<a class="el" href="namespacecds_1_1urcu.html#a9fd06318cc85d4d956ba7fb8152083c1">retired_ptr</a> &amp;p)</td></tr>
<tr class="memdesc:abcc93e3859a57be91e5d17d0f2213042"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retires <code>p</code> pointer.  <a href="#abcc93e3859a57be91e5d17d0f2213042">More...</a><br /></td></tr>
<tr class="separator:abcc93e3859a57be91e5d17d0f2213042"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c483f4be42081ae4ebd7f2e2fcdae5f"><td class="memTemplParams" colspan="2"><a class="anchor" id="a1c483f4be42081ae4ebd7f2e2fcdae5f"></a>
template&lt;typename ForwardIterator &gt; </td></tr>
<tr class="memitem:a1c483f4be42081ae4ebd7f2e2fcdae5f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1urcu_1_1signal__threaded.html#a1c483f4be42081ae4ebd7f2e2fcdae5f">batch_retire</a> (ForwardIterator itFirst, ForwardIterator itLast)</td></tr>
<tr class="memdesc:a1c483f4be42081ae4ebd7f2e2fcdae5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retires the pointer chain [<code>itFirst</code>, <code>itLast</code>) <br /></td></tr>
<tr class="separator:a1c483f4be42081ae4ebd7f2e2fcdae5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61c5af3b2072c448a14ca843ffd769c5"><td class="memTemplParams" colspan="2"><a class="anchor" id="a61c5af3b2072c448a14ca843ffd769c5"></a>
template&lt;typename Func &gt; </td></tr>
<tr class="memitem:a61c5af3b2072c448a14ca843ffd769c5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1urcu_1_1signal__threaded.html#a61c5af3b2072c448a14ca843ffd769c5">batch_retire</a> (Func e)</td></tr>
<tr class="memdesc:a61c5af3b2072c448a14ca843ffd769c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retires the pointer chain until <code>Func</code> returns <code>nullptr</code> retired pointer. <br /></td></tr>
<tr class="separator:a61c5af3b2072c448a14ca843ffd769c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a494dc4d4b7c998adb6bd95a346d7d76f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a494dc4d4b7c998adb6bd95a346d7d76f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1urcu_1_1signal__threaded.html#a494dc4d4b7c998adb6bd95a346d7d76f">synchronize</a> ()</td></tr>
<tr class="memdesc:a494dc4d4b7c998adb6bd95a346d7d76f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits to finish a grace period and calls disposing thread. <br /></td></tr>
<tr class="separator:a494dc4d4b7c998adb6bd95a346d7d76f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c4585877821591a2b51af88e145aaac"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9c4585877821591a2b51af88e145aaac"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1urcu_1_1signal__threaded.html#a9c4585877821591a2b51af88e145aaac">capacity</a> () const </td></tr>
<tr class="memdesc:a9c4585877821591a2b51af88e145aaac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the threshold of internal buffer. <br /></td></tr>
<tr class="separator:a9c4585877821591a2b51af88e145aaac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92c91e23adb1bc1594430ba8d8a4ac51"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a92c91e23adb1bc1594430ba8d8a4ac51"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1urcu_1_1signal__threaded.html#a92c91e23adb1bc1594430ba8d8a4ac51">signal_no</a> () const </td></tr>
<tr class="memdesc:a92c91e23adb1bc1594430ba8d8a4ac51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the signal number stated for RCU. <br /></td></tr>
<tr class="separator:a92c91e23adb1bc1594430ba8d8a4ac51"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ac7991ba881d5b186df1f7bd805f93794"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac7991ba881d5b186df1f7bd805f93794"></a>
static <a class="el" href="classcds_1_1urcu_1_1signal__threaded.html">signal_threaded</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1urcu_1_1signal__threaded.html#ac7991ba881d5b186df1f7bd805f93794">instance</a> ()</td></tr>
<tr class="memdesc:ac7991ba881d5b186df1f7bd805f93794"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns singleton instance. <br /></td></tr>
<tr class="separator:ac7991ba881d5b186df1f7bd805f93794"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a751f80ff133d529aca77328e8de2259e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a751f80ff133d529aca77328e8de2259e"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1urcu_1_1signal__threaded.html#a751f80ff133d529aca77328e8de2259e">isUsed</a> ()</td></tr>
<tr class="memdesc:a751f80ff133d529aca77328e8de2259e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the singleton is created and ready to use. <br /></td></tr>
<tr class="separator:a751f80ff133d529aca77328e8de2259e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60a26f3309f69bf6c9d289e7fcc5b9ab"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1urcu_1_1signal__threaded.html#a60a26f3309f69bf6c9d289e7fcc5b9ab">Construct</a> (size_t nBufferCapacity=256, int nSignal=SIGUSR1)</td></tr>
<tr class="memdesc:a60a26f3309f69bf6c9d289e7fcc5b9ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates singleton object and starts reclamation thread.  <a href="#a60a26f3309f69bf6c9d289e7fcc5b9ab">More...</a><br /></td></tr>
<tr class="separator:a60a26f3309f69bf6c9d289e7fcc5b9ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa905191bf44d5837b0a6e467299aa7ef"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa905191bf44d5837b0a6e467299aa7ef"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1urcu_1_1signal__threaded.html#aa905191bf44d5837b0a6e467299aa7ef">Destruct</a> (bool bDetachAll=false)</td></tr>
<tr class="memdesc:aa905191bf44d5837b0a6e467299aa7ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys singleton object and terminates internal reclamation thread. <br /></td></tr>
<tr class="separator:aa905191bf44d5837b0a6e467299aa7ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a3583904e89072f611a938cb46761d3c5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3583904e89072f611a938cb46761d3c5"></a>
static bool const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1urcu_1_1signal__threaded.html#a3583904e89072f611a938cb46761d3c5">c_bBuffered</a> = true</td></tr>
<tr class="memdesc:a3583904e89072f611a938cb46761d3c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">This RCU buffers disposed elements. <br /></td></tr>
<tr class="separator:a3583904e89072f611a938cb46761d3c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class Buffer = cds::container::VyukovMPSCCycleQueue&lt; epoch_retired_ptr &gt;, class Lock = std::mutex, class DisposerThread = dispose_thread&lt;Buffer&gt;, class Backoff = cds::backoff::Default&gt;<br />
class cds::urcu::signal_threaded&lt; Buffer, Lock, DisposerThread, Backoff &gt;</h3>

<p>User-space signal-handled RCU with deferred threaded reclamation. </p>
<p>This implementation is similar to <a class="el" href="classcds_1_1urcu_1_1signal__buffered.html">signal_buffered</a> but separate thread is created for deleting the retired objects. Like <code>signal_buffered</code>, the class contains an internal buffer where retired objects are accumulated. When the buffer becomes full, the RCU <code>synchronize</code> function is called that waits until all reader/updater threads end up their read-side critical sections, i.e. until the RCU quiescent state will come. After that the "work ready" message is sent to reclamation thread. The reclamation thread frees the buffer. This synchronization cycle may be called in any thread that calls <a class="el" href="classcds_1_1urcu_1_1signal__threaded.html#abcc93e3859a57be91e5d17d0f2213042">retire_ptr</a> function.</p>
<p>There is a wrapper <a class="el" href="classcds_1_1urcu_1_1gc_3_01signal__threaded_3_01_buffer_00_01_lock_00_01_disposer_thread_00_01_backoff_01_4_01_4.html#cds_urcu_signal_threaded_gc">gc&lt;signal_threaded&gt;</a> for <code>signal_threaded</code> class that provides unified RCU interface. You should use this wrapper class instead <code>signal_threaded</code> </p>
<p>Template arguments:</p><ul>
<li><code>Buffer</code> - buffer type with FIFO semantics. Default is <code><a class="el" href="namespacecds_1_1container.html#a3d7b29c21c482acfe4bf2e0a1bd27a97" title="Vyukov&#39;s queue multiple producer - single consumer version. ">cds::container::VyukovMPSCCycleQueue</a></code>. See <a class="el" href="classcds_1_1urcu_1_1signal__buffered.html">signal_buffered</a> for description of buffer's interface. The buffer contains the objects of <a class="el" href="structcds_1_1epoch__retired__ptr.html">epoch_retired_ptr</a> type that contains additional <code>m_nEpoch</code> field. This field specifies an epoch when the object has been placed into the buffer. The <code>signal_threaded</code> object has a global epoch counter that is incremented on each <code><a class="el" href="classcds_1_1urcu_1_1signal__threaded.html#a494dc4d4b7c998adb6bd95a346d7d76f" title="Waits to finish a grace period and calls disposing thread. ">synchronize()</a></code> call. The epoch is used internally to prevent early deletion.</li>
<li><code>Lock</code> - mutex type, default is <code>std::mutex</code> </li>
<li><code>DisposerThread</code> - the reclamation thread class. Default is <a class="el" href="classcds_1_1urcu_1_1dispose__thread.html">cds::urcu::dispose_thread</a>, see the description of this class for required interface.</li>
<li><code>Backoff</code> - back-off schema, default is <a class="el" href="namespacecds_1_1backoff.html#a6d7bf77f149436d5d587a2ec841e5044" title="Default backoff strategy. ">cds::backoff::Default</a> </li>
</ul>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a60a26f3309f69bf6c9d289e7fcc5b9ab"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Buffer  = cds::container::VyukovMPSCCycleQueue&lt; epoch_retired_ptr &gt;, class Lock  = std::mutex, class DisposerThread  = dispose_thread&lt;Buffer&gt;, class Backoff  = cds::backoff::Default&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classcds_1_1urcu_1_1signal__threaded.html">cds::urcu::signal_threaded</a>&lt; Buffer, Lock, DisposerThread, Backoff &gt;::Construct </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nBufferCapacity</em> = <code>256</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nSignal</em> = <code>SIGUSR1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates singleton object and starts reclamation thread. </p>
<p>The <code>nBufferCapacity</code> parameter defines RCU threshold.</p>
<p>The <code>nSignal</code> parameter defines a signal number stated for RCU, default is <code>SIGUSR1</code> </p>

</div>
</div>
<a class="anchor" id="abcc93e3859a57be91e5d17d0f2213042"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Buffer  = cds::container::VyukovMPSCCycleQueue&lt; epoch_retired_ptr &gt;, class Lock  = std::mutex, class DisposerThread  = dispose_thread&lt;Buffer&gt;, class Backoff  = cds::backoff::Default&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classcds_1_1urcu_1_1signal__threaded.html">cds::urcu::signal_threaded</a>&lt; Buffer, Lock, DisposerThread, Backoff &gt;::retire_ptr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacecds_1_1urcu.html#a9fd06318cc85d4d956ba7fb8152083c1">retired_ptr</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retires <code>p</code> pointer. </p>
<p>The method pushes <code>p</code> pointer to internal buffer. When the buffer becomes full <a class="el" href="classcds_1_1urcu_1_1signal__threaded.html#a494dc4d4b7c998adb6bd95a346d7d76f">synchronize</a> function is called to wait for the end of grace period and then a message is sent to the reclamation thread. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>cds/urcu/details/sig_threaded.h</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<hr/>
<div align="right">
  <b>cds</b> <b>2.1.0</b> 
  Developed by <i>Maxim Khizhinsky aka khizmax</i> 2007 - 2015
  <br/>
  <i>Autogenerated Wed Jan 6 2016 16:00:49 by Doxygen 1.8.10</i>
</div>
</body>
</html>
