<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>cds: cds::intrusive Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">cds
   &#160;<span id="projectnumber">2.1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('namespacecds_1_1intrusive.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Data Structures</a>  </div>
  <div class="headertitle">
<div class="title">cds::intrusive Namespace Reference<div class="ingroups"><a class="el" href="group__cds__intrusive__containers.html">Intrusive containers</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Intrusive containers.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacecds_1_1intrusive_1_1basket__queue"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecds_1_1intrusive_1_1basket__queue.html">basket_queue</a></td></tr>
<tr class="memdesc:namespacecds_1_1intrusive_1_1basket__queue"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classcds_1_1intrusive_1_1_basket_queue.html" title="Basket lock-free queue (intrusive variant) ">BasketQueue</a> -related definitions. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacecds_1_1intrusive_1_1cuckoo"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecds_1_1intrusive_1_1cuckoo.html">cuckoo</a></td></tr>
<tr class="memdesc:namespacecds_1_1intrusive_1_1cuckoo"><td class="mdescLeft">&#160;</td><td class="mdescRight">CuckooSet-related definitions. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacecds_1_1intrusive_1_1ellen__bintree"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecds_1_1intrusive_1_1ellen__bintree.html">ellen_bintree</a></td></tr>
<tr class="memdesc:namespacecds_1_1intrusive_1_1ellen__bintree"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree.html" title="Ellen&#39;s et al binary search tree. ">EllenBinTree</a> related declarations. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacecds_1_1intrusive_1_1fcqueue"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecds_1_1intrusive_1_1fcqueue.html">fcqueue</a></td></tr>
<tr class="memdesc:namespacecds_1_1intrusive_1_1fcqueue"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classcds_1_1intrusive_1_1_f_c_queue.html" title="Flat-combining intrusive queue. ">FCQueue</a> related definitions. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacecds_1_1intrusive_1_1fcstack"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecds_1_1intrusive_1_1fcstack.html">fcstack</a></td></tr>
<tr class="memdesc:namespacecds_1_1intrusive_1_1fcstack"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classcds_1_1intrusive_1_1_f_c_stack.html" title="Flat-combining intrusive stack. ">FCStack</a> related definitions. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacecds_1_1intrusive_1_1feldman__hashset"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecds_1_1intrusive_1_1feldman__hashset.html">feldman_hashset</a></td></tr>
<tr class="memdesc:namespacecds_1_1intrusive_1_1feldman__hashset"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set.html" title="Intrusive hash set based on multi-level array. ">FeldmanHashSet</a> related definitions. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacecds_1_1intrusive_1_1lazy__list"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecds_1_1intrusive_1_1lazy__list.html">lazy_list</a></td></tr>
<tr class="memdesc:namespacecds_1_1intrusive_1_1lazy__list"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classcds_1_1intrusive_1_1_lazy_list.html" title="Lazy ordered single-linked list. ">LazyList</a> ordered list related definitions. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacecds_1_1intrusive_1_1michael__list"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecds_1_1intrusive_1_1michael__list.html">michael_list</a></td></tr>
<tr class="memdesc:namespacecds_1_1intrusive_1_1michael__list"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classcds_1_1intrusive_1_1_michael_list.html" title="Michael&#39;s lock-free ordered single-linked list. ">MichaelList</a> ordered list related definitions. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacecds_1_1intrusive_1_1michael__set"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecds_1_1intrusive_1_1michael__set.html">michael_set</a></td></tr>
<tr class="memdesc:namespacecds_1_1intrusive_1_1michael__set"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classcds_1_1intrusive_1_1_michael_hash_set.html" title="Michael&#39;s hash set. ">MichaelHashSet</a> related definitions. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacecds_1_1intrusive_1_1mspriority__queue"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecds_1_1intrusive_1_1mspriority__queue.html">mspriority_queue</a></td></tr>
<tr class="memdesc:namespacecds_1_1intrusive_1_1mspriority__queue"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classcds_1_1intrusive_1_1_m_s_priority_queue.html" title="Michael & Scott array-based lock-based concurrent priority queue heap. ">MSPriorityQueue</a> related definitions. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacecds_1_1intrusive_1_1msqueue"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecds_1_1intrusive_1_1msqueue.html">msqueue</a></td></tr>
<tr class="memdesc:namespacecds_1_1intrusive_1_1msqueue"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classcds_1_1intrusive_1_1_m_s_queue.html" title="Michael & Scott&#39;s intrusive lock-free queue. ">MSQueue</a> related definitions. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacecds_1_1intrusive_1_1opt"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecds_1_1intrusive_1_1opt.html">opt</a></td></tr>
<tr class="memdesc:namespacecds_1_1intrusive_1_1opt"><td class="mdescLeft">&#160;</td><td class="mdescRight">Common options for intrusive containers. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacecds_1_1intrusive_1_1optimistic__queue"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecds_1_1intrusive_1_1optimistic__queue.html">optimistic_queue</a></td></tr>
<tr class="memdesc:namespacecds_1_1intrusive_1_1optimistic__queue"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classcds_1_1intrusive_1_1_optimistic_queue.html" title="Optimistic intruive lock-free queue. ">OptimisticQueue</a> related definitions. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacecds_1_1intrusive_1_1segmented__queue"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecds_1_1intrusive_1_1segmented__queue.html">segmented_queue</a></td></tr>
<tr class="memdesc:namespacecds_1_1intrusive_1_1segmented__queue"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classcds_1_1intrusive_1_1_segmented_queue.html" title="Segmented queue. ">SegmentedQueue</a> -related declarations. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacecds_1_1intrusive_1_1single__link"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecds_1_1intrusive_1_1single__link.html">single_link</a></td></tr>
<tr class="memdesc:namespacecds_1_1intrusive_1_1single__link"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definitions common for single-linked data structures. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacecds_1_1intrusive_1_1skip__list"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecds_1_1intrusive_1_1skip__list.html">skip_list</a></td></tr>
<tr class="memdesc:namespacecds_1_1intrusive_1_1skip__list"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html" title="Lock-free skip-list set. ">SkipListSet</a> related definitions. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacecds_1_1intrusive_1_1split__list"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecds_1_1intrusive_1_1split__list.html">split_list</a></td></tr>
<tr class="memdesc:namespacecds_1_1intrusive_1_1split__list"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split-ordered list related definitions. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacecds_1_1intrusive_1_1striped__set"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecds_1_1intrusive_1_1striped__set.html">striped_set</a></td></tr>
<tr class="memdesc:namespacecds_1_1intrusive_1_1striped__set"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html" title="Striped hash set. ">StripedSet</a> related definitions. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacecds_1_1intrusive_1_1treiber__stack"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecds_1_1intrusive_1_1treiber__stack.html">treiber_stack</a></td></tr>
<tr class="memdesc:namespacecds_1_1intrusive_1_1treiber__stack"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classcds_1_1intrusive_1_1_treiber_stack.html" title="Treiber intrusive stack. ">TreiberStack</a> related definitions. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacecds_1_1intrusive_1_1tsigas__queue"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecds_1_1intrusive_1_1tsigas__queue.html">tsigas_queue</a></td></tr>
<tr class="memdesc:namespacecds_1_1intrusive_1_1tsigas__queue"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classcds_1_1intrusive_1_1_tsigas_cycle_queue.html" title="Non-blocking cyclic queue discovered by Philippas Tsigas and Yi Zhang. ">TsigasCycleQueue</a> related definitions. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacecds_1_1intrusive_1_1vyukov__queue"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecds_1_1intrusive_1_1vyukov__queue.html">vyukov_queue</a></td></tr>
<tr class="memdesc:namespacecds_1_1intrusive_1_1vyukov__queue"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classcds_1_1intrusive_1_1_vyukov_m_p_m_c_cycle_queue.html" title="Vyukov&#39;s MPMC bounded queue. ">VyukovMPMCCycleQueue</a> related definitions. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_basket_queue.html">BasketQueue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Basket lock-free queue (intrusive variant)  <a href="classcds_1_1intrusive_1_1_basket_queue.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html">CuckooSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cuckoo hash set.  <a href="classcds_1_1intrusive_1_1_cuckoo_set.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree.html">EllenBinTree</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ellen's et al binary search tree.  <a href="classcds_1_1intrusive_1_1_ellen_bin_tree.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html">EllenBinTree&lt; cds::urcu::gc&lt; RCU &gt;, Key, T, Traits &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ellen's et al binary search tree (RCU specialization)  <a href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_f_c_queue.html">FCQueue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flat-combining intrusive queue.  <a href="classcds_1_1intrusive_1_1_f_c_queue.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_f_c_stack.html">FCStack</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flat-combining intrusive stack.  <a href="classcds_1_1intrusive_1_1_f_c_stack.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set.html">FeldmanHashSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intrusive hash set based on multi-level array.  <a href="classcds_1_1intrusive_1_1_feldman_hash_set.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_feldman_hash_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html">FeldmanHashSet&lt; cds::urcu::gc&lt; RCU &gt;, T, Traits &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intrusive hash set based on multi-level array, <a class="el" href="namespacecds_1_1urcu.html#cds_urcu_desc">RCU</a> specialization.  <a href="classcds_1_1intrusive_1_1_feldman_hash_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcds_1_1intrusive_1_1get__node__traits.html">get_node_traits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Node traits selector metafunction.  <a href="structcds_1_1intrusive_1_1get__node__traits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_lazy_list.html">LazyList</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lazy ordered single-linked list.  <a href="classcds_1_1intrusive_1_1_lazy_list.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_lazy_list_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html">LazyList&lt; cds::urcu::gc&lt; RCU &gt;, T, Traits &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lazy ordered single-linked list (template specialization for <a class="el" href="namespacecds_1_1urcu.html#cds_urcu_desc">RCU</a>)  <a href="classcds_1_1intrusive_1_1_lazy_list_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_lazy_list_3_01gc_1_1nogc_00_01_t_00_01_traits_01_4.html">LazyList&lt; gc::nogc, T, Traits &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lazy single-linked list (template specialization for <code><a class="el" href="classcds_1_1gc_1_1nogc.html" title="No garbage collecting. ">gc::nogc</a></code>)  <a href="classcds_1_1intrusive_1_1_lazy_list_3_01gc_1_1nogc_00_01_t_00_01_traits_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_michael_hash_set.html">MichaelHashSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Michael's hash set.  <a href="classcds_1_1intrusive_1_1_michael_hash_set.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_michael_hash_set_3_01cds_1_1gc_1_1nogc_00_01_ordered_list_00_01_traits_01_4.html">MichaelHashSet&lt; cds::gc::nogc, OrderedList, Traits &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Michael's hash set (template specialization for <a class="el" href="classcds_1_1gc_1_1nogc.html" title="No garbage collecting. ">gc::nogc</a>)  <a href="classcds_1_1intrusive_1_1_michael_hash_set_3_01cds_1_1gc_1_1nogc_00_01_ordered_list_00_01_traits_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_michael_hash_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_ordered_list_00_01_traits_01_4.html">MichaelHashSet&lt; cds::urcu::gc&lt; RCU &gt;, OrderedList, Traits &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Michael's hash set, <a class="el" href="namespacecds_1_1urcu.html#cds_urcu_desc">RCU</a> specialization.  <a href="classcds_1_1intrusive_1_1_michael_hash_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_ordered_list_00_01_traits_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_michael_list.html">MichaelList</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Michael's lock-free ordered single-linked list.  <a href="classcds_1_1intrusive_1_1_michael_list.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_michael_list_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html">MichaelList&lt; cds::urcu::gc&lt; RCU &gt;, T, Traits &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Michael's lock-free ordered single-linked list (template specialization for <a class="el" href="namespacecds_1_1urcu.html#cds_urcu_desc">RCU</a>)  <a href="classcds_1_1intrusive_1_1_michael_list_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_michael_list_3_01gc_1_1nogc_00_01_t_00_01_traits_01_4.html">MichaelList&lt; gc::nogc, T, Traits &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Michael's lock-free ordered single-linked list (template specialization for <a class="el" href="classcds_1_1gc_1_1nogc.html" title="No garbage collecting. ">gc::nogc</a>)  <a href="classcds_1_1intrusive_1_1_michael_list_3_01gc_1_1nogc_00_01_t_00_01_traits_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_moir_queue.html">MoirQueue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A variation of Michael &amp; Scott's lock-free queue (intrusive variant)  <a href="classcds_1_1intrusive_1_1_moir_queue.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_m_s_priority_queue.html">MSPriorityQueue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Michael &amp; Scott array-based lock-based concurrent priority queue heap.  <a href="classcds_1_1intrusive_1_1_m_s_priority_queue.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_m_s_queue.html">MSQueue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Michael &amp; Scott's intrusive lock-free queue.  <a href="classcds_1_1intrusive_1_1_m_s_queue.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcds_1_1intrusive_1_1node__traits.html">node_traits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container's node traits.  <a href="structcds_1_1intrusive_1_1node__traits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_optimistic_queue.html">OptimisticQueue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Optimistic intruive lock-free queue.  <a href="classcds_1_1intrusive_1_1_optimistic_queue.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_segmented_queue.html">SegmentedQueue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Segmented queue.  <a href="classcds_1_1intrusive_1_1_segmented_queue.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set.html">SkipListSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lock-free skip-list set.  <a href="classcds_1_1intrusive_1_1_skip_list_set.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1gc_1_1nogc_00_01_t_00_01_traits_01_4.html">SkipListSet&lt; cds::gc::nogc, T, Traits &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lock-free skip-list set (template specialization for <a class="el" href="classcds_1_1gc_1_1nogc.html" title="No garbage collecting. ">gc::nogc</a>)  <a href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1gc_1_1nogc_00_01_t_00_01_traits_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html">SkipListSet&lt; cds::urcu::gc&lt; RCU &gt;, T, Traits &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lock-free skip-list set (template specialization for <a class="el" href="namespacecds_1_1urcu.html#cds_urcu_desc">RCU</a>)  <a href="classcds_1_1intrusive_1_1_skip_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html">SplitListSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split-ordered list.  <a href="classcds_1_1intrusive_1_1_split_list_set.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set_3_01cds_1_1gc_1_1nogc_00_01_ordered_list_00_01_traits_01_4.html">SplitListSet&lt; cds::gc::nogc, OrderedList, Traits &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split-ordered list (template specialization for <a class="el" href="classcds_1_1gc_1_1nogc.html" title="No garbage collecting. ">gc::nogc</a>)  <a href="classcds_1_1intrusive_1_1_split_list_set_3_01cds_1_1gc_1_1nogc_00_01_ordered_list_00_01_traits_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_ordered_list_00_01_traits_01_4.html">SplitListSet&lt; cds::urcu::gc&lt; RCU &gt;, OrderedList, Traits &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split-ordered list RCU specialization.  <a href="classcds_1_1intrusive_1_1_split_list_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_ordered_list_00_01_traits_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html">StripedSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Striped hash set.  <a href="classcds_1_1intrusive_1_1_striped_set.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_treiber_stack.html">TreiberStack</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Treiber intrusive stack.  <a href="classcds_1_1intrusive_1_1_treiber_stack.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_tsigas_cycle_queue.html">TsigasCycleQueue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-blocking cyclic queue discovered by Philippas Tsigas and Yi Zhang.  <a href="classcds_1_1intrusive_1_1_tsigas_cycle_queue.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_vyukov_m_p_m_c_cycle_queue.html">VyukovMPMCCycleQueue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vyukov's MPMC bounded queue.  <a href="classcds_1_1intrusive_1_1_vyukov_m_p_m_c_cycle_queue.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Intrusive containers. </p>
<p>The namespace <a class="el" href="namespacecds_1_1intrusive.html" title="Intrusive containers. ">cds::intrusive</a> contains intrusive lock-free containers. The idea comes from <code>boost::intrusive</code> library, see <a href="http://boost.org/doc/">http://boost.org/doc/</a> as a good introduction to intrusive approach. The intrusive containers of libcds library is developed as close to <code>boost::intrusive</code> </p>
<p>In terms of lock-free approach, the main advantage of intrusive containers is that no memory allocation is performed to maintain container items. However, additional requirements are imposed for types and values that can be stored in intrusive container. See the container documentation for details.</p>
<p><a class="anchor" id="cds_intrusive_hook_tag"></a></p><dl class="section user"><dt>Tags</dt><dd>Many hooks and nodes for intrusive containers contain template argument <code>Tag</code>. This argument serves as a tag, so you can derive from more than one container's node and hence put an object in multiple intrusive containers at the same time. An incomplete type can serve as a tag. If you specify two hooks, you must specify a different tag for each one. Example: <div class="fragment"><div class="line"><span class="keyword">struct </span>tag1;</div>
<div class="line"><a class="code" href="structcds_1_1intrusive_1_1single__link_1_1node.html">cds::intrusive::treiber_stack::node&lt; cds::gc::HP, tag&lt;tag1&gt;</a> &gt;</div>
</div><!-- fragment --> If no tag is specified the default <code><a class="el" href="structcds_1_1opt_1_1none.html" title="Type indicates that an option is not specified and the default one should be used. ">cds::opt::none</a></code> will be used.</dd></dl>
<p><a class="anchor" id="cds_intrusive_item_creating"></a></p><dl class="section user"><dt>Inserting items</dt><dd>Many intrusive and non-intrusive (standard-like) containers in the library have the member functions that take a functor argument to initialize the inserted item after it has been successfully inserted, for example: <div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Q, <span class="keyword">typename</span> Func&gt;</div>
<div class="line"><span class="keywordtype">bool</span> insert( Q&amp; key, Func f );</div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Q, <span class="keyword">typename</span> Func&gt;</div>
<div class="line">std::pair&lt;bool, bool&gt; update( Q&amp; key, Func f, <span class="keywordtype">bool</span> bAllowInsert = <span class="keyword">true</span> );</div>
</div><!-- fragment --> The first member function calls <code>f</code> functor iif a new item has been inserted. The functor takes two parameter: a reference to inserted item and <code>key</code>.</dd></dl>
<p>The second member function, <code>update()</code>, allows to insert a new item to the container if <code>key</code> is not found, or to find the item with <code>key</code> and to perform some action with it. The <code>f</code> signature is: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> f( <span class="keywordtype">bool</span> bNew, item_type&amp; item, Q&amp; key );</div>
</div><!-- fragment --><p> where <code>bNew</code> is a flag to indicate whether <code>item</code> is a new created node or not.</p>
<p>Such functions should be used with caution in multi-threaded environment since they can cause races. The library does not synchronize access to container's items, so many threads can access to one item simultaneously. For example, for <code>insert</code> member function the following race is possible: </p><div class="fragment"><div class="line"><span class="comment">// Suppose, Foo is a complex structure with int key field</span></div>
<div class="line">SomeContainer&lt;Foo&gt; q;</div>
<div class="line"></div>
<div class="line">Thread 1                                  Thread 2</div>
<div class="line"></div>
<div class="line">q.insert( Foo(5),                         q.find( 5, []( Foo&amp; item ) {</div>
<div class="line">    []( Foo&amp; item ){                         <span class="comment">// access to item fields</span></div>
<div class="line">       <span class="comment">// complex initialization             ...</span></div>
<div class="line">       item.f1 = ...;                     });</div>
<div class="line">       ...</div>
<div class="line">    });</div>
</div><!-- fragment --><p> Execute sequence: </p><div class="fragment"><div class="line">Find 5 in the container.</div>
<div class="line">Key 5 is not found</div>
<div class="line">Create a <span class="keyword">new</span> item                         Find key 5</div>
<div class="line">    with calling Foo(5) ctor</div>
<div class="line">Insert the new item</div>
<div class="line">                                          The key 5 is found -</div>
<div class="line">                                             call the functor     (!)</div>
<div class="line">Perform complex</div>
<div class="line">   initialization -</div>
<div class="line">   call the functor</div>
</div><!-- fragment --><p> (!): Thread 2 found the key and call its functor on incomplete initialized item. Simultaneous access to the item also is possible. In this case Thread 1 is initializing the item, thread 2 is reading (or writing) the item's fields. In any case, Thread 2 can read uninitialized or incomplete initialized fields.</p>
<p><code>update()</code> member function race. Suppose, thread 1 and thread 2 perform the following code: </p><div class="fragment"><div class="line">q.update( 5, []( <span class="keywordtype">bool</span> bNew, Foo&amp; item, <span class="keywordtype">int</span>  arg )</div>
<div class="line">   {</div>
<div class="line">      <span class="comment">// bNew: true if the new element has been created</span></div>
<div class="line">      <span class="comment">//       false otherwise</span></div>
<div class="line">      <span class="keywordflow">if</span> ( bNew ) {</div>
<div class="line">         <span class="comment">// initialize item</span></div>
<div class="line">         item.f1=...;</div>
<div class="line">         <span class="comment">//...</span></div>
<div class="line">      }</div>
<div class="line">      <span class="keywordflow">else</span> {</div>
<div class="line">         <span class="comment">// do some work</span></div>
<div class="line">         <span class="keywordflow">if</span> ( !item.f1 )</div>
<div class="line">            item.f1 = ...;</div>
<div class="line">         <span class="keywordflow">else</span> {</div>
<div class="line">           <span class="comment">//...</span></div>
<div class="line">         }</div>
<div class="line">         <span class="comment">//...</span></div>
<div class="line">      }</div>
<div class="line">   }</div>
<div class="line">);</div>
</div><!-- fragment --><p> Execute sequence: </p><div class="fragment"><div class="line">Thread 1                                  Thread 2</div>
<div class="line">key 5 not found</div>
<div class="line">insert <span class="keyword">new</span> item Foo(5)                    Find 5</div>
<div class="line">                                          Key 5 found</div>
<div class="line">                                          call the functor with</div>
<div class="line">                                             bNew = false        (!)</div>
<div class="line">call the functor with</div>
<div class="line">   bNew = true</div>
</div><!-- fragment --><p> (!): Thread 2 executes its functor on incomplete initialized item.</p>
<p>To protect your code from such races you can use some item-level synchronization, for example: </p><div class="fragment"><div class="line"><span class="keyword">struct </span>Foo {</div>
<div class="line">   spinlock lock;       <span class="comment">// item-level lock</span></div>
<div class="line">   <span class="keywordtype">bool</span> initialized = <span class="keyword">false</span>;    <span class="comment">// initialization flag</span></div>
<div class="line">   <span class="comment">// other fields</span></div>
<div class="line">   <span class="comment">// ....</span></div>
<div class="line">};</div>
<div class="line"></div>
<div class="line">q.update( 5, []( <span class="keywordtype">bool</span> bNew, Foo&amp; item, <span class="keywordtype">int</span>  arg )</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// Lock access to the item</span></div>
<div class="line">        std::unique_lock( item.lock );</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> ( !item.initialized ) {</div>
<div class="line">            <span class="comment">// initialize item</span></div>
<div class="line">            item.f1=...;</div>
<div class="line">            <span class="comment">//...</span></div>
<div class="line">            item.initialized = <span class="keyword">true</span>; <span class="comment">// mark the item as initialized</span></div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">else</span> {</div>
<div class="line">            <span class="comment">// do some work</span></div>
<div class="line">            <span class="keywordflow">if</span> ( !item.f1 )</div>
<div class="line">                item.f1 = ...;</div>
<div class="line">            <span class="keywordflow">else</span> {</div>
<div class="line">                <span class="comment">//...</span></div>
<div class="line">            }</div>
<div class="line">            <span class="comment">//...</span></div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">);</div>
</div><!-- fragment --><p> If the item-level synchronization is not suitable, you should not use any inserting member function with post-insert functor argument.</p>
<p><a class="anchor" id="cds_intrusive_item_destroying"></a></p><dl class="section user"><dt>Destroying items</dt><dd></dd></dl>
<p>It should be very careful when destroying an item removed from intrusive container. In other threads the references to popped item may exists some time after removing. To destroy the removed item in thread-safe manner you should call static function <code>retire</code> of garbage collector you use, for example: </p><div class="fragment"><div class="line"><span class="keyword">struct </span>destroyer  {</div>
<div class="line">    <span class="keywordtype">void</span> operator ()( my_type * p )</div>
<div class="line">    {</div>
<div class="line">        <span class="keyword">delete</span> p;</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="classcds_1_1intrusive_1_1_treiber_stack.html">cds::intrusive::TreiberStack&lt; cds::gc::HP, my_type, cds::opt::disposer&lt; destroyer &gt;</a> &gt; stack;</div>
<div class="line">stack s;</div>
<div class="line"></div>
<div class="line"><span class="comment">// ....</span></div>
<div class="line"></div>
<div class="line">my_type * p = s.<a class="code" href="classcds_1_1intrusive_1_1_treiber_stack.html#ae87f09d2df1ef1954a99b334575029ea">pop</a>();</div>
<div class="line"></div>
<div class="line"><span class="keywordflow">if</span> ( p ) {</div>
<div class="line">    <span class="comment">// It is wrong</span></div>
<div class="line">    <span class="comment">// delete p;</span></div>
<div class="line"></div>
<div class="line">    <span class="comment">// It is correct</span></div>
<div class="line">    <a class="code" href="namespacecds_1_1gc.html">cds::gc</a>:HP::retire&lt; destroyer &gt;( p );</div>
<div class="line">}</div>
</div><!-- fragment --><p> The situation becomes even more complicated when you want store items in different intrusive containers. In this case the best way is using reference counting: </p><div class="fragment"><div class="line"><span class="keyword">struct </span>my_type {</div>
<div class="line">    ...</div>
<div class="line">    std::atomic&lt;unsigned int&gt; nRefCount;</div>
<div class="line"></div>
<div class="line">    my_type()</div>
<div class="line">        : nRefCount(0)</div>
<div class="line">    {}</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keyword">struct </span>destroyer  {</div>
<div class="line">    <span class="keywordtype">void</span> operator ()( my_type * p )</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">if</span> ( --p-&gt;nRefCount == 0 )</div>
<div class="line">            <span class="keyword">delete</span> p    ;   <span class="comment">// delete only after no reference pointing to p</span></div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="classcds_1_1intrusive_1_1_treiber_stack.html">cds::intrusive::TreiberStack&lt; cds::gc::HP, my_type, cds::opt::disposer&lt; destroyer &gt;</a> &gt; stack;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="classcds_1_1intrusive_1_1_m_s_queue.html">cds::intrusive::MSQueue&lt; cds::gc::HP, my_type, cds::opt::disposer&lt; destroyer &gt;</a> &gt; queue;</div>
<div class="line">stack s;</div>
<div class="line">queue q;</div>
<div class="line"></div>
<div class="line">my_type * v = <span class="keyword">new</span> my_type();</div>
<div class="line"></div>
<div class="line">v.nRefCount++   ; <span class="comment">// increment counter before pushing the item to the stack</span></div>
<div class="line">s.push(v);</div>
<div class="line"></div>
<div class="line">v.nRefCount++   ; <span class="comment">// increment counter before pushing the item to the queue</span></div>
<div class="line">q.push(v);</div>
<div class="line"></div>
<div class="line"><span class="comment">// ....</span></div>
<div class="line"></div>
<div class="line">my_type * ps = s.pop();</div>
<div class="line"><span class="keywordflow">if</span> ( ps ) {</div>
<div class="line">    <span class="comment">// It is wrong</span></div>
<div class="line">    <span class="comment">// delete ps;</span></div>
<div class="line"></div>
<div class="line">    <span class="comment">// It is correct</span></div>
<div class="line">    <a class="code" href="namespacecds_1_1gc.html">cds::gc</a>:HP::retire&lt; destroyer &gt;( ps );</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">my_type * pq = q.pop();</div>
<div class="line"><span class="keywordflow">if</span> ( pq ) {</div>
<div class="line">    <span class="comment">// It is wrong</span></div>
<div class="line">    <span class="comment">// delete pq;</span></div>
<div class="line"></div>
<div class="line">    <span class="comment">// It is correct</span></div>
<div class="line">    <a class="code" href="namespacecds_1_1gc.html">cds::gc</a>:HP::retire&lt; destroyer &gt;( pq );</div>
<div class="line">}</div>
</div><!-- fragment --><p> Violation of these rules may lead to a crash.</p>
<dl class="section user"><dt>Intrusive containers and Hazard Pointer-like garbage collectors</dt><dd></dd></dl>
<p>If you develop your intrusive container based on <b>libcds</b> library framework, you should take in the account the following. The main idea of garbage collectors (GC) based on Hazard Pointer schema is protecting a shared pointer by publishing it as a "hazard" one i.e. as a pointer that is changing at the current time and cannot be deleted at this moment. In intrusive container paradigm, the pointer to the node of the container and the pointer to the item stored in the container are not equal in the general case. However, any pointer to the node should be castable to the appropriate pointer to the container's item. In general, any item can be placed to some different intrusive containers simultaneously, and each of those container holds a unique pointer to its node that refers to the same item. When we protect a pointer, we want to protect an <b>item</b> pointer that is the invariant for any container stored that item. In your intrusive container, instead of protecting by GC's guard a pointer to an node you should convert it to the pointer to the item and then protect resulting item pointer. Otherwise an unpredictable result may occur. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<hr/>
<div align="right">
  <b>cds</b> <b>2.1.0</b> 
  Developed by <i>Maxim Khizhinsky aka khizmax</i> 2007 - 2015
  <br/>
  <i>Autogenerated Wed Jan 6 2016 16:00:43 by Doxygen 1.8.10</i>
</div>
</body>
</html>
