<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>cds: cds::container::BronsonAVLTreeMap&lt; cds::urcu::gc&lt; RCU &gt;, Key, T, Traits &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">cds
   &#160;<span id="projectnumber">2.1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="classes.html"><span>Data&#160;Structure&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Data&#160;Fields</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a>  </div>
  <div class="headertitle">
<div class="title">cds::container::BronsonAVLTreeMap&lt; cds::urcu::gc&lt; RCU &gt;, Key, T, Traits &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__cds__nonintrusive__containers.html">Non-intrusive containers</a> &raquo; <a class="el" href="group__cds__nonintrusive__map.html">Map</a><a class="el" href="group__cds__nonintrusive__containers.html">Non-intrusive containers</a> &raquo;  &#124; <a class="el" href="group__cds__nonintrusive__tree.html">Tree</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Bronson et al AVL-tree (RCU specialization)  
 <a href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#details">More...</a></p>

<p><code>#include &lt;cds/container/bronson_avltree_map_rcu.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for cds::container::BronsonAVLTreeMap&lt; cds::urcu::gc&lt; RCU &gt;, Key, T, Traits &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.png" usemap="#cds::container::BronsonAVLTreeMap&lt; cds::urcu::gc&lt; RCU &gt;, Key, T, Traits &gt;_map" alt=""/>
  <map id="cds::container::BronsonAVLTreeMap&lt; cds::urcu::gc&lt; RCU &gt;, Key, T, Traits &gt;_map" name="cds::container::BronsonAVLTreeMap&lt; cds::urcu::gc&lt; RCU &gt;, Key, T, Traits &gt;_map">
<area href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4.html" title="Bronson et al AVL-tree (RCU specialization for storing pointer to values) " alt="cds::container::BronsonAVLTreeMap&lt; cds::urcu::gc&lt; RCU &gt;, Key, T *, Traits &gt;" shape="rect" coords="0,0,464,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ade504429a284ce3112e7c03c7b6f4881"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ade504429a284ce3112e7c03c7b6f4881"></a>
typedef cds::urcu::gc&lt; RCU &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#ade504429a284ce3112e7c03c7b6f4881">gc</a></td></tr>
<tr class="memdesc:ade504429a284ce3112e7c03c7b6f4881"><td class="mdescLeft">&#160;</td><td class="mdescRight">RCU Garbage collector. <br /></td></tr>
<tr class="separator:ade504429a284ce3112e7c03c7b6f4881"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19f5fcd50d2125780854c19e316ee49e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a19f5fcd50d2125780854c19e316ee49e"></a>
typedef Key&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a19f5fcd50d2125780854c19e316ee49e">key_type</a></td></tr>
<tr class="memdesc:a19f5fcd50d2125780854c19e316ee49e"><td class="mdescLeft">&#160;</td><td class="mdescRight">type of a key stored in the map <br /></td></tr>
<tr class="separator:a19f5fcd50d2125780854c19e316ee49e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3f5c2ab6ebcf04e7dcf5125ec8058e6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad3f5c2ab6ebcf04e7dcf5125ec8058e6"></a>
typedef T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#ad3f5c2ab6ebcf04e7dcf5125ec8058e6">mapped_type</a></td></tr>
<tr class="memdesc:ad3f5c2ab6ebcf04e7dcf5125ec8058e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">type of value stored in the map <br /></td></tr>
<tr class="separator:ad3f5c2ab6ebcf04e7dcf5125ec8058e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a225cf23bc05ea8e4eb3b364aafb49ee3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a225cf23bc05ea8e4eb3b364aafb49ee3"></a>
typedef Traits&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a225cf23bc05ea8e4eb3b364aafb49ee3">traits</a></td></tr>
<tr class="memdesc:a225cf23bc05ea8e4eb3b364aafb49ee3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traits template parameter. <br /></td></tr>
<tr class="separator:a225cf23bc05ea8e4eb3b364aafb49ee3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c6c719a6282a15c87e49267c128487c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2c6c719a6282a15c87e49267c128487c"></a>
typedef base_class::key_comparator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a2c6c719a6282a15c87e49267c128487c">key_comparator</a></td></tr>
<tr class="memdesc:a2c6c719a6282a15c87e49267c128487c"><td class="mdescLeft">&#160;</td><td class="mdescRight">key compare functor based on <code>Traits::compare</code> and <code>Traits::less</code> <br /></td></tr>
<tr class="separator:a2c6c719a6282a15c87e49267c128487c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8eb0b5aefe4d76d85cf883dc28c0b2d3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8eb0b5aefe4d76d85cf883dc28c0b2d3"></a>
typedef traits::item_counter&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a8eb0b5aefe4d76d85cf883dc28c0b2d3">item_counter</a></td></tr>
<tr class="memdesc:a8eb0b5aefe4d76d85cf883dc28c0b2d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Item counting policy. <br /></td></tr>
<tr class="separator:a8eb0b5aefe4d76d85cf883dc28c0b2d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50fc0ed223e510c12f83a1b6348cfd54"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a50fc0ed223e510c12f83a1b6348cfd54"></a>
typedef traits::memory_model&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a50fc0ed223e510c12f83a1b6348cfd54">memory_model</a></td></tr>
<tr class="memdesc:a50fc0ed223e510c12f83a1b6348cfd54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Memory ordering, see <code><a class="el" href="structcds_1_1opt_1_1memory__model.html" title="[type-option] Option setter for C++ memory model ">cds::opt::memory_model</a></code> option. <br /></td></tr>
<tr class="separator:a50fc0ed223e510c12f83a1b6348cfd54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa05ac2a463e5ec231e18edd1a0ed716e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa05ac2a463e5ec231e18edd1a0ed716e"></a>
typedef traits::allocator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#aa05ac2a463e5ec231e18edd1a0ed716e">allocator_type</a></td></tr>
<tr class="memdesc:aa05ac2a463e5ec231e18edd1a0ed716e"><td class="mdescLeft">&#160;</td><td class="mdescRight">allocator for value <br /></td></tr>
<tr class="separator:aa05ac2a463e5ec231e18edd1a0ed716e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34866baae30166fef667a8e26106e856"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a34866baae30166fef667a8e26106e856"></a>
typedef traits::node_allocator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a34866baae30166fef667a8e26106e856">node_allocator_type</a></td></tr>
<tr class="memdesc:a34866baae30166fef667a8e26106e856"><td class="mdescLeft">&#160;</td><td class="mdescRight">allocator for maintaining internal nodes <br /></td></tr>
<tr class="separator:a34866baae30166fef667a8e26106e856"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8c040c578a5e61c396b937edd8d543b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab8c040c578a5e61c396b937edd8d543b"></a>
typedef traits::stat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#ab8c040c578a5e61c396b937edd8d543b">stat</a></td></tr>
<tr class="memdesc:ab8c040c578a5e61c396b937edd8d543b"><td class="mdescLeft">&#160;</td><td class="mdescRight">internal statistics <br /></td></tr>
<tr class="separator:ab8c040c578a5e61c396b937edd8d543b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83a40569b4c8b34dc1ad45a195ec6321"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a83a40569b4c8b34dc1ad45a195ec6321"></a>
typedef traits::rcu_check_deadlock&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a83a40569b4c8b34dc1ad45a195ec6321">rcu_check_deadlock</a></td></tr>
<tr class="memdesc:a83a40569b4c8b34dc1ad45a195ec6321"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deadlock checking policy. <br /></td></tr>
<tr class="separator:a83a40569b4c8b34dc1ad45a195ec6321"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a367a369caf503595c57f1aca47601547"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a367a369caf503595c57f1aca47601547"></a>
typedef traits::back_off&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a367a369caf503595c57f1aca47601547">back_off</a></td></tr>
<tr class="memdesc:a367a369caf503595c57f1aca47601547"><td class="mdescLeft">&#160;</td><td class="mdescRight">Back-off strategy. <br /></td></tr>
<tr class="separator:a367a369caf503595c57f1aca47601547"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a221981858d89b1f90315f80e3c649ca6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a221981858d89b1f90315f80e3c649ca6"></a>
typedef traits::sync_monitor&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a221981858d89b1f90315f80e3c649ca6">sync_monitor</a></td></tr>
<tr class="memdesc:a221981858d89b1f90315f80e3c649ca6"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="cds_sync_monitor.html">Synchronization monitor</a> type for node-level locking <br /></td></tr>
<tr class="separator:a221981858d89b1f90315f80e3c649ca6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a404365b550d0a7e23bf66bbace645b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0a404365b550d0a7e23bf66bbace645b"></a>
typedef base_class::rcu_lock&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a0a404365b550d0a7e23bf66bbace645b">rcu_lock</a></td></tr>
<tr class="memdesc:a0a404365b550d0a7e23bf66bbace645b"><td class="mdescLeft">&#160;</td><td class="mdescRight">RCU scoped lock. <br /></td></tr>
<tr class="separator:a0a404365b550d0a7e23bf66bbace645b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49e823c7277e6a8ffc84fd280863b401"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a49e823c7277e6a8ffc84fd280863b401"></a>
typedef base_class::exempt_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a49e823c7277e6a8ffc84fd280863b401">exempt_ptr</a></td></tr>
<tr class="memdesc:a49e823c7277e6a8ffc84fd280863b401"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returned pointer to <code>mapped_type</code> of extracted node. <br /></td></tr>
<tr class="separator:a49e823c7277e6a8ffc84fd280863b401"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a8fcc2cff472e86eecb69e8715d552309"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8fcc2cff472e86eecb69e8715d552309"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a8fcc2cff472e86eecb69e8715d552309">BronsonAVLTreeMap</a> ()</td></tr>
<tr class="memdesc:a8fcc2cff472e86eecb69e8715d552309"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates empty map. <br /></td></tr>
<tr class="separator:a8fcc2cff472e86eecb69e8715d552309"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab28c815ac34d72dd2403423fddab4f93"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab28c815ac34d72dd2403423fddab4f93"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#ab28c815ac34d72dd2403423fddab4f93">~BronsonAVLTreeMap</a> ()</td></tr>
<tr class="memdesc:ab28c815ac34d72dd2403423fddab4f93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys the map. <br /></td></tr>
<tr class="separator:ab28c815ac34d72dd2403423fddab4f93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a737a79db0162c98dd5d462966892464d"><td class="memTemplParams" colspan="2">template&lt;typename K &gt; </td></tr>
<tr class="memitem:a737a79db0162c98dd5d462966892464d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a737a79db0162c98dd5d462966892464d">insert</a> (K const &amp;key)</td></tr>
<tr class="memdesc:a737a79db0162c98dd5d462966892464d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new node with <code>key</code> and default value.  <a href="#a737a79db0162c98dd5d462966892464d">More...</a><br /></td></tr>
<tr class="separator:a737a79db0162c98dd5d462966892464d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6720c8decba4c64dcbe6a6ef64ab016a"><td class="memTemplParams" colspan="2">template&lt;typename K , typename V &gt; </td></tr>
<tr class="memitem:a6720c8decba4c64dcbe6a6ef64ab016a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a6720c8decba4c64dcbe6a6ef64ab016a">insert</a> (K const &amp;key, V const &amp;val)</td></tr>
<tr class="memdesc:a6720c8decba4c64dcbe6a6ef64ab016a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new node.  <a href="#a6720c8decba4c64dcbe6a6ef64ab016a">More...</a><br /></td></tr>
<tr class="separator:a6720c8decba4c64dcbe6a6ef64ab016a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74b24524e3d5b2171f1f6a883d5d9dc8"><td class="memTemplParams" colspan="2">template&lt;typename K , typename Func &gt; </td></tr>
<tr class="memitem:a74b24524e3d5b2171f1f6a883d5d9dc8"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a74b24524e3d5b2171f1f6a883d5d9dc8">insert_with</a> (K const &amp;key, Func func)</td></tr>
<tr class="memdesc:a74b24524e3d5b2171f1f6a883d5d9dc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new node and initialize it by a functor.  <a href="#a74b24524e3d5b2171f1f6a883d5d9dc8">More...</a><br /></td></tr>
<tr class="separator:a74b24524e3d5b2171f1f6a883d5d9dc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e01d5bd72320153774deb96da431660"><td class="memTemplParams" colspan="2">template&lt;typename K , typename... Args&gt; </td></tr>
<tr class="memitem:a3e01d5bd72320153774deb96da431660"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a3e01d5bd72320153774deb96da431660">emplace</a> (K &amp;&amp;key, Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:a3e01d5bd72320153774deb96da431660"><td class="mdescLeft">&#160;</td><td class="mdescRight">For key <code>key</code> inserts data of type <code>mapped_type</code> created in-place from <code>args</code>.  <a href="#a3e01d5bd72320153774deb96da431660">More...</a><br /></td></tr>
<tr class="separator:a3e01d5bd72320153774deb96da431660"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b6c39f2ac7ac37051aae2e00eb0e5ea"><td class="memTemplParams" colspan="2">template&lt;typename K , typename Func &gt; </td></tr>
<tr class="memitem:a1b6c39f2ac7ac37051aae2e00eb0e5ea"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; bool, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a1b6c39f2ac7ac37051aae2e00eb0e5ea">update</a> (K const &amp;key, Func func, bool bAllowInsert=true)</td></tr>
<tr class="memdesc:a1b6c39f2ac7ac37051aae2e00eb0e5ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the value for <code>key</code>.  <a href="#a1b6c39f2ac7ac37051aae2e00eb0e5ea">More...</a><br /></td></tr>
<tr class="separator:a1b6c39f2ac7ac37051aae2e00eb0e5ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a4b1fd14e91c647f2356e911a4f2a1a"><td class="memTemplParams" colspan="2">template&lt;typename K &gt; </td></tr>
<tr class="memitem:a1a4b1fd14e91c647f2356e911a4f2a1a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a1a4b1fd14e91c647f2356e911a4f2a1a">erase</a> (K const &amp;key)</td></tr>
<tr class="memdesc:a1a4b1fd14e91c647f2356e911a4f2a1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete <code>key</code> from the map.  <a href="#a1a4b1fd14e91c647f2356e911a4f2a1a">More...</a><br /></td></tr>
<tr class="separator:a1a4b1fd14e91c647f2356e911a4f2a1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70205077f86a8ec4a6dda4f52b8d96af"><td class="memTemplParams" colspan="2">template&lt;typename K , typename Less &gt; </td></tr>
<tr class="memitem:a70205077f86a8ec4a6dda4f52b8d96af"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a70205077f86a8ec4a6dda4f52b8d96af">erase_with</a> (K const &amp;key, Less pred)</td></tr>
<tr class="memdesc:a70205077f86a8ec4a6dda4f52b8d96af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the item from the map using <code>pred</code> predicate for searching.  <a href="#a70205077f86a8ec4a6dda4f52b8d96af">More...</a><br /></td></tr>
<tr class="separator:a70205077f86a8ec4a6dda4f52b8d96af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f0cb31cfbeca3aa58fb48dc1401c0c9"><td class="memTemplParams" colspan="2">template&lt;typename K , typename Func &gt; </td></tr>
<tr class="memitem:a9f0cb31cfbeca3aa58fb48dc1401c0c9"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a9f0cb31cfbeca3aa58fb48dc1401c0c9">erase</a> (K const &amp;key, Func f)</td></tr>
<tr class="memdesc:a9f0cb31cfbeca3aa58fb48dc1401c0c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete <code>key</code> from the map.  <a href="#a9f0cb31cfbeca3aa58fb48dc1401c0c9">More...</a><br /></td></tr>
<tr class="separator:a9f0cb31cfbeca3aa58fb48dc1401c0c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af138ff4bf3da3b33a8cf074ca8a2d131"><td class="memTemplParams" colspan="2">template&lt;typename K , typename Less , typename Func &gt; </td></tr>
<tr class="memitem:af138ff4bf3da3b33a8cf074ca8a2d131"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#af138ff4bf3da3b33a8cf074ca8a2d131">erase_with</a> (K const &amp;key, Less pred, Func f)</td></tr>
<tr class="memdesc:af138ff4bf3da3b33a8cf074ca8a2d131"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the item from the map using <code>pred</code> predicate for searching.  <a href="#af138ff4bf3da3b33a8cf074ca8a2d131">More...</a><br /></td></tr>
<tr class="separator:af138ff4bf3da3b33a8cf074ca8a2d131"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67612de75c25b7151be2d72a1d4e6cd5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a49e823c7277e6a8ffc84fd280863b401">exempt_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a67612de75c25b7151be2d72a1d4e6cd5">extract_min</a> ()</td></tr>
<tr class="memdesc:a67612de75c25b7151be2d72a1d4e6cd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts a value with minimal key from the map.  <a href="#a67612de75c25b7151be2d72a1d4e6cd5">More...</a><br /></td></tr>
<tr class="separator:a67612de75c25b7151be2d72a1d4e6cd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd9da9fa1c8634920d2b81b61799e846"><td class="memTemplParams" colspan="2">template&lt;typename Func &gt; </td></tr>
<tr class="memitem:abd9da9fa1c8634920d2b81b61799e846"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a49e823c7277e6a8ffc84fd280863b401">exempt_ptr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#abd9da9fa1c8634920d2b81b61799e846">extract_min</a> (Func f)</td></tr>
<tr class="memdesc:abd9da9fa1c8634920d2b81b61799e846"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts minimal key key and corresponding value.  <a href="#abd9da9fa1c8634920d2b81b61799e846">More...</a><br /></td></tr>
<tr class="separator:abd9da9fa1c8634920d2b81b61799e846"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f7c615b5d2dae6d05a0365cbecdc5a6"><td class="memItemLeft" align="right" valign="top">std::enable_if&lt; std::is_copy_assignable&lt; <a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a19f5fcd50d2125780854c19e316ee49e">key_type</a> &gt;::value, <a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a49e823c7277e6a8ffc84fd280863b401">exempt_ptr</a> &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a9f7c615b5d2dae6d05a0365cbecdc5a6">extract_min_key</a> (<a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a19f5fcd50d2125780854c19e316ee49e">key_type</a> &amp;min_key)</td></tr>
<tr class="memdesc:a9f7c615b5d2dae6d05a0365cbecdc5a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts minimal key key and corresponding value.  <a href="#a9f7c615b5d2dae6d05a0365cbecdc5a6">More...</a><br /></td></tr>
<tr class="separator:a9f7c615b5d2dae6d05a0365cbecdc5a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52be1f9b07b54faef3a5e7c5dda88952"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a49e823c7277e6a8ffc84fd280863b401">exempt_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a52be1f9b07b54faef3a5e7c5dda88952">extract_max</a> ()</td></tr>
<tr class="memdesc:a52be1f9b07b54faef3a5e7c5dda88952"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts an item with maximal key from the map.  <a href="#a52be1f9b07b54faef3a5e7c5dda88952">More...</a><br /></td></tr>
<tr class="separator:a52be1f9b07b54faef3a5e7c5dda88952"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82e61d4458f926a627ccdfc691f2b82f"><td class="memTemplParams" colspan="2">template&lt;typename Func &gt; </td></tr>
<tr class="memitem:a82e61d4458f926a627ccdfc691f2b82f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a49e823c7277e6a8ffc84fd280863b401">exempt_ptr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a82e61d4458f926a627ccdfc691f2b82f">extract_max</a> (Func f)</td></tr>
<tr class="memdesc:a82e61d4458f926a627ccdfc691f2b82f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the maximal key and corresponding value.  <a href="#a82e61d4458f926a627ccdfc691f2b82f">More...</a><br /></td></tr>
<tr class="separator:a82e61d4458f926a627ccdfc691f2b82f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4557da16d7b87085f500dd403f7b8e4"><td class="memItemLeft" align="right" valign="top">std::enable_if&lt; std::is_copy_assignable&lt; <a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a19f5fcd50d2125780854c19e316ee49e">key_type</a> &gt;::value, <a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a49e823c7277e6a8ffc84fd280863b401">exempt_ptr</a> &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#ae4557da16d7b87085f500dd403f7b8e4">extract_max_key</a> (<a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a19f5fcd50d2125780854c19e316ee49e">key_type</a> &amp;max_key)</td></tr>
<tr class="memdesc:ae4557da16d7b87085f500dd403f7b8e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the maximal key and corresponding value.  <a href="#ae4557da16d7b87085f500dd403f7b8e4">More...</a><br /></td></tr>
<tr class="separator:ae4557da16d7b87085f500dd403f7b8e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a279a8bc01074fd53a8ac333676f0089c"><td class="memTemplParams" colspan="2">template&lt;typename Q &gt; </td></tr>
<tr class="memitem:a279a8bc01074fd53a8ac333676f0089c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a49e823c7277e6a8ffc84fd280863b401">exempt_ptr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a279a8bc01074fd53a8ac333676f0089c">extract</a> (Q const &amp;key)</td></tr>
<tr class="memdesc:a279a8bc01074fd53a8ac333676f0089c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts an item from the map.  <a href="#a279a8bc01074fd53a8ac333676f0089c">More...</a><br /></td></tr>
<tr class="separator:a279a8bc01074fd53a8ac333676f0089c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4a39c4e20350146eede4a39c21b1442"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Less &gt; </td></tr>
<tr class="memitem:ac4a39c4e20350146eede4a39c21b1442"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a49e823c7277e6a8ffc84fd280863b401">exempt_ptr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#ac4a39c4e20350146eede4a39c21b1442">extract_with</a> (Q const &amp;key, Less pred)</td></tr>
<tr class="memdesc:ac4a39c4e20350146eede4a39c21b1442"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts an item from the map using <code>pred</code> for searching.  <a href="#ac4a39c4e20350146eede4a39c21b1442">More...</a><br /></td></tr>
<tr class="separator:ac4a39c4e20350146eede4a39c21b1442"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9727d6aecbc2fc75e7fd0631a3b9f052"><td class="memTemplParams" colspan="2">template&lt;typename K , typename Func &gt; </td></tr>
<tr class="memitem:a9727d6aecbc2fc75e7fd0631a3b9f052"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a9727d6aecbc2fc75e7fd0631a3b9f052">find</a> (K const &amp;key, Func f)</td></tr>
<tr class="memdesc:a9727d6aecbc2fc75e7fd0631a3b9f052"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the key <code>key</code>.  <a href="#a9727d6aecbc2fc75e7fd0631a3b9f052">More...</a><br /></td></tr>
<tr class="separator:a9727d6aecbc2fc75e7fd0631a3b9f052"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95239282385efb4e8446e6d1daa47bb4"><td class="memTemplParams" colspan="2">template&lt;typename K , typename Less , typename Func &gt; </td></tr>
<tr class="memitem:a95239282385efb4e8446e6d1daa47bb4"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a95239282385efb4e8446e6d1daa47bb4">find_with</a> (K const &amp;key, Less pred, Func f)</td></tr>
<tr class="memdesc:a95239282385efb4e8446e6d1daa47bb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the key <code>val</code> using <code>pred</code> predicate for searching.  <a href="#a95239282385efb4e8446e6d1daa47bb4">More...</a><br /></td></tr>
<tr class="separator:a95239282385efb4e8446e6d1daa47bb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f5e5bdd93442d44bf7a188f85530856"><td class="memTemplParams" colspan="2">template&lt;typename K &gt; </td></tr>
<tr class="memitem:a1f5e5bdd93442d44bf7a188f85530856"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a1f5e5bdd93442d44bf7a188f85530856">contains</a> (K const &amp;key)</td></tr>
<tr class="memdesc:a1f5e5bdd93442d44bf7a188f85530856"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the map contains <code>key</code>.  <a href="#a1f5e5bdd93442d44bf7a188f85530856">More...</a><br /></td></tr>
<tr class="separator:a1f5e5bdd93442d44bf7a188f85530856"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62d1483913a15e119c3e144b8511d582"><td class="memTemplParams" colspan="2">template&lt;typename K , typename Less &gt; </td></tr>
<tr class="memitem:a62d1483913a15e119c3e144b8511d582"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a62d1483913a15e119c3e144b8511d582">contains</a> (K const &amp;key, Less pred)</td></tr>
<tr class="memdesc:a62d1483913a15e119c3e144b8511d582"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the map contains <code>key</code> using <code>pred</code> predicate for searching.  <a href="#a62d1483913a15e119c3e144b8511d582">More...</a><br /></td></tr>
<tr class="separator:a62d1483913a15e119c3e144b8511d582"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1150b1c1d880a145d73e1ec9486c7211"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1150b1c1d880a145d73e1ec9486c7211"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a1150b1c1d880a145d73e1ec9486c7211">clear</a> ()</td></tr>
<tr class="memdesc:a1150b1c1d880a145d73e1ec9486c7211"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the map. <br /></td></tr>
<tr class="separator:a1150b1c1d880a145d73e1ec9486c7211"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b72a9f5f7ab07c7f2707b18d880f547"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6b72a9f5f7ab07c7f2707b18d880f547"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a6b72a9f5f7ab07c7f2707b18d880f547">empty</a> () const </td></tr>
<tr class="memdesc:a6b72a9f5f7ab07c7f2707b18d880f547"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the map is empty. <br /></td></tr>
<tr class="separator:a6b72a9f5f7ab07c7f2707b18d880f547"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae32da787c023d704683927f45baba2fb"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#ae32da787c023d704683927f45baba2fb">size</a> () const </td></tr>
<tr class="memdesc:ae32da787c023d704683927f45baba2fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns item count in the map.  <a href="#ae32da787c023d704683927f45baba2fb">More...</a><br /></td></tr>
<tr class="separator:ae32da787c023d704683927f45baba2fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d0c801414dc9e10ff65b7f93097a419"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9d0c801414dc9e10ff65b7f93097a419"></a>
<a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#ab8c040c578a5e61c396b937edd8d543b">stat</a> const &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a9d0c801414dc9e10ff65b7f93097a419">statistics</a> () const </td></tr>
<tr class="memdesc:a9d0c801414dc9e10ff65b7f93097a419"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns const reference to internal statistics. <br /></td></tr>
<tr class="separator:a9d0c801414dc9e10ff65b7f93097a419"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa02b30f7fe376dcecbca7b454e89d6d0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa02b30f7fe376dcecbca7b454e89d6d0"></a>
<a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a221981858d89b1f90315f80e3c649ca6">sync_monitor</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#aa02b30f7fe376dcecbca7b454e89d6d0">monitor</a> ()</td></tr>
<tr class="memdesc:aa02b30f7fe376dcecbca7b454e89d6d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns reference to <code>sync_monitor</code> object. <br /></td></tr>
<tr class="separator:aa02b30f7fe376dcecbca7b454e89d6d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58640b952b9b70161e99397e349700ca"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a58640b952b9b70161e99397e349700ca">check_consistency</a> () const </td></tr>
<tr class="memdesc:a58640b952b9b70161e99397e349700ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks internal consistency (not atomic, not thread-safe)  <a href="#a58640b952b9b70161e99397e349700ca">More...</a><br /></td></tr>
<tr class="separator:a58640b952b9b70161e99397e349700ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a925835747f15603be749debb6e73b60b"><td class="memTemplParams" colspan="2">template&lt;typename Func &gt; </td></tr>
<tr class="memitem:a925835747f15603be749debb6e73b60b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a925835747f15603be749debb6e73b60b">check_consistency</a> (Func f) const </td></tr>
<tr class="memdesc:a925835747f15603be749debb6e73b60b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks internal consistency (not atomic, not thread-safe)  <a href="#a925835747f15603be749debb6e73b60b">More...</a><br /></td></tr>
<tr class="separator:a925835747f15603be749debb6e73b60b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:aa84ec127edf8164ebebd1285a896b40d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa84ec127edf8164ebebd1285a896b40d"></a>
static bool const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#aa84ec127edf8164ebebd1285a896b40d">c_bRelaxedInsert</a> = traits::relaxed_insert</td></tr>
<tr class="memdesc:aa84ec127edf8164ebebd1285a896b40d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enabled or disabled <a class="el" href="structcds_1_1container_1_1bronson__avltree_1_1relaxed__insert.html">relaxed insertion</a>. <br /></td></tr>
<tr class="separator:aa84ec127edf8164ebebd1285a896b40d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a680844a1fdf868074d2c95b852704642"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a680844a1fdf868074d2c95b852704642"></a>
static constexpr const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a680844a1fdf868074d2c95b852704642">c_bExtractLockExternal</a> = base_class::c_bExtractLockExternal</td></tr>
<tr class="memdesc:a680844a1fdf868074d2c95b852704642"><td class="mdescLeft">&#160;</td><td class="mdescRight">Group of <code>extract_xxx</code> functions does not require external locking. <br /></td></tr>
<tr class="separator:a680844a1fdf868074d2c95b852704642"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_types_classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4')"><img src="closed.png" alt="-"/>&#160;Private Types inherited from <a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4.html">cds::container::BronsonAVLTreeMap&lt; cds::urcu::gc&lt; RCU &gt;, Key, T *, Traits &gt;</a></td></tr>
<tr class="memitem:aaed9b1acee4c48f573a800a921289375 inherit pub_types_classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaed9b1acee4c48f573a800a921289375"></a>
typedef cds::urcu::gc&lt; RCU &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4.html#aaed9b1acee4c48f573a800a921289375">gc</a></td></tr>
<tr class="memdesc:aaed9b1acee4c48f573a800a921289375 inherit pub_types_classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">RCU Garbage collector. <br /></td></tr>
<tr class="separator:aaed9b1acee4c48f573a800a921289375 inherit pub_types_classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1241636918651c696267269ff61e682 inherit pub_types_classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af1241636918651c696267269ff61e682"></a>
typedef Key&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4.html#af1241636918651c696267269ff61e682">key_type</a></td></tr>
<tr class="memdesc:af1241636918651c696267269ff61e682 inherit pub_types_classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">type of a key stored in the map <br /></td></tr>
<tr class="separator:af1241636918651c696267269ff61e682 inherit pub_types_classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa955a3d4f22ee5ef4026606f9b7eb487 inherit pub_types_classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa955a3d4f22ee5ef4026606f9b7eb487"></a>
typedef T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4.html#aa955a3d4f22ee5ef4026606f9b7eb487">mapped_type</a></td></tr>
<tr class="memdesc:aa955a3d4f22ee5ef4026606f9b7eb487 inherit pub_types_classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">type of value stored in the map <br /></td></tr>
<tr class="separator:aa955a3d4f22ee5ef4026606f9b7eb487 inherit pub_types_classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14b954a25ba303fe21eddec2652e7fbc inherit pub_types_classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a14b954a25ba303fe21eddec2652e7fbc"></a>
typedef Traits&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4.html#a14b954a25ba303fe21eddec2652e7fbc">traits</a></td></tr>
<tr class="memdesc:a14b954a25ba303fe21eddec2652e7fbc inherit pub_types_classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traits template parameter. <br /></td></tr>
<tr class="separator:a14b954a25ba303fe21eddec2652e7fbc inherit pub_types_classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10047d6018844bfb6d4d4577fd7d7c39 inherit pub_types_classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a10047d6018844bfb6d4d4577fd7d7c39"></a>
typedef implementation_defined&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4.html#a10047d6018844bfb6d4d4577fd7d7c39">key_comparator</a></td></tr>
<tr class="memdesc:a10047d6018844bfb6d4d4577fd7d7c39 inherit pub_types_classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">key compare functor based on <code>Traits::compare</code> and <code>Traits::less</code> <br /></td></tr>
<tr class="separator:a10047d6018844bfb6d4d4577fd7d7c39 inherit pub_types_classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bbae578888bd3706652cdaf6b42d72c inherit pub_types_classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8bbae578888bd3706652cdaf6b42d72c"></a>
typedef traits::item_counter&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4.html#a8bbae578888bd3706652cdaf6b42d72c">item_counter</a></td></tr>
<tr class="memdesc:a8bbae578888bd3706652cdaf6b42d72c inherit pub_types_classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Item counting policy. <br /></td></tr>
<tr class="separator:a8bbae578888bd3706652cdaf6b42d72c inherit pub_types_classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb4ea0faa83564f45c85dcd1f1ed02f4 inherit pub_types_classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acb4ea0faa83564f45c85dcd1f1ed02f4"></a>
typedef traits::memory_model&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4.html#acb4ea0faa83564f45c85dcd1f1ed02f4">memory_model</a></td></tr>
<tr class="memdesc:acb4ea0faa83564f45c85dcd1f1ed02f4 inherit pub_types_classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Memory ordering, see <code><a class="el" href="structcds_1_1opt_1_1memory__model.html" title="[type-option] Option setter for C++ memory model ">cds::opt::memory_model</a></code> option. <br /></td></tr>
<tr class="separator:acb4ea0faa83564f45c85dcd1f1ed02f4 inherit pub_types_classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7520161e80670a6720e79530ee6c985f inherit pub_types_classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7520161e80670a6720e79530ee6c985f"></a>
typedef traits::node_allocator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4.html#a7520161e80670a6720e79530ee6c985f">node_allocator_type</a></td></tr>
<tr class="memdesc:a7520161e80670a6720e79530ee6c985f inherit pub_types_classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">allocator for maintaining internal nodes <br /></td></tr>
<tr class="separator:a7520161e80670a6720e79530ee6c985f inherit pub_types_classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab498349cd9695a96cdbc21e11a2f9941 inherit pub_types_classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab498349cd9695a96cdbc21e11a2f9941"></a>
typedef traits::stat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4.html#ab498349cd9695a96cdbc21e11a2f9941">stat</a></td></tr>
<tr class="memdesc:ab498349cd9695a96cdbc21e11a2f9941 inherit pub_types_classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">internal statistics <br /></td></tr>
<tr class="separator:ab498349cd9695a96cdbc21e11a2f9941 inherit pub_types_classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab18c3df8b3b2dc4a21db03d2153c6248 inherit pub_types_classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab18c3df8b3b2dc4a21db03d2153c6248"></a>
typedef traits::rcu_check_deadlock&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4.html#ab18c3df8b3b2dc4a21db03d2153c6248">rcu_check_deadlock</a></td></tr>
<tr class="memdesc:ab18c3df8b3b2dc4a21db03d2153c6248 inherit pub_types_classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deadlock checking policy. <br /></td></tr>
<tr class="separator:ab18c3df8b3b2dc4a21db03d2153c6248 inherit pub_types_classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad91532ad46333ea0f3e5aadc67c9f03 inherit pub_types_classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aad91532ad46333ea0f3e5aadc67c9f03"></a>
typedef traits::back_off&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4.html#aad91532ad46333ea0f3e5aadc67c9f03">back_off</a></td></tr>
<tr class="memdesc:aad91532ad46333ea0f3e5aadc67c9f03 inherit pub_types_classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Back-off strategy. <br /></td></tr>
<tr class="separator:aad91532ad46333ea0f3e5aadc67c9f03 inherit pub_types_classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa1d0f97e8cb375833a76cc1e7d1e8d3 inherit pub_types_classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaa1d0f97e8cb375833a76cc1e7d1e8d3"></a>
typedef traits::disposer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4.html#aaa1d0f97e8cb375833a76cc1e7d1e8d3">disposer</a></td></tr>
<tr class="memdesc:aaa1d0f97e8cb375833a76cc1e7d1e8d3 inherit pub_types_classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Value disposer. <br /></td></tr>
<tr class="separator:aaa1d0f97e8cb375833a76cc1e7d1e8d3 inherit pub_types_classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b081575c5536963822350e265a44ad6 inherit pub_types_classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6b081575c5536963822350e265a44ad6"></a>
typedef traits::sync_monitor&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4.html#a6b081575c5536963822350e265a44ad6">sync_monitor</a></td></tr>
<tr class="memdesc:a6b081575c5536963822350e265a44ad6 inherit pub_types_classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="cds_sync_monitor.html">Synchronization monitor</a> type for node-level locking <br /></td></tr>
<tr class="separator:a6b081575c5536963822350e265a44ad6 inherit pub_types_classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad151e631864e27a386826e4f942861ae inherit pub_types_classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad151e631864e27a386826e4f942861ae"></a>
typedef <a class="el" href="classcds_1_1urcu_1_1exempt__ptr.html">cds::urcu::exempt_ptr</a>&lt; <a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4.html#aaed9b1acee4c48f573a800a921289375">gc</a>, T, T, <a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4.html#aaa1d0f97e8cb375833a76cc1e7d1e8d3">disposer</a>, void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4.html#ad151e631864e27a386826e4f942861ae">exempt_ptr</a></td></tr>
<tr class="memdesc:ad151e631864e27a386826e4f942861ae inherit pub_types_classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returned pointer to <code>mapped_type</code> of extracted node. <br /></td></tr>
<tr class="separator:ad151e631864e27a386826e4f942861ae inherit pub_types_classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf85b466c8c79656546ea8193c37ccfc inherit pub_types_classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abf85b466c8c79656546ea8193c37ccfc"></a>
typedef gc::scoped_lock&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4.html#abf85b466c8c79656546ea8193c37ccfc">rcu_lock</a></td></tr>
<tr class="memdesc:abf85b466c8c79656546ea8193c37ccfc inherit pub_types_classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">RCU scoped lock. <br /></td></tr>
<tr class="separator:abf85b466c8c79656546ea8193c37ccfc inherit pub_types_classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4')"><img src="closed.png" alt="-"/>&#160;Private Member Functions inherited from <a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4.html">cds::container::BronsonAVLTreeMap&lt; cds::urcu::gc&lt; RCU &gt;, Key, T *, Traits &gt;</a></td></tr>
<tr class="memitem:a9311a5a3a29859a04f371b99ad70843c inherit pub_methods_classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9311a5a3a29859a04f371b99ad70843c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4.html#a9311a5a3a29859a04f371b99ad70843c">BronsonAVLTreeMap</a> ()</td></tr>
<tr class="memdesc:a9311a5a3a29859a04f371b99ad70843c inherit pub_methods_classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates empty map. <br /></td></tr>
<tr class="separator:a9311a5a3a29859a04f371b99ad70843c inherit pub_methods_classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3929dfff3cba5fa08766ea0ae43c241b inherit pub_methods_classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3929dfff3cba5fa08766ea0ae43c241b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4.html#a3929dfff3cba5fa08766ea0ae43c241b">~BronsonAVLTreeMap</a> ()</td></tr>
<tr class="memdesc:a3929dfff3cba5fa08766ea0ae43c241b inherit pub_methods_classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys the map. <br /></td></tr>
<tr class="separator:a3929dfff3cba5fa08766ea0ae43c241b inherit pub_methods_classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13226bcab1d76e8cf24b0038bb482e98 inherit pub_methods_classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4"><td class="memTemplParams" colspan="2">template&lt;typename K &gt; </td></tr>
<tr class="memitem:a13226bcab1d76e8cf24b0038bb482e98 inherit pub_methods_classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4.html#a13226bcab1d76e8cf24b0038bb482e98">insert</a> (K const &amp;key, <a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4.html#aa955a3d4f22ee5ef4026606f9b7eb487">mapped_type</a> pVal)</td></tr>
<tr class="memdesc:a13226bcab1d76e8cf24b0038bb482e98 inherit pub_methods_classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new node.  <a href="#a13226bcab1d76e8cf24b0038bb482e98">More...</a><br /></td></tr>
<tr class="separator:a13226bcab1d76e8cf24b0038bb482e98 inherit pub_methods_classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c09bb36626732fc37ecf54981bd0a96 inherit pub_methods_classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4"><td class="memTemplParams" colspan="2">template&lt;typename K &gt; </td></tr>
<tr class="memitem:a6c09bb36626732fc37ecf54981bd0a96 inherit pub_methods_classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; bool, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4.html#a6c09bb36626732fc37ecf54981bd0a96">update</a> (K const &amp;key, <a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4.html#aa955a3d4f22ee5ef4026606f9b7eb487">mapped_type</a> pVal, bool bInsert=true)</td></tr>
<tr class="memdesc:a6c09bb36626732fc37ecf54981bd0a96 inherit pub_methods_classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the value for <code>key</code>.  <a href="#a6c09bb36626732fc37ecf54981bd0a96">More...</a><br /></td></tr>
<tr class="separator:a6c09bb36626732fc37ecf54981bd0a96 inherit pub_methods_classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c94f4a0fb5127e5ff5443f5c3367119 inherit pub_methods_classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4"><td class="memTemplParams" colspan="2">template&lt;typename K &gt; </td></tr>
<tr class="memitem:a0c94f4a0fb5127e5ff5443f5c3367119 inherit pub_methods_classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4.html#a0c94f4a0fb5127e5ff5443f5c3367119">erase</a> (K const &amp;key)</td></tr>
<tr class="memdesc:a0c94f4a0fb5127e5ff5443f5c3367119 inherit pub_methods_classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete <code>key</code> from the map.  <a href="#a0c94f4a0fb5127e5ff5443f5c3367119">More...</a><br /></td></tr>
<tr class="separator:a0c94f4a0fb5127e5ff5443f5c3367119 inherit pub_methods_classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0366890161a2a550abfc858eb85d1ccf inherit pub_methods_classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4"><td class="memTemplParams" colspan="2">template&lt;typename K , typename Less &gt; </td></tr>
<tr class="memitem:a0366890161a2a550abfc858eb85d1ccf inherit pub_methods_classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4.html#a0366890161a2a550abfc858eb85d1ccf">erase_with</a> (K const &amp;key, Less pred)</td></tr>
<tr class="memdesc:a0366890161a2a550abfc858eb85d1ccf inherit pub_methods_classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the item from the map using <code>pred</code> predicate for searching.  <a href="#a0366890161a2a550abfc858eb85d1ccf">More...</a><br /></td></tr>
<tr class="separator:a0366890161a2a550abfc858eb85d1ccf inherit pub_methods_classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32fa503a18c8117edc55099ea6da871e inherit pub_methods_classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4"><td class="memTemplParams" colspan="2">template&lt;typename K , typename Func &gt; </td></tr>
<tr class="memitem:a32fa503a18c8117edc55099ea6da871e inherit pub_methods_classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4.html#a32fa503a18c8117edc55099ea6da871e">erase</a> (K const &amp;key, Func f)</td></tr>
<tr class="memdesc:a32fa503a18c8117edc55099ea6da871e inherit pub_methods_classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete <code>key</code> from the map.  <a href="#a32fa503a18c8117edc55099ea6da871e">More...</a><br /></td></tr>
<tr class="separator:a32fa503a18c8117edc55099ea6da871e inherit pub_methods_classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7767e7ab2b47adf96ddd91b4215f0edd inherit pub_methods_classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4"><td class="memTemplParams" colspan="2">template&lt;typename K , typename Less , typename Func &gt; </td></tr>
<tr class="memitem:a7767e7ab2b47adf96ddd91b4215f0edd inherit pub_methods_classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4.html#a7767e7ab2b47adf96ddd91b4215f0edd">erase_with</a> (K const &amp;key, Less pred, Func f)</td></tr>
<tr class="memdesc:a7767e7ab2b47adf96ddd91b4215f0edd inherit pub_methods_classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the item from the map using <code>pred</code> predicate for searching.  <a href="#a7767e7ab2b47adf96ddd91b4215f0edd">More...</a><br /></td></tr>
<tr class="separator:a7767e7ab2b47adf96ddd91b4215f0edd inherit pub_methods_classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad66eab7b97360e818168b13cb2665388 inherit pub_methods_classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4.html#ad151e631864e27a386826e4f942861ae">exempt_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4.html#ad66eab7b97360e818168b13cb2665388">extract_min</a> ()</td></tr>
<tr class="memdesc:ad66eab7b97360e818168b13cb2665388 inherit pub_methods_classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts a value with minimal key from the map.  <a href="#ad66eab7b97360e818168b13cb2665388">More...</a><br /></td></tr>
<tr class="separator:ad66eab7b97360e818168b13cb2665388 inherit pub_methods_classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9c3f0993ad9fa44530c9a2caccfeb60 inherit pub_methods_classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4"><td class="memTemplParams" colspan="2">template&lt;typename Func &gt; </td></tr>
<tr class="memitem:ac9c3f0993ad9fa44530c9a2caccfeb60 inherit pub_methods_classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4.html#ad151e631864e27a386826e4f942861ae">exempt_ptr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4.html#ac9c3f0993ad9fa44530c9a2caccfeb60">extract_min</a> (Func f)</td></tr>
<tr class="memdesc:ac9c3f0993ad9fa44530c9a2caccfeb60 inherit pub_methods_classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts minimal key key and corresponding value.  <a href="#ac9c3f0993ad9fa44530c9a2caccfeb60">More...</a><br /></td></tr>
<tr class="separator:ac9c3f0993ad9fa44530c9a2caccfeb60 inherit pub_methods_classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b5e169c62720516c5c9d4c1f3b607b3 inherit pub_methods_classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4"><td class="memTemplParams" colspan="2">template&lt;typename Func &gt; </td></tr>
<tr class="memitem:a3b5e169c62720516c5c9d4c1f3b607b3 inherit pub_methods_classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4.html#ad151e631864e27a386826e4f942861ae">exempt_ptr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4.html#a3b5e169c62720516c5c9d4c1f3b607b3">extract_max</a> (Func f)</td></tr>
<tr class="memdesc:a3b5e169c62720516c5c9d4c1f3b607b3 inherit pub_methods_classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts minimal key key and corresponding value.  <a href="#a3b5e169c62720516c5c9d4c1f3b607b3">More...</a><br /></td></tr>
<tr class="separator:a3b5e169c62720516c5c9d4c1f3b607b3 inherit pub_methods_classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec008afbe0336c747abad6d61448f640 inherit pub_methods_classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4"><td class="memTemplParams" colspan="2">template&lt;typename K , typename Func &gt; </td></tr>
<tr class="memitem:aec008afbe0336c747abad6d61448f640 inherit pub_methods_classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4.html#aec008afbe0336c747abad6d61448f640">find</a> (K const &amp;key, Func f)</td></tr>
<tr class="memdesc:aec008afbe0336c747abad6d61448f640 inherit pub_methods_classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the maximal key and corresponding value.  <a href="#aec008afbe0336c747abad6d61448f640">More...</a><br /></td></tr>
<tr class="separator:aec008afbe0336c747abad6d61448f640 inherit pub_methods_classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4f832d644c8cb32d2566b818887b689 inherit pub_methods_classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4"><td class="memTemplParams" colspan="2">template&lt;typename K , typename Less , typename Func &gt; </td></tr>
<tr class="memitem:ac4f832d644c8cb32d2566b818887b689 inherit pub_methods_classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4.html#ac4f832d644c8cb32d2566b818887b689">find_with</a> (K const &amp;key, Less pred, Func f)</td></tr>
<tr class="memdesc:ac4f832d644c8cb32d2566b818887b689 inherit pub_methods_classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the key <code>val</code> using <code>pred</code> predicate for searching.  <a href="#ac4f832d644c8cb32d2566b818887b689">More...</a><br /></td></tr>
<tr class="separator:ac4f832d644c8cb32d2566b818887b689 inherit pub_methods_classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b5e850207b41f5dce6af6468fb5dbaf inherit pub_methods_classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4"><td class="memTemplParams" colspan="2">template&lt;typename K &gt; </td></tr>
<tr class="memitem:a0b5e850207b41f5dce6af6468fb5dbaf inherit pub_methods_classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4.html#a0b5e850207b41f5dce6af6468fb5dbaf">contains</a> (K const &amp;key)</td></tr>
<tr class="memdesc:a0b5e850207b41f5dce6af6468fb5dbaf inherit pub_methods_classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the map contains <code>key</code>.  <a href="#a0b5e850207b41f5dce6af6468fb5dbaf">More...</a><br /></td></tr>
<tr class="separator:a0b5e850207b41f5dce6af6468fb5dbaf inherit pub_methods_classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c2287d7dbb737ba2911881e52a3aa32 inherit pub_methods_classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4"><td class="memTemplParams" colspan="2">template&lt;typename K , typename Less &gt; </td></tr>
<tr class="memitem:a4c2287d7dbb737ba2911881e52a3aa32 inherit pub_methods_classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4.html#a4c2287d7dbb737ba2911881e52a3aa32">contains</a> (K const &amp;key, Less pred)</td></tr>
<tr class="memdesc:a4c2287d7dbb737ba2911881e52a3aa32 inherit pub_methods_classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the map contains <code>key</code> using <code>pred</code> predicate for searching.  <a href="#a4c2287d7dbb737ba2911881e52a3aa32">More...</a><br /></td></tr>
<tr class="separator:a4c2287d7dbb737ba2911881e52a3aa32 inherit pub_methods_classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a498154314d46257923293f1a580962d0 inherit pub_methods_classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4.html#a498154314d46257923293f1a580962d0">clear</a> ()</td></tr>
<tr class="memdesc:a498154314d46257923293f1a580962d0 inherit pub_methods_classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the tree (thread safe, not atomic)  <a href="#a498154314d46257923293f1a580962d0">More...</a><br /></td></tr>
<tr class="separator:a498154314d46257923293f1a580962d0 inherit pub_methods_classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac08f24b55ec8cfecde4e9360caab8f75 inherit pub_methods_classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4.html#ac08f24b55ec8cfecde4e9360caab8f75">unsafe_clear</a> ()</td></tr>
<tr class="memdesc:ac08f24b55ec8cfecde4e9360caab8f75 inherit pub_methods_classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the tree (not thread safe)  <a href="#ac08f24b55ec8cfecde4e9360caab8f75">More...</a><br /></td></tr>
<tr class="separator:ac08f24b55ec8cfecde4e9360caab8f75 inherit pub_methods_classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cfe1823367ada09a1d67fae95766e48 inherit pub_methods_classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0cfe1823367ada09a1d67fae95766e48"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4.html#a0cfe1823367ada09a1d67fae95766e48">empty</a> () const </td></tr>
<tr class="memdesc:a0cfe1823367ada09a1d67fae95766e48 inherit pub_methods_classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the map is empty. <br /></td></tr>
<tr class="separator:a0cfe1823367ada09a1d67fae95766e48 inherit pub_methods_classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f61cb425b6f6b7fc34968010c04d2cd inherit pub_methods_classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4.html#a5f61cb425b6f6b7fc34968010c04d2cd">size</a> () const </td></tr>
<tr class="memdesc:a5f61cb425b6f6b7fc34968010c04d2cd inherit pub_methods_classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns item count in the map.  <a href="#a5f61cb425b6f6b7fc34968010c04d2cd">More...</a><br /></td></tr>
<tr class="separator:a5f61cb425b6f6b7fc34968010c04d2cd inherit pub_methods_classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d6783a45b7735c174bf37e60d67dd55 inherit pub_methods_classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4d6783a45b7735c174bf37e60d67dd55"></a>
<a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4.html#ab498349cd9695a96cdbc21e11a2f9941">stat</a> const &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4.html#a4d6783a45b7735c174bf37e60d67dd55">statistics</a> () const </td></tr>
<tr class="memdesc:a4d6783a45b7735c174bf37e60d67dd55 inherit pub_methods_classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns const reference to internal statistics. <br /></td></tr>
<tr class="separator:a4d6783a45b7735c174bf37e60d67dd55 inherit pub_methods_classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7e4233fd89fa018b0b9419f490b8b71 inherit pub_methods_classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac7e4233fd89fa018b0b9419f490b8b71"></a>
<a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4.html#a6b081575c5536963822350e265a44ad6">sync_monitor</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4.html#ac7e4233fd89fa018b0b9419f490b8b71">monitor</a> ()</td></tr>
<tr class="memdesc:ac7e4233fd89fa018b0b9419f490b8b71 inherit pub_methods_classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns reference to <code>sync_monitor</code> object. <br /></td></tr>
<tr class="separator:ac7e4233fd89fa018b0b9419f490b8b71 inherit pub_methods_classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91b0aeeecf30f6faee707119472dad4d inherit pub_methods_classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4.html#a91b0aeeecf30f6faee707119472dad4d">check_consistency</a> () const </td></tr>
<tr class="memdesc:a91b0aeeecf30f6faee707119472dad4d inherit pub_methods_classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks internal consistency (not atomic, not thread-safe)  <a href="#a91b0aeeecf30f6faee707119472dad4d">More...</a><br /></td></tr>
<tr class="separator:a91b0aeeecf30f6faee707119472dad4d inherit pub_methods_classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07a3428f7ee2f0ddcb1c27f4d7492054 inherit pub_methods_classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4"><td class="memTemplParams" colspan="2">template&lt;typename Func &gt; </td></tr>
<tr class="memitem:a07a3428f7ee2f0ddcb1c27f4d7492054 inherit pub_methods_classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4.html#a07a3428f7ee2f0ddcb1c27f4d7492054">check_consistency</a> (Func f) const </td></tr>
<tr class="memdesc:a07a3428f7ee2f0ddcb1c27f4d7492054 inherit pub_methods_classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks internal consistency (not atomic, not thread-safe)  <a href="#a07a3428f7ee2f0ddcb1c27f4d7492054">More...</a><br /></td></tr>
<tr class="separator:a07a3428f7ee2f0ddcb1c27f4d7492054 inherit pub_methods_classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_attribs_classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4"><td colspan="2" onclick="javascript:toggleInherit('pub_static_attribs_classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4')"><img src="closed.png" alt="-"/>&#160;Static Private Attributes inherited from <a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4.html">cds::container::BronsonAVLTreeMap&lt; cds::urcu::gc&lt; RCU &gt;, Key, T *, Traits &gt;</a></td></tr>
<tr class="memitem:ae222095a858065553f04e842ebca3f91 inherit pub_static_attribs_classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae222095a858065553f04e842ebca3f91"></a>
static constexpr bool const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4.html#ae222095a858065553f04e842ebca3f91">c_bRelaxedInsert</a> = traits::relaxed_insert</td></tr>
<tr class="memdesc:ae222095a858065553f04e842ebca3f91 inherit pub_static_attribs_classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enabled or disabled <a class="el" href="structcds_1_1container_1_1bronson__avltree_1_1relaxed__insert.html">relaxed insertion</a>. <br /></td></tr>
<tr class="separator:ae222095a858065553f04e842ebca3f91 inherit pub_static_attribs_classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6bb4e5ada7821e8140f694fbcad0375 inherit pub_static_attribs_classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa6bb4e5ada7821e8140f694fbcad0375"></a>
static constexpr const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4.html#aa6bb4e5ada7821e8140f694fbcad0375">c_bExtractLockExternal</a> = false</td></tr>
<tr class="memdesc:aa6bb4e5ada7821e8140f694fbcad0375 inherit pub_static_attribs_classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Group of <code>extract_xxx</code> functions does not require external locking. <br /></td></tr>
<tr class="separator:aa6bb4e5ada7821e8140f694fbcad0375 inherit pub_static_attribs_classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename RCU, typename Key, typename T, typename Traits = bronson_avltree::traits&gt;<br />
class cds::container::BronsonAVLTreeMap&lt; cds::urcu::gc&lt; RCU &gt;, Key, T, Traits &gt;</h3>

<p>Bronson et al AVL-tree (RCU specialization) </p>
<p><a class="anchor" id="cds_container_BronsonAVLTreeMap_rcu"></a> Source:</p><ul>
<li>[2010] N.Bronson, J.Casper, H.Chafi, K.Olukotun "A Practical Concurrent Binary Search Tree"</li>
<li><a href="http://github.com/nbronson/snaptree">Java implementation</a></li>
</ul>
<p>This is a concurrent AVL tree algorithm that uses hand-over-hand optimistic validation, a concurrency control mechanism for searching and navigating a binary search tree. This mechanism minimizes spurious retries when concurrent structural changes cannot affect the correctness of the search or navigation result. The algorithm is based on partially external trees, a simple scheme that simplifies deletions by leaving a routing node in the tree when deleting a node that has two children, then opportunistically unlinking routing nodes during rebalancing. As in external trees, which store values only in leaf nodes, deletions can be performed locally while holding a fixed number of locks. Partially external trees, however, require far fewer routing nodes than an external tree for most sequences of insertions and deletions. The algorithm uses optimistic concurrency control, but carefully manage the tree in such a way that all atomic regions have fixed read and write sets that are known ahead of time. This allows to reduce practical overheads by embedding the concurrency control directly. To perform tree operations using only fixed sized atomic regions the algo uses the following mechanisms: search operations overlap atomic blocks as in the hand-over-hand locking technique; mutations perform rebalancing separately; and deletions occasionally leave a routing node in the tree.</p>
<p><b>Template arguments</b>:</p><ul>
<li><code>RCU</code> - one of <a class="el" href="namespacecds_1_1urcu.html#cds_urcu_gc">RCU type</a></li>
<li><code>Key</code> - key type</li>
<li><code>T</code> - value type to be stored in tree's nodes.</li>
<li><code>Traits</code> - tree traits, default is <code><a class="el" href="structcds_1_1container_1_1bronson__avltree_1_1traits.html" title="BronsonAVLTreeMap traits ">bronson_avltree::traits</a></code> It is possible to declare option-based tree with <code><a class="el" href="structcds_1_1container_1_1bronson__avltree_1_1make__traits.html" title="Metafunction converting option list to BronsonAVLTreeMap traits. ">bronson_avltree::make_traits</a></code> metafunction instead of <code>Traits</code> template argument.</li>
</ul>
<p>There is <a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4.html#cds_container_BronsonAVLTreeMap_rcu_ptr">a specialization</a> for "key -&gt; value pointer" map.</p>
<dl class="section note"><dt>Note</dt><dd>Before including <code>&lt;cds/container/bronson_avltree_map_rcu.h&gt;</code> you should include appropriate RCU header file, see <a class="el" href="namespacecds_1_1urcu.html#cds_urcu_gc">RCU type</a> for list of existing RCU class and corresponding header files. </dd></dl>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a58640b952b9b70161e99397e349700ca"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RCU , typename Key , typename T , typename Traits  = bronson_avltree::traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map.html">cds::container::BronsonAVLTreeMap</a>&lt; cds::urcu::gc&lt; RCU &gt;, Key, T, Traits &gt;::check_consistency </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks internal consistency (not atomic, not thread-safe) </p>
<p>The debugging function to check internal consistency of the tree. </p>

</div>
</div>
<a class="anchor" id="a925835747f15603be749debb6e73b60b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RCU , typename Key , typename T , typename Traits  = bronson_avltree::traits&gt; </div>
<div class="memtemplate">
template&lt;typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map.html">cds::container::BronsonAVLTreeMap</a>&lt; cds::urcu::gc&lt; RCU &gt;, Key, T, Traits &gt;::check_consistency </td>
          <td>(</td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks internal consistency (not atomic, not thread-safe) </p>
<p>The debugging function to check internal consistency of the tree. The functor <code>Func</code> is called if a violation of internal tree structure is found: </p><div class="fragment"><div class="line"><span class="keyword">struct </span>functor {</div>
<div class="line">    <span class="keywordtype">void</span> operator()( <span class="keywordtype">size_t</span> nLevel, <span class="keywordtype">size_t</span> hLeft, <span class="keywordtype">size_t</span> hRight );</div>
<div class="line">};</div>
</div><!-- fragment --><p> where</p><ul>
<li><code>nLevel</code> - the level where the violation is found</li>
<li><code>hLeft</code> - the height of left subtree</li>
<li><code>hRight</code> - the height of right subtree</li>
</ul>
<p>The functor is called for each violation found. </p>

</div>
</div>
<a class="anchor" id="a1f5e5bdd93442d44bf7a188f85530856"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RCU , typename Key , typename T , typename Traits  = bronson_avltree::traits&gt; </div>
<div class="memtemplate">
template&lt;typename K &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map.html">cds::container::BronsonAVLTreeMap</a>&lt; cds::urcu::gc&lt; RCU &gt;, Key, T, Traits &gt;::contains </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether the map contains <code>key</code>. </p>
<p>The function searches the item with key equal to <code>key</code> and returns <code>true</code> if it is found, and <code>false</code> otherwise.</p>
<p>The function applies RCU lock internally. </p>

</div>
</div>
<a class="anchor" id="a62d1483913a15e119c3e144b8511d582"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RCU , typename Key , typename T , typename Traits  = bronson_avltree::traits&gt; </div>
<div class="memtemplate">
template&lt;typename K , typename Less &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map.html">cds::container::BronsonAVLTreeMap</a>&lt; cds::urcu::gc&lt; RCU &gt;, Key, T, Traits &gt;::contains </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Less&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether the map contains <code>key</code> using <code>pred</code> predicate for searching. </p>
<p>The function is similar to <code>contains( key )</code> but <code>pred</code> is used for key comparing. <code>Less</code> functor has the interface like <code>std::less</code>. <code>Less</code> must imply the same element order as the comparator used for building the set. </p>

</div>
</div>
<a class="anchor" id="a3e01d5bd72320153774deb96da431660"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RCU , typename Key , typename T , typename Traits  = bronson_avltree::traits&gt; </div>
<div class="memtemplate">
template&lt;typename K , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map.html">cds::container::BronsonAVLTreeMap</a>&lt; cds::urcu::gc&lt; RCU &gt;, Key, T, Traits &gt;::emplace </td>
          <td>(</td>
          <td class="paramtype">K &amp;&amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For key <code>key</code> inserts data of type <code>mapped_type</code> created in-place from <code>args</code>. </p>
<p>Returns <code>true</code> if inserting successful, <code>false</code> otherwise.</p>
<p>RCU <code>synchronize()</code> method can be called. RCU should not be locked. </p>

</div>
</div>
<a class="anchor" id="a1a4b1fd14e91c647f2356e911a4f2a1a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RCU , typename Key , typename T , typename Traits  = bronson_avltree::traits&gt; </div>
<div class="memtemplate">
template&lt;typename K &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map.html">cds::container::BronsonAVLTreeMap</a>&lt; cds::urcu::gc&lt; RCU &gt;, Key, T, Traits &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Delete <code>key</code> from the map. </p>
<p>RCU <code>synchronize()</code> method can be called. RCU should not be locked.</p>
<p>Return <code>true</code> if <code>key</code> is found and deleted, <code>false</code> otherwise </p>

</div>
</div>
<a class="anchor" id="a9f0cb31cfbeca3aa58fb48dc1401c0c9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RCU , typename Key , typename T , typename Traits  = bronson_avltree::traits&gt; </div>
<div class="memtemplate">
template&lt;typename K , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map.html">cds::container::BronsonAVLTreeMap</a>&lt; cds::urcu::gc&lt; RCU &gt;, Key, T, Traits &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Delete <code>key</code> from the map. </p>
<p><a class="anchor" id="cds_nonintrusive_BronsonAVLTreeMap_rcu_erase_func"></a> The function searches an item with key <code>key</code>, calls <code>f</code> functor and deletes the item. If <code>key</code> is not found, the functor is not called.</p>
<p>The functor <code>Func</code> interface: </p><div class="fragment"><div class="line"><span class="keyword">struct </span>extractor {</div>
<div class="line">    <span class="keywordtype">void</span> operator()(<a class="code" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a19f5fcd50d2125780854c19e316ee49e">key_type</a> <span class="keyword">const</span>&amp; key, <a class="code" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#ad3f5c2ab6ebcf04e7dcf5125ec8058e6">mapped_type</a>&amp; item) { ... }</div>
<div class="line">};</div>
</div><!-- fragment --><p>RCU <code>synchronize</code> method can be called. RCU should not be locked.</p>
<p>Return <code>true</code> if key is found and deleted, <code>false</code> otherwise </p>

</div>
</div>
<a class="anchor" id="a70205077f86a8ec4a6dda4f52b8d96af"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RCU , typename Key , typename T , typename Traits  = bronson_avltree::traits&gt; </div>
<div class="memtemplate">
template&lt;typename K , typename Less &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map.html">cds::container::BronsonAVLTreeMap</a>&lt; cds::urcu::gc&lt; RCU &gt;, Key, T, Traits &gt;::erase_with </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Less&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deletes the item from the map using <code>pred</code> predicate for searching. </p>
<p>The function is an analog of <code><a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a1a4b1fd14e91c647f2356e911a4f2a1a" title="Delete key from the map. ">erase(K const&amp;)</a></code> but <code>pred</code> is used for key comparing. <code>Less</code> functor has the interface like <code>std::less</code>. <code>Less</code> must imply the same element order as the comparator used for building the map. </p>

</div>
</div>
<a class="anchor" id="af138ff4bf3da3b33a8cf074ca8a2d131"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RCU , typename Key , typename T , typename Traits  = bronson_avltree::traits&gt; </div>
<div class="memtemplate">
template&lt;typename K , typename Less , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map.html">cds::container::BronsonAVLTreeMap</a>&lt; cds::urcu::gc&lt; RCU &gt;, Key, T, Traits &gt;::erase_with </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Less&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deletes the item from the map using <code>pred</code> predicate for searching. </p>
<p>The function is an analog of <a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#cds_nonintrusive_BronsonAVLTreeMap_rcu_erase_func">erase(K const&amp;, Func)</a> but <code>pred</code> is used for key comparing. <code>Less</code> functor has the interface like <code>std::less</code>. <code>Less</code> must imply the same element order as the comparator used for building the map. </p>

</div>
</div>
<a class="anchor" id="a279a8bc01074fd53a8ac333676f0089c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RCU , typename Key , typename T , typename Traits  = bronson_avltree::traits&gt; </div>
<div class="memtemplate">
template&lt;typename Q &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a49e823c7277e6a8ffc84fd280863b401">exempt_ptr</a> <a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map.html">cds::container::BronsonAVLTreeMap</a>&lt; cds::urcu::gc&lt; RCU &gt;, Key, T, Traits &gt;::extract </td>
          <td>(</td>
          <td class="paramtype">Q const &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extracts an item from the map. </p>
<p>The function searches an item with key equal to <code>key</code> in the tree, unlinks it, and returns <code>exempt_ptr</code> pointer to a value found. If <code>key</code> is not found the function returns an empty <code>exempt_ptr</code>.</p>
<p>RCU <code>synchronize</code> method can be called. RCU should NOT be locked. The function does not destroy the value found. The dealloctor will be implicitly invoked when the returned object is destroyed or when its <code>release()</code> member function is called. </p>

</div>
</div>
<a class="anchor" id="a52be1f9b07b54faef3a5e7c5dda88952"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RCU , typename Key , typename T , typename Traits  = bronson_avltree::traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a49e823c7277e6a8ffc84fd280863b401">exempt_ptr</a> <a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map.html">cds::container::BronsonAVLTreeMap</a>&lt; cds::urcu::gc&lt; RCU &gt;, Key, T, Traits &gt;::extract_max </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extracts an item with maximal key from the map. </p>
<p>Returns <code>exempt_ptr</code> pointer to the rightmost item. If the set is empty, returns empty <code>exempt_ptr</code>.</p>
<p>Note that the function returns only the value for maximal key. To retrieve its key use <code><a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a82e61d4458f926a627ccdfc691f2b82f" title="Extracts the maximal key and corresponding value. ">extract_max( Func )</a></code> or <code><a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#ae4557da16d7b87085f500dd403f7b8e4" title="Extracts the maximal key and corresponding value. ">extract_max_key(key_type&amp;)</a></code> member function.</p>
<dl class="section note"><dt>Note</dt><dd>Due the concurrent nature of the map, the function extracts <em>nearly</em> maximal key. It means that the function gets rightmost leaf of the tree and tries to unlink it. During unlinking, a concurrent thread may insert an item with key great than leftmost item's key. So, the function returns the item with maximum key at the moment of tree traversing.</dd></dl>
<p>RCU <code>synchronize</code> method can be called. RCU should NOT be locked. The function does not free the item. The deallocator will be implicitly invoked when the returned object is destroyed or when its <code>release()</code> is called. </p>

</div>
</div>
<a class="anchor" id="a82e61d4458f926a627ccdfc691f2b82f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RCU , typename Key , typename T , typename Traits  = bronson_avltree::traits&gt; </div>
<div class="memtemplate">
template&lt;typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a49e823c7277e6a8ffc84fd280863b401">exempt_ptr</a> <a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map.html">cds::container::BronsonAVLTreeMap</a>&lt; cds::urcu::gc&lt; RCU &gt;, Key, T, Traits &gt;::extract_max </td>
          <td>(</td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extracts the maximal key and corresponding value. </p>
<p>Returns <code>exempt_ptr</code> pointer to the rightmost item. If the set is empty, returns empty <code>exempt_ptr</code>.</p>
<p><code>Func</code> functor is used to store maximal key. <code>Func</code> has the following signature: </p><div class="fragment"><div class="line"><span class="keyword">struct </span>functor {</div>
<div class="line">    <span class="keywordtype">void</span> operator()( <a class="code" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a19f5fcd50d2125780854c19e316ee49e">key_type</a> <span class="keyword">const</span>&amp; key );</div>
<div class="line">};</div>
</div><!-- fragment --><p> If the tree is empty, <code>f</code> is not called. Otherwise, is it called with maximal key, the pointer to corresponding value is returned as <code>exempt_ptr</code>.</p>
<dl class="section note"><dt>Note</dt><dd>Due the concurrent nature of the map, the function extracts <em>nearly</em> maximal key. It means that the function gets rightmost leaf of the tree and tries to unlink it. During unlinking, a concurrent thread may insert an item with key great than leftmost item's key. So, the function returns the item with maximum key at the moment of tree traversing.</dd></dl>
<p>RCU <code>synchronize</code> method can be called. RCU should NOT be locked. The function does not free the item. The deallocator will be implicitly invoked when the returned object is destroyed or when its <code>release()</code> is called. </p>

</div>
</div>
<a class="anchor" id="ae4557da16d7b87085f500dd403f7b8e4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RCU , typename Key , typename T , typename Traits  = bronson_avltree::traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_copy_assignable&lt;<a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a19f5fcd50d2125780854c19e316ee49e">key_type</a>&gt;::value, <a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a49e823c7277e6a8ffc84fd280863b401">exempt_ptr</a> &gt;::type <a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map.html">cds::container::BronsonAVLTreeMap</a>&lt; cds::urcu::gc&lt; RCU &gt;, Key, T, Traits &gt;::extract_max_key </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a19f5fcd50d2125780854c19e316ee49e">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>max_key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extracts the maximal key and corresponding value. </p>
<p>This function is a shortcut for the following call: </p><div class="fragment"><div class="line"><a class="code" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a19f5fcd50d2125780854c19e316ee49e">key_type</a> key;</div>
<div class="line"><a class="code" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a49e823c7277e6a8ffc84fd280863b401">exempt_ptr</a> xp = theTree.extract_max( [&amp;key]( <a class="code" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a19f5fcd50d2125780854c19e316ee49e">key_type</a> <span class="keyword">const</span>&amp; k ) { key = k; } );</div>
</div><!-- fragment --><p> <code>key_type</code> should be copy-assignable. The copy of maximal key is returned in <code>max_key</code> argument. </p>

</div>
</div>
<a class="anchor" id="a67612de75c25b7151be2d72a1d4e6cd5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RCU , typename Key , typename T , typename Traits  = bronson_avltree::traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a49e823c7277e6a8ffc84fd280863b401">exempt_ptr</a> <a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map.html">cds::container::BronsonAVLTreeMap</a>&lt; cds::urcu::gc&lt; RCU &gt;, Key, T, Traits &gt;::extract_min </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extracts a value with minimal key from the map. </p>
<p>Returns <code>exempt_ptr</code> pointer to the leftmost item. If the set is empty, returns empty <code>exempt_ptr</code>.</p>
<p>Note that the function returns only the value for minimal key. To retrieve its key use <code><a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#abd9da9fa1c8634920d2b81b61799e846" title="Extracts minimal key key and corresponding value. ">extract_min( Func )</a></code> member function.</p>
<dl class="section note"><dt>Note</dt><dd>Due the concurrent nature of the map, the function extracts <em>nearly</em> minimum key. It means that the function gets leftmost leaf of the tree and tries to unlink it. During unlinking, a concurrent thread may insert an item with key less than leftmost item's key. So, the function returns the item with minimum key at the moment of tree traversing.</dd></dl>
<p>RCU <code>synchronize</code> method can be called. RCU should NOT be locked. The function does not free the item. The deallocator will be implicitly invoked when the returned object is destroyed or when its <code>release()</code> member function is called. </p>

</div>
</div>
<a class="anchor" id="abd9da9fa1c8634920d2b81b61799e846"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RCU , typename Key , typename T , typename Traits  = bronson_avltree::traits&gt; </div>
<div class="memtemplate">
template&lt;typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a49e823c7277e6a8ffc84fd280863b401">exempt_ptr</a> <a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map.html">cds::container::BronsonAVLTreeMap</a>&lt; cds::urcu::gc&lt; RCU &gt;, Key, T, Traits &gt;::extract_min </td>
          <td>(</td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extracts minimal key key and corresponding value. </p>
<p>Returns <code>exempt_ptr</code> to the leftmost item. If the tree is empty, returns empty <code>exempt_ptr</code>.</p>
<p><code>Func</code> functor is used to store minimal key. <code>Func</code> has the following signature: </p><div class="fragment"><div class="line"><span class="keyword">struct </span>functor {</div>
<div class="line">    <span class="keywordtype">void</span> operator()( <a class="code" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a19f5fcd50d2125780854c19e316ee49e">key_type</a> <span class="keyword">const</span>&amp; key );</div>
<div class="line">};</div>
</div><!-- fragment --><p> If the tree is empty, <code>f</code> is not called. Otherwise, is it called with minimal key, the pointer to corresponding value is returned as <code>exempt_ptr</code>.</p>
<dl class="section note"><dt>Note</dt><dd>Due the concurrent nature of the map, the function extracts <em>nearly</em> minimum key. It means that the function gets leftmost leaf of the tree and tries to unlink it. During unlinking, a concurrent thread may insert an item with key less than leftmost item's key. So, the function returns the item with minimum key at the moment of tree traversing.</dd></dl>
<p>RCU <code>synchronize</code> method can be called. RCU should NOT be locked. The function does not free the item. The deallocator will be implicitly invoked when the returned object is destroyed or when its <code>release()</code> member function is called. </p>

</div>
</div>
<a class="anchor" id="a9f7c615b5d2dae6d05a0365cbecdc5a6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RCU , typename Key , typename T , typename Traits  = bronson_avltree::traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_copy_assignable&lt;<a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a19f5fcd50d2125780854c19e316ee49e">key_type</a>&gt;::value, <a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a49e823c7277e6a8ffc84fd280863b401">exempt_ptr</a> &gt;::type <a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map.html">cds::container::BronsonAVLTreeMap</a>&lt; cds::urcu::gc&lt; RCU &gt;, Key, T, Traits &gt;::extract_min_key </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a19f5fcd50d2125780854c19e316ee49e">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>min_key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extracts minimal key key and corresponding value. </p>
<p>This function is a shortcut for the following call: </p><div class="fragment"><div class="line"><a class="code" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a19f5fcd50d2125780854c19e316ee49e">key_type</a> key;</div>
<div class="line"><a class="code" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a49e823c7277e6a8ffc84fd280863b401">exempt_ptr</a> xp = theTree.extract_min( [&amp;key]( <a class="code" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a19f5fcd50d2125780854c19e316ee49e">key_type</a> <span class="keyword">const</span>&amp; k ) { key = k; } );</div>
</div><!-- fragment --><p> <code>key_type</code> should be copy-assignable. The copy of minimal key is returned in <code>min_key</code> argument. </p>

</div>
</div>
<a class="anchor" id="ac4a39c4e20350146eede4a39c21b1442"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RCU , typename Key , typename T , typename Traits  = bronson_avltree::traits&gt; </div>
<div class="memtemplate">
template&lt;typename Q , typename Less &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a49e823c7277e6a8ffc84fd280863b401">exempt_ptr</a> <a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map.html">cds::container::BronsonAVLTreeMap</a>&lt; cds::urcu::gc&lt; RCU &gt;, Key, T, Traits &gt;::extract_with </td>
          <td>(</td>
          <td class="paramtype">Q const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Less&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extracts an item from the map using <code>pred</code> for searching. </p>
<p>The function is an analog of <code><a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a279a8bc01074fd53a8ac333676f0089c" title="Extracts an item from the map. ">extract(Q const&amp;)</a></code> but <code>pred</code> is used for key compare. <code>Less</code> has the interface like <code>std::less</code>. <code>pred</code> must imply the same element order as the comparator used for building the map. </p>

</div>
</div>
<a class="anchor" id="a9727d6aecbc2fc75e7fd0631a3b9f052"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RCU , typename Key , typename T , typename Traits  = bronson_avltree::traits&gt; </div>
<div class="memtemplate">
template&lt;typename K , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map.html">cds::container::BronsonAVLTreeMap</a>&lt; cds::urcu::gc&lt; RCU &gt;, Key, T, Traits &gt;::find </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the key <code>key</code>. </p>
<p>The function searches the item with key equal to <code>key</code> and calls the functor <code>f</code> for item found. The interface of <code>Func</code> functor is: </p><div class="fragment"><div class="line"><span class="keyword">struct </span>functor {</div>
<div class="line">    <span class="keywordtype">void</span> operator()( <a class="code" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a19f5fcd50d2125780854c19e316ee49e">key_type</a> <span class="keyword">const</span>&amp; key, <a class="code" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#ad3f5c2ab6ebcf04e7dcf5125ec8058e6">mapped_type</a>&amp; val );</div>
<div class="line">};</div>
</div><!-- fragment --><p> where <code>val</code> is the item found for <code>key</code> The functor is called under node-level lock.</p>
<p>The function applies RCU lock internally.</p>
<p>The function returns <code>true</code> if <code>key</code> is found, <code>false</code> otherwise. </p>

</div>
</div>
<a class="anchor" id="a95239282385efb4e8446e6d1daa47bb4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RCU , typename Key , typename T , typename Traits  = bronson_avltree::traits&gt; </div>
<div class="memtemplate">
template&lt;typename K , typename Less , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map.html">cds::container::BronsonAVLTreeMap</a>&lt; cds::urcu::gc&lt; RCU &gt;, Key, T, Traits &gt;::find_with </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Less&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the key <code>val</code> using <code>pred</code> predicate for searching. </p>
<p>The function is an analog of <code><a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a9727d6aecbc2fc75e7fd0631a3b9f052" title="Find the key key. ">find(K const&amp;, Func)</a></code> but <code>pred</code> is used for key comparing. <code>Less</code> functor has the interface like <code>std::less</code>. <code>Less</code> must imply the same element order as the comparator used for building the map. </p>

</div>
</div>
<a class="anchor" id="a737a79db0162c98dd5d462966892464d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RCU , typename Key , typename T , typename Traits  = bronson_avltree::traits&gt; </div>
<div class="memtemplate">
template&lt;typename K &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map.html">cds::container::BronsonAVLTreeMap</a>&lt; cds::urcu::gc&lt; RCU &gt;, Key, T, Traits &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts new node with <code>key</code> and default value. </p>
<p>The function creates a node with <code>key</code> and default value, and then inserts the node created into the map.</p>
<p>Preconditions:</p><ul>
<li>The <code>key_type</code> should be constructible from a value of type <code>K</code>.</li>
<li>The <code>mapped_type</code> should be default-constructible.</li>
</ul>
<p>RCU <code>synchronize()</code> can be called. RCU should not be locked.</p>
<p>Returns <code>true</code> if inserting successful, <code>false</code> otherwise. </p>

</div>
</div>
<a class="anchor" id="a6720c8decba4c64dcbe6a6ef64ab016a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RCU , typename Key , typename T , typename Traits  = bronson_avltree::traits&gt; </div>
<div class="memtemplate">
template&lt;typename K , typename V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map.html">cds::container::BronsonAVLTreeMap</a>&lt; cds::urcu::gc&lt; RCU &gt;, Key, T, Traits &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">V const &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts new node. </p>
<p>The function creates a node with copy of <code>val</code> value and then inserts the node created into the map.</p>
<p>Preconditions:</p><ul>
<li>The <code>key_type</code> should be constructible from <code>key</code> of type <code>K</code>.</li>
<li>The <code>mapped_type</code> should be constructible from <code>val</code> of type <code>V</code>.</li>
</ul>
<p>RCU <code>synchronize()</code> method can be called. RCU should not be locked.</p>
<p>Returns <code>true</code> if <code>val</code> is inserted into the map, <code>false</code> otherwise. </p>

</div>
</div>
<a class="anchor" id="a74b24524e3d5b2171f1f6a883d5d9dc8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RCU , typename Key , typename T , typename Traits  = bronson_avltree::traits&gt; </div>
<div class="memtemplate">
template&lt;typename K , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map.html">cds::container::BronsonAVLTreeMap</a>&lt; cds::urcu::gc&lt; RCU &gt;, Key, T, Traits &gt;::insert_with </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts new node and initialize it by a functor. </p>
<p>This function inserts new node with key <code>key</code> and if inserting is successful then it calls <code>func</code> functor with signature </p><div class="fragment"><div class="line"><span class="keyword">struct </span>functor {</div>
<div class="line">    <span class="keywordtype">void</span> operator()( <a class="code" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a19f5fcd50d2125780854c19e316ee49e">key_type</a> <span class="keyword">const</span>&amp; key, <a class="code" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#ad3f5c2ab6ebcf04e7dcf5125ec8058e6">mapped_type</a>&amp; item );</div>
<div class="line">};</div>
</div><!-- fragment --><p>The key_type should be constructible from value of type <code>K</code>.</p>
<p>The function allows to split creating of new item into two part:</p><ul>
<li>create item from <code>key</code>;</li>
<li>insert new item into the map;</li>
<li>if inserting is successful, initialize the value of item by calling <code>func</code> functor</li>
</ul>
<p>This can be useful if complete initialization of object of <code>value_type</code> is heavyweight and it is preferable that the initialization should be completed only if inserting is successful. The functor is called under the node lock.</p>
<p>RCU <code>synchronize()</code> method can be called. RCU should not be locked. </p>

</div>
</div>
<a class="anchor" id="ae32da787c023d704683927f45baba2fb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RCU , typename Key , typename T , typename Traits  = bronson_avltree::traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map.html">cds::container::BronsonAVLTreeMap</a>&lt; cds::urcu::gc&lt; RCU &gt;, Key, T, Traits &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns item count in the map. </p>
<p>Only leaf nodes containing user data are counted.</p>
<p>The value returned depends on item counter type provided by <code>Traits</code> template parameter. If it is <code><a class="el" href="classcds_1_1atomicity_1_1empty__item__counter.html" title="Empty item counter. ">atomicity::empty_item_counter</a></code> this function always returns 0.</p>
<p>The function is not suitable for checking the tree emptiness, use <code><a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a6b72a9f5f7ab07c7f2707b18d880f547" title="Checks if the map is empty. ">empty()</a></code> member function for this purpose. </p>

</div>
</div>
<a class="anchor" id="a1b6c39f2ac7ac37051aae2e00eb0e5ea"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RCU , typename Key , typename T , typename Traits  = bronson_avltree::traits&gt; </div>
<div class="memtemplate">
template&lt;typename K , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;bool, bool&gt; <a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map.html">cds::container::BronsonAVLTreeMap</a>&lt; cds::urcu::gc&lt; RCU &gt;, Key, T, Traits &gt;::update </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bAllowInsert</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Updates the value for <code>key</code>. </p>
<p>The operation performs inserting or changing data with lock-free manner.</p>
<p>If the <code>key</code> not found in the map, then the new item created from <code>key</code> will be inserted into the map iff <code>bAllowInsert</code> is <code>true</code> (note that in this case the <a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a19f5fcd50d2125780854c19e316ee49e">key_type</a> should be constructible from type <code>K</code>). Otherwise, the functor <code>func</code> is called with item found. The functor <code>Func</code> signature is: </p><div class="fragment"><div class="line"><span class="keyword">struct </span>my_functor {</div>
<div class="line">    <span class="keywordtype">void</span> operator()( <span class="keywordtype">bool</span> bNew, <a class="code" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a19f5fcd50d2125780854c19e316ee49e">key_type</a> <span class="keyword">const</span>&amp; key, <a class="code" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#ad3f5c2ab6ebcf04e7dcf5125ec8058e6">mapped_type</a>&amp; item );</div>
<div class="line">};</div>
</div><!-- fragment --><p>with arguments:</p><ul>
<li><code>bNew</code> - <code>true</code> if the item has been inserted, <code>false</code> otherwise</li>
<li><code>item</code> - value</li>
</ul>
<p>The functor may change any fields of the <code>item</code>. The functor is called under the node lock, the caller can change any field of <code>item</code>.</p>
<p>RCU <code>synchronize()</code> method can be called. RCU should not be locked.</p>
<p>Returns <code> std::pair&lt;bool, bool&gt; </code> where <code>first</code> is <code>true</code> if operation is successfull, <code>second</code> is <code>true</code> if new item has been added or <code>false</code> if the item with <code>key</code> already exists. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>cds/container/bronson_avltree_map_rcu.h</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<hr/>
<div align="right">
  <b>cds</b> <b>2.1.0</b> 
  Developed by <i>Maxim Khizhinsky aka khizmax</i> 2007 - 2015
  <br/>
  <i>Autogenerated Wed Jan 6 2016 16:00:36 by Doxygen 1.8.10</i>
</div>
</body>
</html>
