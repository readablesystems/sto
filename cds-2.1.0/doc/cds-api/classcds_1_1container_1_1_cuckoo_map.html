<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>cds: cds::container::CuckooMap&lt; Key, T, Traits &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">cds
   &#160;<span id="projectnumber">2.1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="classes.html"><span>Data&#160;Structure&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Data&#160;Fields</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classcds_1_1container_1_1_cuckoo_map.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a>  </div>
  <div class="headertitle">
<div class="title">cds::container::CuckooMap&lt; Key, T, Traits &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__cds__nonintrusive__containers.html">Non-intrusive containers</a> &raquo; <a class="el" href="group__cds__nonintrusive__map.html">Map</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Cuckoo hash map.  
 <a href="classcds_1_1container_1_1_cuckoo_map.html#details">More...</a></p>

<p><code>#include &lt;cds/container/cuckoo_map.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for cds::container::CuckooMap&lt; Key, T, Traits &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classcds_1_1container_1_1_cuckoo_map.png" usemap="#cds::container::CuckooMap&lt; Key, T, Traits &gt;_map" alt=""/>
  <map id="cds::container::CuckooMap&lt; Key, T, Traits &gt;_map" name="cds::container::CuckooMap&lt; Key, T, Traits &gt;_map">
<area href="classcds_1_1intrusive_1_1_cuckoo_set.html" alt="cds::intrusive::CuckooSet&lt; std::pair&lt; Key const, T &gt;, Traits &gt;" shape="rect" coords="0,0,358,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a3da032600868e73a64b352ee8fde1ad2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3da032600868e73a64b352ee8fde1ad2"></a>
typedef Key&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_cuckoo_map.html#a3da032600868e73a64b352ee8fde1ad2">key_type</a></td></tr>
<tr class="memdesc:a3da032600868e73a64b352ee8fde1ad2"><td class="mdescLeft">&#160;</td><td class="mdescRight">key type <br /></td></tr>
<tr class="separator:a3da032600868e73a64b352ee8fde1ad2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab64c43804999ac92124b547ee9d35721"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab64c43804999ac92124b547ee9d35721"></a>
typedef T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_cuckoo_map.html#ab64c43804999ac92124b547ee9d35721">mapped_type</a></td></tr>
<tr class="memdesc:ab64c43804999ac92124b547ee9d35721"><td class="mdescLeft">&#160;</td><td class="mdescRight">value type stored in the container <br /></td></tr>
<tr class="separator:ab64c43804999ac92124b547ee9d35721"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b7029bea19087f7565784426abffcba"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6b7029bea19087f7565784426abffcba"></a>
typedef std::pair&lt; <a class="el" href="classcds_1_1container_1_1_cuckoo_map.html#a3da032600868e73a64b352ee8fde1ad2">key_type</a> const, <a class="el" href="classcds_1_1container_1_1_cuckoo_map.html#ab64c43804999ac92124b547ee9d35721">mapped_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_cuckoo_map.html#a6b7029bea19087f7565784426abffcba">value_type</a></td></tr>
<tr class="memdesc:a6b7029bea19087f7565784426abffcba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Key-value pair type stored in the map. <br /></td></tr>
<tr class="separator:a6b7029bea19087f7565784426abffcba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3c2558118ee46b4e8e3dac4ecfc4e24"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae3c2558118ee46b4e8e3dac4ecfc4e24"></a>
typedef Traits&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_cuckoo_map.html#ae3c2558118ee46b4e8e3dac4ecfc4e24">traits</a></td></tr>
<tr class="memdesc:ae3c2558118ee46b4e8e3dac4ecfc4e24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map traits. <br /></td></tr>
<tr class="separator:ae3c2558118ee46b4e8e3dac4ecfc4e24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40094438568aee8e8bf456585ff0c15d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a40094438568aee8e8bf456585ff0c15d"></a>
typedef traits::hash&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_cuckoo_map.html#a40094438568aee8e8bf456585ff0c15d">hash</a></td></tr>
<tr class="memdesc:a40094438568aee8e8bf456585ff0c15d"><td class="mdescLeft">&#160;</td><td class="mdescRight">hash functor tuple wrapped for internal use <br /></td></tr>
<tr class="separator:a40094438568aee8e8bf456585ff0c15d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a875c8c5ecc6c99c802d7368b76cd1486"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a875c8c5ecc6c99c802d7368b76cd1486"></a>
typedef base_class::hash_tuple_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_cuckoo_map.html#a875c8c5ecc6c99c802d7368b76cd1486">hash_tuple_type</a></td></tr>
<tr class="memdesc:a875c8c5ecc6c99c802d7368b76cd1486"><td class="mdescLeft">&#160;</td><td class="mdescRight">hash tuple type <br /></td></tr>
<tr class="separator:a875c8c5ecc6c99c802d7368b76cd1486"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bf312f1c91e71a6a74d196b5812cd58"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5bf312f1c91e71a6a74d196b5812cd58"></a>
typedef base_class::mutex_policy&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_cuckoo_map.html#a5bf312f1c91e71a6a74d196b5812cd58">mutex_policy</a></td></tr>
<tr class="memdesc:a5bf312f1c91e71a6a74d196b5812cd58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concurrent access policy, see <code><a class="el" href="structcds_1_1container_1_1cuckoo_1_1traits.html#a40a7d6977e27e08e178e39521a43e07f" title="Concurrent access policy. ">cuckoo::traits::mutex_policy</a></code>. <br /></td></tr>
<tr class="separator:a5bf312f1c91e71a6a74d196b5812cd58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee847170d3b27c1e04991cf696e2fbb1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aee847170d3b27c1e04991cf696e2fbb1"></a>
typedef base_class::stat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_cuckoo_map.html#aee847170d3b27c1e04991cf696e2fbb1">stat</a></td></tr>
<tr class="memdesc:aee847170d3b27c1e04991cf696e2fbb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">internal statistics type <br /></td></tr>
<tr class="separator:aee847170d3b27c1e04991cf696e2fbb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2058c35e17dd2ddb9e855651d0767417"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2058c35e17dd2ddb9e855651d0767417"></a>
typedef base_class::key_equal_to&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_cuckoo_map.html#a2058c35e17dd2ddb9e855651d0767417">key_equal_to</a></td></tr>
<tr class="memdesc:a2058c35e17dd2ddb9e855651d0767417"><td class="mdescLeft">&#160;</td><td class="mdescRight">Key equality functor; used only for unordered probe-set. <br /></td></tr>
<tr class="separator:a2058c35e17dd2ddb9e855651d0767417"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a068b7713f5bb6a55525a5cbbdcf1af71"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a068b7713f5bb6a55525a5cbbdcf1af71"></a>
typedef base_class::key_comparator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_cuckoo_map.html#a068b7713f5bb6a55525a5cbbdcf1af71">key_comparator</a></td></tr>
<tr class="memdesc:a068b7713f5bb6a55525a5cbbdcf1af71"><td class="mdescLeft">&#160;</td><td class="mdescRight">key comparing functor based on <a class="el" href="structcds_1_1opt_1_1compare.html" title="[type-option] Option setter for key comparing ">opt::compare</a> and <a class="el" href="structcds_1_1opt_1_1less.html" title="[type-option] Option setter for less predicate ">opt::less</a> option setter. Used only for ordered probe set <br /></td></tr>
<tr class="separator:a068b7713f5bb6a55525a5cbbdcf1af71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe85994f6767c7a70837925330784d00"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abe85994f6767c7a70837925330784d00"></a>
typedef base_class::allocator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_cuckoo_map.html#abe85994f6767c7a70837925330784d00">allocator</a></td></tr>
<tr class="memdesc:abe85994f6767c7a70837925330784d00"><td class="mdescLeft">&#160;</td><td class="mdescRight">allocator type used for internal bucket table allocations <br /></td></tr>
<tr class="separator:abe85994f6767c7a70837925330784d00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a342ac6c8dc0817b842d39357b8e57391"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a342ac6c8dc0817b842d39357b8e57391"></a>
typedef std::conditional&lt; std::is_same&lt; typename traits::node_allocator, <a class="el" href="structcds_1_1opt_1_1none.html">opt::none</a> &gt;::value, <a class="el" href="classcds_1_1container_1_1_cuckoo_map.html#abe85994f6767c7a70837925330784d00">allocator</a>, typename traits::node_allocator &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_cuckoo_map.html#a342ac6c8dc0817b842d39357b8e57391">node_allocator</a></td></tr>
<tr class="memdesc:a342ac6c8dc0817b842d39357b8e57391"><td class="mdescLeft">&#160;</td><td class="mdescRight">Node allocator type. <br /></td></tr>
<tr class="separator:a342ac6c8dc0817b842d39357b8e57391"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a384d60fb9f53a38aa618543d235398cc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a384d60fb9f53a38aa618543d235398cc"></a>
typedef traits::item_counter&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_cuckoo_map.html#a384d60fb9f53a38aa618543d235398cc">item_counter</a></td></tr>
<tr class="memdesc:a384d60fb9f53a38aa618543d235398cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">item counter type <br /></td></tr>
<tr class="separator:a384d60fb9f53a38aa618543d235398cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a341c7da08ef0c77406969e8414e71b9d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_cuckoo_map.html#a341c7da08ef0c77406969e8414e71b9d">CuckooMap</a> ()</td></tr>
<tr class="memdesc:a341c7da08ef0c77406969e8414e71b9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="#a341c7da08ef0c77406969e8414e71b9d">More...</a><br /></td></tr>
<tr class="separator:a341c7da08ef0c77406969e8414e71b9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9004754391ab93c87e581461b63fbb44"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_cuckoo_map.html#a9004754391ab93c87e581461b63fbb44">CuckooMap</a> (size_t nInitialSize, unsigned int nProbesetSize, unsigned int nProbesetThreshold=0)</td></tr>
<tr class="memdesc:a9004754391ab93c87e581461b63fbb44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an object with given probe set size and threshold.  <a href="#a9004754391ab93c87e581461b63fbb44">More...</a><br /></td></tr>
<tr class="separator:a9004754391ab93c87e581461b63fbb44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a779df6d9d36dc26634173734b851d277"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_cuckoo_map.html#a779df6d9d36dc26634173734b851d277">CuckooMap</a> (<a class="el" href="classcds_1_1container_1_1_cuckoo_map.html#a875c8c5ecc6c99c802d7368b76cd1486">hash_tuple_type</a> const &amp;h)</td></tr>
<tr class="memdesc:a779df6d9d36dc26634173734b851d277"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an object with given hash functor tuple.  <a href="#a779df6d9d36dc26634173734b851d277">More...</a><br /></td></tr>
<tr class="separator:a779df6d9d36dc26634173734b851d277"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac976f4836e512daeabfff6683f43d323"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_cuckoo_map.html#ac976f4836e512daeabfff6683f43d323">CuckooMap</a> (size_t nInitialSize, unsigned int nProbesetSize, unsigned int nProbesetThreshold, <a class="el" href="classcds_1_1container_1_1_cuckoo_map.html#a875c8c5ecc6c99c802d7368b76cd1486">hash_tuple_type</a> const &amp;h)</td></tr>
<tr class="memdesc:ac976f4836e512daeabfff6683f43d323"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a map with given probe set properties and hash functor tuple.  <a href="#ac976f4836e512daeabfff6683f43d323">More...</a><br /></td></tr>
<tr class="separator:ac976f4836e512daeabfff6683f43d323"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16fd32ddba075fca3ffe33c44181fdb6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_cuckoo_map.html#a16fd32ddba075fca3ffe33c44181fdb6">CuckooMap</a> (<a class="el" href="classcds_1_1container_1_1_cuckoo_map.html#a875c8c5ecc6c99c802d7368b76cd1486">hash_tuple_type</a> &amp;&amp;h)</td></tr>
<tr class="memdesc:a16fd32ddba075fca3ffe33c44181fdb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a map with given hash functor tuple (move semantics)  <a href="#a16fd32ddba075fca3ffe33c44181fdb6">More...</a><br /></td></tr>
<tr class="separator:a16fd32ddba075fca3ffe33c44181fdb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bf609fe428c69dd4f794a7936bb6428"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_cuckoo_map.html#a9bf609fe428c69dd4f794a7936bb6428">CuckooMap</a> (size_t nInitialSize, unsigned int nProbesetSize, unsigned int nProbesetThreshold, <a class="el" href="classcds_1_1container_1_1_cuckoo_map.html#a875c8c5ecc6c99c802d7368b76cd1486">hash_tuple_type</a> &amp;&amp;h)</td></tr>
<tr class="memdesc:a9bf609fe428c69dd4f794a7936bb6428"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a map with given probe set properties and hash functor tuple (move semantics)  <a href="#a9bf609fe428c69dd4f794a7936bb6428">More...</a><br /></td></tr>
<tr class="separator:a9bf609fe428c69dd4f794a7936bb6428"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70fdc0789a9930b1fff07592f8085ceb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a70fdc0789a9930b1fff07592f8085ceb"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_cuckoo_map.html#a70fdc0789a9930b1fff07592f8085ceb">~CuckooMap</a> ()</td></tr>
<tr class="memdesc:a70fdc0789a9930b1fff07592f8085ceb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor clears the map. <br /></td></tr>
<tr class="separator:a70fdc0789a9930b1fff07592f8085ceb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a305d109764c5685e2f8d649c15f0ebc7"><td class="memTemplParams" colspan="2">template&lt;typename K &gt; </td></tr>
<tr class="memitem:a305d109764c5685e2f8d649c15f0ebc7"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_cuckoo_map.html#a305d109764c5685e2f8d649c15f0ebc7">insert</a> (K const &amp;key)</td></tr>
<tr class="memdesc:a305d109764c5685e2f8d649c15f0ebc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new node with key and default value.  <a href="#a305d109764c5685e2f8d649c15f0ebc7">More...</a><br /></td></tr>
<tr class="separator:a305d109764c5685e2f8d649c15f0ebc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac30d8a9a5bff3cf218c0f55809bc12bf"><td class="memTemplParams" colspan="2">template&lt;typename K , typename V &gt; </td></tr>
<tr class="memitem:ac30d8a9a5bff3cf218c0f55809bc12bf"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_cuckoo_map.html#ac30d8a9a5bff3cf218c0f55809bc12bf">insert</a> (K const &amp;key, V const &amp;val)</td></tr>
<tr class="memdesc:ac30d8a9a5bff3cf218c0f55809bc12bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new node.  <a href="#ac30d8a9a5bff3cf218c0f55809bc12bf">More...</a><br /></td></tr>
<tr class="separator:ac30d8a9a5bff3cf218c0f55809bc12bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acab9998f29a722cc9d073d08aaf6a457"><td class="memTemplParams" colspan="2">template&lt;typename K , typename Func &gt; </td></tr>
<tr class="memitem:acab9998f29a722cc9d073d08aaf6a457"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_cuckoo_map.html#acab9998f29a722cc9d073d08aaf6a457">insert_with</a> (const K &amp;key, Func func)</td></tr>
<tr class="memdesc:acab9998f29a722cc9d073d08aaf6a457"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new node and initialize it by a functor.  <a href="#acab9998f29a722cc9d073d08aaf6a457">More...</a><br /></td></tr>
<tr class="separator:acab9998f29a722cc9d073d08aaf6a457"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7b5dac039c3782313e7491e84679f8e"><td class="memTemplParams" colspan="2">template&lt;typename K , typename... Args&gt; </td></tr>
<tr class="memitem:ae7b5dac039c3782313e7491e84679f8e"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_cuckoo_map.html#ae7b5dac039c3782313e7491e84679f8e">emplace</a> (K &amp;&amp;key, Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:ae7b5dac039c3782313e7491e84679f8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">For key <code>key</code> inserts data of type <a class="el" href="classcds_1_1container_1_1_cuckoo_map.html#a6b7029bea19087f7565784426abffcba">value_type</a> constructed with <code>std::forward&lt;Args&gt;(args)...</code>  <a href="#ae7b5dac039c3782313e7491e84679f8e">More...</a><br /></td></tr>
<tr class="separator:ae7b5dac039c3782313e7491e84679f8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4aba6537a931cd08f2664a10e09bdc29"><td class="memTemplParams" colspan="2">template&lt;typename K , typename Func &gt; </td></tr>
<tr class="memitem:a4aba6537a931cd08f2664a10e09bdc29"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; bool, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_cuckoo_map.html#a4aba6537a931cd08f2664a10e09bdc29">update</a> (K const &amp;key, Func func, bool bAllowInsert=true)</td></tr>
<tr class="memdesc:a4aba6537a931cd08f2664a10e09bdc29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the node.  <a href="#a4aba6537a931cd08f2664a10e09bdc29">More...</a><br /></td></tr>
<tr class="separator:a4aba6537a931cd08f2664a10e09bdc29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a949108e97bfa54780ef4816ba0db2ef0"><td class="memTemplParams" colspan="2">template&lt;typename K &gt; </td></tr>
<tr class="memitem:a949108e97bfa54780ef4816ba0db2ef0"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_cuckoo_map.html#a949108e97bfa54780ef4816ba0db2ef0">erase</a> (K const &amp;key)</td></tr>
<tr class="memdesc:a949108e97bfa54780ef4816ba0db2ef0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete <code>key</code> from the map.  <a href="#a949108e97bfa54780ef4816ba0db2ef0">More...</a><br /></td></tr>
<tr class="separator:a949108e97bfa54780ef4816ba0db2ef0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a773b90f2861fd07a205b1d7113a2faee"><td class="memTemplParams" colspan="2">template&lt;typename K , typename Predicate &gt; </td></tr>
<tr class="memitem:a773b90f2861fd07a205b1d7113a2faee"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_cuckoo_map.html#a773b90f2861fd07a205b1d7113a2faee">erase_with</a> (K const &amp;key, Predicate pred)</td></tr>
<tr class="memdesc:a773b90f2861fd07a205b1d7113a2faee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the item from the list using <code>pred</code> predicate for searching.  <a href="#a773b90f2861fd07a205b1d7113a2faee">More...</a><br /></td></tr>
<tr class="separator:a773b90f2861fd07a205b1d7113a2faee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadddd9a1a41b940289a1f7efdf78fcae"><td class="memTemplParams" colspan="2">template&lt;typename K , typename Func &gt; </td></tr>
<tr class="memitem:aadddd9a1a41b940289a1f7efdf78fcae"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_cuckoo_map.html#aadddd9a1a41b940289a1f7efdf78fcae">erase</a> (K const &amp;key, Func f)</td></tr>
<tr class="memdesc:aadddd9a1a41b940289a1f7efdf78fcae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete <code>key</code> from the map.  <a href="#aadddd9a1a41b940289a1f7efdf78fcae">More...</a><br /></td></tr>
<tr class="separator:aadddd9a1a41b940289a1f7efdf78fcae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89acd3bfb03ea7705a91f05af79e0be9"><td class="memTemplParams" colspan="2">template&lt;typename K , typename Predicate , typename Func &gt; </td></tr>
<tr class="memitem:a89acd3bfb03ea7705a91f05af79e0be9"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_cuckoo_map.html#a89acd3bfb03ea7705a91f05af79e0be9">erase_with</a> (K const &amp;key, Predicate pred, Func f)</td></tr>
<tr class="memdesc:a89acd3bfb03ea7705a91f05af79e0be9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the item from the list using <code>pred</code> predicate for searching.  <a href="#a89acd3bfb03ea7705a91f05af79e0be9">More...</a><br /></td></tr>
<tr class="separator:a89acd3bfb03ea7705a91f05af79e0be9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49e55b628a859e446f9751046c8fa464"><td class="memTemplParams" colspan="2">template&lt;typename K , typename Func &gt; </td></tr>
<tr class="memitem:a49e55b628a859e446f9751046c8fa464"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_cuckoo_map.html#a49e55b628a859e446f9751046c8fa464">find</a> (K const &amp;key, Func f)</td></tr>
<tr class="memdesc:a49e55b628a859e446f9751046c8fa464"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the key <code>key</code>.  <a href="#a49e55b628a859e446f9751046c8fa464">More...</a><br /></td></tr>
<tr class="separator:a49e55b628a859e446f9751046c8fa464"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0944519780b201d3f0e265f73e47771"><td class="memTemplParams" colspan="2">template&lt;typename K , typename Predicate , typename Func &gt; </td></tr>
<tr class="memitem:ac0944519780b201d3f0e265f73e47771"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_cuckoo_map.html#ac0944519780b201d3f0e265f73e47771">find_with</a> (K const &amp;key, Predicate pred, Func f)</td></tr>
<tr class="memdesc:ac0944519780b201d3f0e265f73e47771"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the key <code>val</code> using <code>pred</code> predicate for comparing.  <a href="#ac0944519780b201d3f0e265f73e47771">More...</a><br /></td></tr>
<tr class="separator:ac0944519780b201d3f0e265f73e47771"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7585c9d40606e3e998633d76aebaeebd"><td class="memTemplParams" colspan="2">template&lt;typename K &gt; </td></tr>
<tr class="memitem:a7585c9d40606e3e998633d76aebaeebd"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_cuckoo_map.html#a7585c9d40606e3e998633d76aebaeebd">contains</a> (K const &amp;key)</td></tr>
<tr class="memdesc:a7585c9d40606e3e998633d76aebaeebd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the map contains <code>key</code>.  <a href="#a7585c9d40606e3e998633d76aebaeebd">More...</a><br /></td></tr>
<tr class="separator:a7585c9d40606e3e998633d76aebaeebd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dcd1949a45c4a9b284b6bee09dd5cd2"><td class="memTemplParams" colspan="2">template&lt;typename K , typename Predicate &gt; </td></tr>
<tr class="memitem:a2dcd1949a45c4a9b284b6bee09dd5cd2"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_cuckoo_map.html#a2dcd1949a45c4a9b284b6bee09dd5cd2">contains</a> (K const &amp;key, Predicate pred)</td></tr>
<tr class="memdesc:a2dcd1949a45c4a9b284b6bee09dd5cd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the map contains <code>key</code> using <code>pred</code> predicate for searching.  <a href="#a2dcd1949a45c4a9b284b6bee09dd5cd2">More...</a><br /></td></tr>
<tr class="separator:a2dcd1949a45c4a9b284b6bee09dd5cd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54eca2d1f3c7e56e0532d6ec969ca67e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a54eca2d1f3c7e56e0532d6ec969ca67e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_cuckoo_map.html#a54eca2d1f3c7e56e0532d6ec969ca67e">clear</a> ()</td></tr>
<tr class="memdesc:a54eca2d1f3c7e56e0532d6ec969ca67e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the map. <br /></td></tr>
<tr class="separator:a54eca2d1f3c7e56e0532d6ec969ca67e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13dd080b264b73565911c99c760116c2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_cuckoo_map.html#a13dd080b264b73565911c99c760116c2">empty</a> () const </td></tr>
<tr class="memdesc:a13dd080b264b73565911c99c760116c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the map is empty.  <a href="#a13dd080b264b73565911c99c760116c2">More...</a><br /></td></tr>
<tr class="separator:a13dd080b264b73565911c99c760116c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3a4887444dbbc370563a399442d6a64"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad3a4887444dbbc370563a399442d6a64"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_cuckoo_map.html#ad3a4887444dbbc370563a399442d6a64">size</a> () const </td></tr>
<tr class="memdesc:ad3a4887444dbbc370563a399442d6a64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns item count in the map. <br /></td></tr>
<tr class="separator:ad3a4887444dbbc370563a399442d6a64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53711b0378aab7e54012f772657c8637"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_cuckoo_map.html#a53711b0378aab7e54012f772657c8637">bucket_count</a> () const </td></tr>
<tr class="memdesc:a53711b0378aab7e54012f772657c8637"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of hash table.  <a href="#a53711b0378aab7e54012f772657c8637">More...</a><br /></td></tr>
<tr class="separator:a53711b0378aab7e54012f772657c8637"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f84095546cb5c807d5927286933a408"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_cuckoo_map.html#a7f84095546cb5c807d5927286933a408">lock_count</a> () const </td></tr>
<tr class="memdesc:a7f84095546cb5c807d5927286933a408"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns lock array size.  <a href="#a7f84095546cb5c807d5927286933a408">More...</a><br /></td></tr>
<tr class="separator:a7f84095546cb5c807d5927286933a408"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a224fc555e3673a0bf2bb6f528e36c6da"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a224fc555e3673a0bf2bb6f528e36c6da"></a>
<a class="el" href="classcds_1_1container_1_1_cuckoo_map.html#aee847170d3b27c1e04991cf696e2fbb1">stat</a> const &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_cuckoo_map.html#a224fc555e3673a0bf2bb6f528e36c6da">statistics</a> () const </td></tr>
<tr class="memdesc:a224fc555e3673a0bf2bb6f528e36c6da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns const reference to internal statistics. <br /></td></tr>
<tr class="separator:a224fc555e3673a0bf2bb6f528e36c6da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4392b6221664c16a5d357fd274f8cadd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4392b6221664c16a5d357fd274f8cadd"></a>
mutex_policy::statistics_type const &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_cuckoo_map.html#a4392b6221664c16a5d357fd274f8cadd">mutex_policy_statistics</a> () const </td></tr>
<tr class="memdesc:a4392b6221664c16a5d357fd274f8cadd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns const reference to mutex policy internal statistics. <br /></td></tr>
<tr class="separator:a4392b6221664c16a5d357fd274f8cadd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:ab2b0729de5896dc0e998ae4301747262"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab2b0729de5896dc0e998ae4301747262"></a>
static bool const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_cuckoo_map.html#ab2b0729de5896dc0e998ae4301747262">c_isSorted</a> = base_class::c_isSorted</td></tr>
<tr class="memdesc:ab2b0729de5896dc0e998ae4301747262"><td class="mdescLeft">&#160;</td><td class="mdescRight">whether the probe set should be ordered <br /></td></tr>
<tr class="separator:ab2b0729de5896dc0e998ae4301747262"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35537f20a82788a4fa973c9f894ba74c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a35537f20a82788a4fa973c9f894ba74c"></a>
static size_t const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_cuckoo_map.html#a35537f20a82788a4fa973c9f894ba74c">c_nArity</a> = base_class::c_nArity</td></tr>
<tr class="memdesc:a35537f20a82788a4fa973c9f894ba74c"><td class="mdescLeft">&#160;</td><td class="mdescRight">the arity of cuckoo hashing: the number of hash functors provided; minimum 2. <br /></td></tr>
<tr class="separator:a35537f20a82788a4fa973c9f894ba74c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f7cdc6c06a45355e7616eacd12a361b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3f7cdc6c06a45355e7616eacd12a361b"></a>
static unsigned int const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_cuckoo_map.html#a3f7cdc6c06a45355e7616eacd12a361b">c_nDefaultProbesetSize</a> = base_class::c_nDefaultProbesetSize</td></tr>
<tr class="memdesc:a3f7cdc6c06a45355e7616eacd12a361b"><td class="mdescLeft">&#160;</td><td class="mdescRight">default probeset size <br /></td></tr>
<tr class="separator:a3f7cdc6c06a45355e7616eacd12a361b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92aad97a2dd8a8cc65dd6015e95512b3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a92aad97a2dd8a8cc65dd6015e95512b3"></a>
static size_t const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_cuckoo_map.html#a92aad97a2dd8a8cc65dd6015e95512b3">c_nDefaultInitialSize</a> = base_class::c_nDefaultInitialSize</td></tr>
<tr class="memdesc:a92aad97a2dd8a8cc65dd6015e95512b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">default initial size <br /></td></tr>
<tr class="separator:a92aad97a2dd8a8cc65dd6015e95512b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2856c245ac428436491bec80a650fc4b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2856c245ac428436491bec80a650fc4b"></a>
static unsigned int const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_cuckoo_map.html#a2856c245ac428436491bec80a650fc4b">c_nRelocateLimit</a> = base_class::c_nRelocateLimit</td></tr>
<tr class="memdesc:a2856c245ac428436491bec80a650fc4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count of attempts to relocate before giving up. <br /></td></tr>
<tr class="separator:a2856c245ac428436491bec80a650fc4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_types_classcds_1_1intrusive_1_1_cuckoo_set"><td colspan="2" onclick="javascript:toggleInherit('pro_types_classcds_1_1intrusive_1_1_cuckoo_set')"><img src="closed.png" alt="-"/>&#160;Protected Types inherited from <a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html">cds::intrusive::CuckooSet&lt; std::pair&lt; Key const, T &gt;, Traits &gt;</a></td></tr>
<tr class="memitem:a80f3988a87de588e0a2d873592e6da40 inherit pro_types_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a80f3988a87de588e0a2d873592e6da40"></a>
typedef std::pair&lt; Key const, T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a80f3988a87de588e0a2d873592e6da40">value_type</a></td></tr>
<tr class="memdesc:a80f3988a87de588e0a2d873592e6da40 inherit pro_types_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">The value type stored in the set. <br /></td></tr>
<tr class="separator:a80f3988a87de588e0a2d873592e6da40 inherit pro_types_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a092995180143580f5c99ee285127c6c9 inherit pro_types_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a092995180143580f5c99ee285127c6c9"></a>
typedef Traits&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a092995180143580f5c99ee285127c6c9">traits</a></td></tr>
<tr class="memdesc:a092995180143580f5c99ee285127c6c9 inherit pro_types_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set traits. <br /></td></tr>
<tr class="separator:a092995180143580f5c99ee285127c6c9 inherit pro_types_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a282e600d3e6eec649b6237d6834ffc52 inherit pro_types_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a282e600d3e6eec649b6237d6834ffc52"></a>
typedef traits::hook&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a282e600d3e6eec649b6237d6834ffc52">hook</a></td></tr>
<tr class="memdesc:a282e600d3e6eec649b6237d6834ffc52 inherit pro_types_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">hook type <br /></td></tr>
<tr class="separator:a282e600d3e6eec649b6237d6834ffc52 inherit pro_types_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11d55d2a0fff222284b2d978b7a0985d inherit pro_types_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a11d55d2a0fff222284b2d978b7a0985d"></a>
typedef hook::node_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a11d55d2a0fff222284b2d978b7a0985d">node_type</a></td></tr>
<tr class="memdesc:a11d55d2a0fff222284b2d978b7a0985d inherit pro_types_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">node type <br /></td></tr>
<tr class="separator:a11d55d2a0fff222284b2d978b7a0985d inherit pro_types_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9af0e1eb823a6d2f1c557686c912c605 inherit pro_types_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9af0e1eb823a6d2f1c557686c912c605"></a>
typedef <a class="el" href="structcds_1_1intrusive_1_1get__node__traits.html">get_node_traits</a>&lt; <a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a80f3988a87de588e0a2d873592e6da40">value_type</a>, <a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a11d55d2a0fff222284b2d978b7a0985d">node_type</a>, <a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a282e600d3e6eec649b6237d6834ffc52">hook</a> &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a9af0e1eb823a6d2f1c557686c912c605">node_traits</a></td></tr>
<tr class="memdesc:a9af0e1eb823a6d2f1c557686c912c605 inherit pro_types_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">node traits <br /></td></tr>
<tr class="separator:a9af0e1eb823a6d2f1c557686c912c605 inherit pro_types_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb19f8057ca1bb84b31722b2d287c4f3 inherit pro_types_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aeb19f8057ca1bb84b31722b2d287c4f3"></a>
typedef traits::hash&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#aeb19f8057ca1bb84b31722b2d287c4f3">hash</a></td></tr>
<tr class="memdesc:aeb19f8057ca1bb84b31722b2d287c4f3 inherit pro_types_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">hash functor tuple wrapped for internal use <br /></td></tr>
<tr class="separator:aeb19f8057ca1bb84b31722b2d287c4f3 inherit pro_types_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a109563a562d2cc52f6819b272923dfa7 inherit pro_types_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a109563a562d2cc52f6819b272923dfa7"></a>
typedef hash::hash_tuple_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a109563a562d2cc52f6819b272923dfa7">hash_tuple_type</a></td></tr>
<tr class="memdesc:a109563a562d2cc52f6819b272923dfa7 inherit pro_types_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of hash tuple. <br /></td></tr>
<tr class="separator:a109563a562d2cc52f6819b272923dfa7 inherit pro_types_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44220cb2b6696715e2e902c07a13e330 inherit pro_types_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a44220cb2b6696715e2e902c07a13e330"></a>
typedef traits::stat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a44220cb2b6696715e2e902c07a13e330">stat</a></td></tr>
<tr class="memdesc:a44220cb2b6696715e2e902c07a13e330 inherit pro_types_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">internal statistics type <br /></td></tr>
<tr class="separator:a44220cb2b6696715e2e902c07a13e330 inherit pro_types_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f45ae046c619faae22f2f16f5ba6f6c inherit pro_types_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3f45ae046c619faae22f2f16f5ba6f6c"></a>
typedef traits::mutex_policy&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a3f45ae046c619faae22f2f16f5ba6f6c">original_mutex_policy</a></td></tr>
<tr class="memdesc:a3f45ae046c619faae22f2f16f5ba6f6c inherit pro_types_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concurrent access policy, see <code>cuckoo::traits::mutex_policy</code>. <br /></td></tr>
<tr class="separator:a3f45ae046c619faae22f2f16f5ba6f6c inherit pro_types_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68699b6f6b7957c4f604e4677c9655db inherit pro_types_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memItemLeft" align="right" valign="top">typedef original_mutex_policy::template rebind_statistics&lt; typename std::conditional&lt; std::is_same&lt; <a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a44220cb2b6696715e2e902c07a13e330">stat</a>, <a class="el" href="structcds_1_1intrusive_1_1cuckoo_1_1empty__stat.html">cuckoo::empty_stat</a> &gt;::value, typename original_mutex_policy::empty_stat, typename original_mutex_policy::real_stat &gt;::type &gt;::other&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a68699b6f6b7957c4f604e4677c9655db">mutex_policy</a></td></tr>
<tr class="memdesc:a68699b6f6b7957c4f604e4677c9655db inherit pro_types_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Actual mutex policy.  <a href="#a68699b6f6b7957c4f604e4677c9655db">More...</a><br /></td></tr>
<tr class="separator:a68699b6f6b7957c4f604e4677c9655db inherit pro_types_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef7de3b1f961e712b85e967df7e762b4 inherit pro_types_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aef7de3b1f961e712b85e967df7e762b4"></a>
typedef opt::details::make_equal_to&lt; <a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a80f3988a87de588e0a2d873592e6da40">value_type</a>, <a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a092995180143580f5c99ee285127c6c9">traits</a>,!<a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#aec91125eaafeba9da642a4ec74fd7c0f">c_isSorted</a> &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#aef7de3b1f961e712b85e967df7e762b4">key_equal_to</a></td></tr>
<tr class="memdesc:aef7de3b1f961e712b85e967df7e762b4 inherit pro_types_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Key equality functor; used only for unordered probe-set. <br /></td></tr>
<tr class="separator:aef7de3b1f961e712b85e967df7e762b4 inherit pro_types_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c6cc0f5f964eaef3a8559c2e0377263 inherit pro_types_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8c6cc0f5f964eaef3a8559c2e0377263"></a>
typedef opt::details::make_comparator&lt; <a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a80f3988a87de588e0a2d873592e6da40">value_type</a>, <a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a092995180143580f5c99ee285127c6c9">traits</a> &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a8c6cc0f5f964eaef3a8559c2e0377263">key_comparator</a></td></tr>
<tr class="memdesc:a8c6cc0f5f964eaef3a8559c2e0377263 inherit pro_types_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">key comparing functor based on opt::compare and opt::less option setter. Used only for ordered probe set <br /></td></tr>
<tr class="separator:a8c6cc0f5f964eaef3a8559c2e0377263 inherit pro_types_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c29caeacd9eab62a8295cb776f65ca7 inherit pro_types_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1c29caeacd9eab62a8295cb776f65ca7"></a>
typedef traits::allocator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a1c29caeacd9eab62a8295cb776f65ca7">allocator</a></td></tr>
<tr class="memdesc:a1c29caeacd9eab62a8295cb776f65ca7 inherit pro_types_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">allocator type <br /></td></tr>
<tr class="separator:a1c29caeacd9eab62a8295cb776f65ca7 inherit pro_types_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4384afbdc9b2688c6175aafd3bbb85a9 inherit pro_types_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4384afbdc9b2688c6175aafd3bbb85a9"></a>
typedef traits::item_counter&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a4384afbdc9b2688c6175aafd3bbb85a9">item_counter</a></td></tr>
<tr class="memdesc:a4384afbdc9b2688c6175aafd3bbb85a9 inherit pro_types_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">item counter type <br /></td></tr>
<tr class="separator:a4384afbdc9b2688c6175aafd3bbb85a9 inherit pro_types_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93619c3ddbc8fc96a0b6481de8e03126 inherit pro_types_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a93619c3ddbc8fc96a0b6481de8e03126"></a>
typedef traits::disposer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a93619c3ddbc8fc96a0b6481de8e03126">disposer</a></td></tr>
<tr class="memdesc:a93619c3ddbc8fc96a0b6481de8e03126 inherit pro_types_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">node disposer <br /></td></tr>
<tr class="separator:a93619c3ddbc8fc96a0b6481de8e03126 inherit pro_types_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classcds_1_1intrusive_1_1_cuckoo_set')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html">cds::intrusive::CuckooSet&lt; std::pair&lt; Key const, T &gt;, Traits &gt;</a></td></tr>
<tr class="memitem:a3e221ce6294ce2a9bd4ad4e6fe06b367 inherit pro_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a3e221ce6294ce2a9bd4ad4e6fe06b367">CuckooSet</a> ()</td></tr>
<tr class="memdesc:a3e221ce6294ce2a9bd4ad4e6fe06b367 inherit pro_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="#a3e221ce6294ce2a9bd4ad4e6fe06b367">More...</a><br /></td></tr>
<tr class="separator:a3e221ce6294ce2a9bd4ad4e6fe06b367 inherit pro_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac18f71b08de102c3ca85b9bc53963b38 inherit pro_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#ac18f71b08de102c3ca85b9bc53963b38">CuckooSet</a> (size_t nInitialSize, unsigned int nProbesetSize, unsigned int nProbesetThreshold=0)</td></tr>
<tr class="memdesc:ac18f71b08de102c3ca85b9bc53963b38 inherit pro_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the set object with given probe set size and threshold.  <a href="#ac18f71b08de102c3ca85b9bc53963b38">More...</a><br /></td></tr>
<tr class="separator:ac18f71b08de102c3ca85b9bc53963b38 inherit pro_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cec0e76f68e4d0462420d577c728c76 inherit pro_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a2cec0e76f68e4d0462420d577c728c76">CuckooSet</a> (<a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a109563a562d2cc52f6819b272923dfa7">hash_tuple_type</a> const &amp;h)</td></tr>
<tr class="memdesc:a2cec0e76f68e4d0462420d577c728c76 inherit pro_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the set object with given hash functor tuple.  <a href="#a2cec0e76f68e4d0462420d577c728c76">More...</a><br /></td></tr>
<tr class="separator:a2cec0e76f68e4d0462420d577c728c76 inherit pro_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a028ecfbae605b0199e0b0b2d15fd3d73 inherit pro_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a028ecfbae605b0199e0b0b2d15fd3d73">CuckooSet</a> (size_t nInitialSize, unsigned int nProbesetSize, unsigned int nProbesetThreshold, <a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a109563a562d2cc52f6819b272923dfa7">hash_tuple_type</a> const &amp;h)</td></tr>
<tr class="memdesc:a028ecfbae605b0199e0b0b2d15fd3d73 inherit pro_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the set object with given probe set properties and hash functor tuple.  <a href="#a028ecfbae605b0199e0b0b2d15fd3d73">More...</a><br /></td></tr>
<tr class="separator:a028ecfbae605b0199e0b0b2d15fd3d73 inherit pro_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95f68f38da3654e56754e08c94f66d2e inherit pro_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a95f68f38da3654e56754e08c94f66d2e">CuckooSet</a> (<a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a109563a562d2cc52f6819b272923dfa7">hash_tuple_type</a> &amp;&amp;h)</td></tr>
<tr class="memdesc:a95f68f38da3654e56754e08c94f66d2e inherit pro_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the set object with given hash functor tuple (move semantics)  <a href="#a95f68f38da3654e56754e08c94f66d2e">More...</a><br /></td></tr>
<tr class="separator:a95f68f38da3654e56754e08c94f66d2e inherit pro_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aede715e446da90de4e51b19d64236da3 inherit pro_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#aede715e446da90de4e51b19d64236da3">CuckooSet</a> (size_t nInitialSize, unsigned int nProbesetSize, unsigned int nProbesetThreshold, <a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a109563a562d2cc52f6819b272923dfa7">hash_tuple_type</a> &amp;&amp;h)</td></tr>
<tr class="memdesc:aede715e446da90de4e51b19d64236da3 inherit pro_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the set object with given probe set properties and hash functor tuple (move semantics)  <a href="#aede715e446da90de4e51b19d64236da3">More...</a><br /></td></tr>
<tr class="separator:aede715e446da90de4e51b19d64236da3 inherit pro_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a545595f7caba3bdd3520e16115a7fa2b inherit pro_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a545595f7caba3bdd3520e16115a7fa2b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a545595f7caba3bdd3520e16115a7fa2b">~CuckooSet</a> ()</td></tr>
<tr class="memdesc:a545595f7caba3bdd3520e16115a7fa2b inherit pro_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br /></td></tr>
<tr class="separator:a545595f7caba3bdd3520e16115a7fa2b inherit pro_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75199d012de6ab7c3315dda78b4b3025 inherit pro_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a75199d012de6ab7c3315dda78b4b3025">insert</a> (<a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a80f3988a87de588e0a2d873592e6da40">value_type</a> &amp;val)</td></tr>
<tr class="memdesc:a75199d012de6ab7c3315dda78b4b3025 inherit pro_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new node.  <a href="#a75199d012de6ab7c3315dda78b4b3025">More...</a><br /></td></tr>
<tr class="separator:a75199d012de6ab7c3315dda78b4b3025 inherit pro_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a103ae7f5ebd72ac7fe2a1cc751f937bd inherit pro_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a103ae7f5ebd72ac7fe2a1cc751f937bd">insert</a> (<a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a80f3988a87de588e0a2d873592e6da40">value_type</a> &amp;val, Func f)</td></tr>
<tr class="memdesc:a103ae7f5ebd72ac7fe2a1cc751f937bd inherit pro_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new node.  <a href="#a103ae7f5ebd72ac7fe2a1cc751f937bd">More...</a><br /></td></tr>
<tr class="separator:a103ae7f5ebd72ac7fe2a1cc751f937bd inherit pro_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1341ac3ce1c85b0f84c041132d42ec1a inherit pro_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memItemLeft" align="right" valign="top">std::pair&lt; bool, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a1341ac3ce1c85b0f84c041132d42ec1a">update</a> (<a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a80f3988a87de588e0a2d873592e6da40">value_type</a> &amp;val, Func func, bool bAllowInsert=true)</td></tr>
<tr class="memdesc:a1341ac3ce1c85b0f84c041132d42ec1a inherit pro_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the node.  <a href="#a1341ac3ce1c85b0f84c041132d42ec1a">More...</a><br /></td></tr>
<tr class="separator:a1341ac3ce1c85b0f84c041132d42ec1a inherit pro_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44c2d0ae24a2a32edc066a96e003e9bb inherit pro_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a44c2d0ae24a2a32edc066a96e003e9bb">unlink</a> (<a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a80f3988a87de588e0a2d873592e6da40">value_type</a> &amp;val)</td></tr>
<tr class="memdesc:a44c2d0ae24a2a32edc066a96e003e9bb inherit pro_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlink the item <code>val</code> from the set.  <a href="#a44c2d0ae24a2a32edc066a96e003e9bb">More...</a><br /></td></tr>
<tr class="separator:a44c2d0ae24a2a32edc066a96e003e9bb inherit pro_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b4514beb5a17fa560faca26c3134e38 inherit pro_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a80f3988a87de588e0a2d873592e6da40">value_type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a9b4514beb5a17fa560faca26c3134e38">erase</a> (Q const &amp;val)</td></tr>
<tr class="memdesc:a9b4514beb5a17fa560faca26c3134e38 inherit pro_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the item from the set.  <a href="#a9b4514beb5a17fa560faca26c3134e38">More...</a><br /></td></tr>
<tr class="separator:a9b4514beb5a17fa560faca26c3134e38 inherit pro_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7036d8b2985726d5cb138c879d016a44 inherit pro_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a80f3988a87de588e0a2d873592e6da40">value_type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a7036d8b2985726d5cb138c879d016a44">erase</a> (Q const &amp;val, Func f)</td></tr>
<tr class="memdesc:a7036d8b2985726d5cb138c879d016a44 inherit pro_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete the item from the set.  <a href="#a7036d8b2985726d5cb138c879d016a44">More...</a><br /></td></tr>
<tr class="separator:a7036d8b2985726d5cb138c879d016a44 inherit pro_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a664d70addf3f701f1a62013c69355790 inherit pro_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a80f3988a87de588e0a2d873592e6da40">value_type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a664d70addf3f701f1a62013c69355790">erase_with</a> (Q const &amp;val, Predicate pred)</td></tr>
<tr class="memdesc:a664d70addf3f701f1a62013c69355790 inherit pro_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the item from the set using <code>pred</code> predicate for searching.  <a href="#a664d70addf3f701f1a62013c69355790">More...</a><br /></td></tr>
<tr class="separator:a664d70addf3f701f1a62013c69355790 inherit pro_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a213ba3e87c26e5a1afcc84e7cea477ad inherit pro_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a80f3988a87de588e0a2d873592e6da40">value_type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a213ba3e87c26e5a1afcc84e7cea477ad">erase_with</a> (Q const &amp;val, Predicate pred, Func f)</td></tr>
<tr class="memdesc:a213ba3e87c26e5a1afcc84e7cea477ad inherit pro_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the item from the set using <code>pred</code> predicate for searching.  <a href="#a213ba3e87c26e5a1afcc84e7cea477ad">More...</a><br /></td></tr>
<tr class="separator:a213ba3e87c26e5a1afcc84e7cea477ad inherit pro_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a578457cdff461f79ba9e57515d851b71 inherit pro_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a578457cdff461f79ba9e57515d851b71">find</a> (Q &amp;val, Func f)</td></tr>
<tr class="memdesc:a578457cdff461f79ba9e57515d851b71 inherit pro_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the key <code>val</code>.  <a href="#a578457cdff461f79ba9e57515d851b71">More...</a><br /></td></tr>
<tr class="separator:a578457cdff461f79ba9e57515d851b71 inherit pro_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a783b11c482e9e855ec9d207262aefd75 inherit pro_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a783b11c482e9e855ec9d207262aefd75">find_with</a> (Q &amp;val, Predicate pred, Func f)</td></tr>
<tr class="memdesc:a783b11c482e9e855ec9d207262aefd75 inherit pro_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the key <code>val</code> using <code>pred</code> predicate for comparing.  <a href="#a783b11c482e9e855ec9d207262aefd75">More...</a><br /></td></tr>
<tr class="separator:a783b11c482e9e855ec9d207262aefd75 inherit pro_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a753b31e6fa9114cd1d95471ee057b6a2 inherit pro_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a753b31e6fa9114cd1d95471ee057b6a2">contains</a> (Q const &amp;key)</td></tr>
<tr class="memdesc:a753b31e6fa9114cd1d95471ee057b6a2 inherit pro_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the set contains <code>key</code>.  <a href="#a753b31e6fa9114cd1d95471ee057b6a2">More...</a><br /></td></tr>
<tr class="separator:a753b31e6fa9114cd1d95471ee057b6a2 inherit pro_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10d7acb708e5cfc7488b2d5fb584e6f9 inherit pro_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a10d7acb708e5cfc7488b2d5fb584e6f9">contains</a> (Q const &amp;key, Predicate pred)</td></tr>
<tr class="memdesc:a10d7acb708e5cfc7488b2d5fb584e6f9 inherit pro_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the set contains <code>key</code> using <code>pred</code> predicate for searching.  <a href="#a10d7acb708e5cfc7488b2d5fb584e6f9">More...</a><br /></td></tr>
<tr class="separator:a10d7acb708e5cfc7488b2d5fb584e6f9 inherit pro_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc138e7fd59de4e6a8e0ce6fc13b3f20 inherit pro_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#adc138e7fd59de4e6a8e0ce6fc13b3f20">clear</a> ()</td></tr>
<tr class="memdesc:adc138e7fd59de4e6a8e0ce6fc13b3f20 inherit pro_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the set.  <a href="#adc138e7fd59de4e6a8e0ce6fc13b3f20">More...</a><br /></td></tr>
<tr class="separator:adc138e7fd59de4e6a8e0ce6fc13b3f20 inherit pro_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23148d079b580ccc0a9141094b9534ee inherit pro_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a23148d079b580ccc0a9141094b9534ee">clear_and_dispose</a> (Disposer oDisposer)</td></tr>
<tr class="memdesc:a23148d079b580ccc0a9141094b9534ee inherit pro_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the set and calls <code>disposer</code> for each item.  <a href="#a23148d079b580ccc0a9141094b9534ee">More...</a><br /></td></tr>
<tr class="separator:a23148d079b580ccc0a9141094b9534ee inherit pro_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65734637d991285764dd94c663afab69 inherit pro_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a65734637d991285764dd94c663afab69">empty</a> () const</td></tr>
<tr class="memdesc:a65734637d991285764dd94c663afab69 inherit pro_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the set is empty.  <a href="#a65734637d991285764dd94c663afab69">More...</a><br /></td></tr>
<tr class="separator:a65734637d991285764dd94c663afab69 inherit pro_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad77539c94df2fa452b5d15617c0b3cb2 inherit pro_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad77539c94df2fa452b5d15617c0b3cb2"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#ad77539c94df2fa452b5d15617c0b3cb2">size</a> () const</td></tr>
<tr class="memdesc:ad77539c94df2fa452b5d15617c0b3cb2 inherit pro_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns item count in the set. <br /></td></tr>
<tr class="separator:ad77539c94df2fa452b5d15617c0b3cb2 inherit pro_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ace0cf32a214311fb09204c86b0d2ff inherit pro_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a9ace0cf32a214311fb09204c86b0d2ff">bucket_count</a> () const</td></tr>
<tr class="memdesc:a9ace0cf32a214311fb09204c86b0d2ff inherit pro_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of hash table.  <a href="#a9ace0cf32a214311fb09204c86b0d2ff">More...</a><br /></td></tr>
<tr class="separator:a9ace0cf32a214311fb09204c86b0d2ff inherit pro_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28e8654c925669bf34f15bdb77dec065 inherit pro_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a28e8654c925669bf34f15bdb77dec065"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a28e8654c925669bf34f15bdb77dec065">lock_count</a> () const</td></tr>
<tr class="memdesc:a28e8654c925669bf34f15bdb77dec065 inherit pro_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns lock array size. <br /></td></tr>
<tr class="separator:a28e8654c925669bf34f15bdb77dec065 inherit pro_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bd9a9d0b05db9bbcd090b51e3e866af inherit pro_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9bd9a9d0b05db9bbcd090b51e3e866af"></a>
<a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a44220cb2b6696715e2e902c07a13e330">stat</a> const &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a9bd9a9d0b05db9bbcd090b51e3e866af">statistics</a> () const</td></tr>
<tr class="memdesc:a9bd9a9d0b05db9bbcd090b51e3e866af inherit pro_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns const reference to internal statistics. <br /></td></tr>
<tr class="separator:a9bd9a9d0b05db9bbcd090b51e3e866af inherit pro_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4107eae58541683b5abc0c337d010c9 inherit pro_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af4107eae58541683b5abc0c337d010c9"></a>
mutex_policy::statistics_type const &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#af4107eae58541683b5abc0c337d010c9">mutex_policy_statistics</a> () const</td></tr>
<tr class="memdesc:af4107eae58541683b5abc0c337d010c9 inherit pro_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns const reference to mutex policy internal statistics. <br /></td></tr>
<tr class="separator:af4107eae58541683b5abc0c337d010c9 inherit pro_methods_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_classcds_1_1intrusive_1_1_cuckoo_set"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classcds_1_1intrusive_1_1_cuckoo_set')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html">cds::intrusive::CuckooSet&lt; std::pair&lt; Key const, T &gt;, Traits &gt;</a></td></tr>
<tr class="memitem:a904af372de54c256d49de92ba849814d inherit pro_attribs_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a904af372de54c256d49de92ba849814d"></a>
bucket_entry *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a904af372de54c256d49de92ba849814d">m_BucketTable</a> [<a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#af57c3ed1e36757238a5396a667eeb06f">c_nArity</a>]</td></tr>
<tr class="memdesc:a904af372de54c256d49de92ba849814d inherit pro_attribs_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bucket tables. <br /></td></tr>
<tr class="separator:a904af372de54c256d49de92ba849814d inherit pro_attribs_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95953e1a8377d8f436aa1b4bd9e4e6fe inherit pro_attribs_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a95953e1a8377d8f436aa1b4bd9e4e6fe"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a95953e1a8377d8f436aa1b4bd9e4e6fe">m_nBucketMask</a></td></tr>
<tr class="memdesc:a95953e1a8377d8f436aa1b4bd9e4e6fe inherit pro_attribs_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hash bitmask; bucket table size minus 1. <br /></td></tr>
<tr class="separator:a95953e1a8377d8f436aa1b4bd9e4e6fe inherit pro_attribs_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96855242b5e8df7673689fce275e6410 inherit pro_attribs_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a96855242b5e8df7673689fce275e6410"></a>
unsigned int const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a96855242b5e8df7673689fce275e6410">m_nProbesetSize</a></td></tr>
<tr class="memdesc:a96855242b5e8df7673689fce275e6410 inherit pro_attribs_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Probe set size. <br /></td></tr>
<tr class="separator:a96855242b5e8df7673689fce275e6410 inherit pro_attribs_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80a50b187e648a3855129792ba90ed05 inherit pro_attribs_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a80a50b187e648a3855129792ba90ed05"></a>
unsigned int const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a80a50b187e648a3855129792ba90ed05">m_nProbesetThreshold</a></td></tr>
<tr class="memdesc:a80a50b187e648a3855129792ba90ed05 inherit pro_attribs_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Probe set threshold. <br /></td></tr>
<tr class="separator:a80a50b187e648a3855129792ba90ed05 inherit pro_attribs_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c17058bb63f1b7b32e174642b2d0a31 inherit pro_attribs_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6c17058bb63f1b7b32e174642b2d0a31"></a>
<a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#aeb19f8057ca1bb84b31722b2d287c4f3">hash</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a6c17058bb63f1b7b32e174642b2d0a31">m_Hash</a></td></tr>
<tr class="memdesc:a6c17058bb63f1b7b32e174642b2d0a31 inherit pro_attribs_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hash functor tuple. <br /></td></tr>
<tr class="separator:a6c17058bb63f1b7b32e174642b2d0a31 inherit pro_attribs_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3b55f3a0eb6ad233feee8b9917abaa4 inherit pro_attribs_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa3b55f3a0eb6ad233feee8b9917abaa4"></a>
<a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a68699b6f6b7957c4f604e4677c9655db">mutex_policy</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#aa3b55f3a0eb6ad233feee8b9917abaa4">m_MutexPolicy</a></td></tr>
<tr class="memdesc:aa3b55f3a0eb6ad233feee8b9917abaa4 inherit pro_attribs_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">concurrent access policy <br /></td></tr>
<tr class="separator:aa3b55f3a0eb6ad233feee8b9917abaa4 inherit pro_attribs_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a84f7b7af5ed6cb9f18ff528d41aae2 inherit pro_attribs_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8a84f7b7af5ed6cb9f18ff528d41aae2"></a>
<a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a4384afbdc9b2688c6175aafd3bbb85a9">item_counter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a8a84f7b7af5ed6cb9f18ff528d41aae2">m_ItemCounter</a></td></tr>
<tr class="memdesc:a8a84f7b7af5ed6cb9f18ff528d41aae2 inherit pro_attribs_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">item counter <br /></td></tr>
<tr class="separator:a8a84f7b7af5ed6cb9f18ff528d41aae2 inherit pro_attribs_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac364bc421fc0fe5cce1ed31d99faa74a inherit pro_attribs_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac364bc421fc0fe5cce1ed31d99faa74a"></a>
<a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a44220cb2b6696715e2e902c07a13e330">stat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#ac364bc421fc0fe5cce1ed31d99faa74a">m_Stat</a></td></tr>
<tr class="memdesc:ac364bc421fc0fe5cce1ed31d99faa74a inherit pro_attribs_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">internal statistics <br /></td></tr>
<tr class="separator:ac364bc421fc0fe5cce1ed31d99faa74a inherit pro_attribs_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_static_attribs_classcds_1_1intrusive_1_1_cuckoo_set"><td colspan="2" onclick="javascript:toggleInherit('pro_static_attribs_classcds_1_1intrusive_1_1_cuckoo_set')"><img src="closed.png" alt="-"/>&#160;Static Protected Attributes inherited from <a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html">cds::intrusive::CuckooSet&lt; std::pair&lt; Key const, T &gt;, Traits &gt;</a></td></tr>
<tr class="memitem:aec91125eaafeba9da642a4ec74fd7c0f inherit pro_static_attribs_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aec91125eaafeba9da642a4ec74fd7c0f"></a>
static bool const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#aec91125eaafeba9da642a4ec74fd7c0f">c_isSorted</a></td></tr>
<tr class="memdesc:aec91125eaafeba9da642a4ec74fd7c0f inherit pro_static_attribs_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">whether the probe set should be ordered <br /></td></tr>
<tr class="separator:aec91125eaafeba9da642a4ec74fd7c0f inherit pro_static_attribs_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af57c3ed1e36757238a5396a667eeb06f inherit pro_static_attribs_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af57c3ed1e36757238a5396a667eeb06f"></a>
static size_t const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#af57c3ed1e36757238a5396a667eeb06f">c_nArity</a></td></tr>
<tr class="memdesc:af57c3ed1e36757238a5396a667eeb06f inherit pro_static_attribs_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">the arity of cuckoo hashing: the number of hash functors provided; minimum 2. <br /></td></tr>
<tr class="separator:af57c3ed1e36757238a5396a667eeb06f inherit pro_static_attribs_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7428e959608e5decac221dc317e8da8 inherit pro_static_attribs_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa7428e959608e5decac221dc317e8da8"></a>
static unsigned int const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#aa7428e959608e5decac221dc317e8da8">c_nDefaultProbesetSize</a></td></tr>
<tr class="memdesc:aa7428e959608e5decac221dc317e8da8 inherit pro_static_attribs_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">default probeset size <br /></td></tr>
<tr class="separator:aa7428e959608e5decac221dc317e8da8 inherit pro_static_attribs_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49f3b066d9b88fd5ec69263a5783ac17 inherit pro_static_attribs_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a49f3b066d9b88fd5ec69263a5783ac17"></a>
static size_t const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a49f3b066d9b88fd5ec69263a5783ac17">c_nDefaultInitialSize</a></td></tr>
<tr class="memdesc:a49f3b066d9b88fd5ec69263a5783ac17 inherit pro_static_attribs_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">default initial size <br /></td></tr>
<tr class="separator:a49f3b066d9b88fd5ec69263a5783ac17 inherit pro_static_attribs_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aceb27b2754ff51b10ee5e7754aafec36 inherit pro_static_attribs_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aceb27b2754ff51b10ee5e7754aafec36"></a>
static unsigned int const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#aceb27b2754ff51b10ee5e7754aafec36">c_nRelocateLimit</a></td></tr>
<tr class="memdesc:aceb27b2754ff51b10ee5e7754aafec36 inherit pro_static_attribs_classcds_1_1intrusive_1_1_cuckoo_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count of attempts to relocate before giving up. <br /></td></tr>
<tr class="separator:aceb27b2754ff51b10ee5e7754aafec36 inherit pro_static_attribs_classcds_1_1intrusive_1_1_cuckoo_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename Key, typename T, typename Traits = cuckoo::traits&gt;<br />
class cds::container::CuckooMap&lt; Key, T, Traits &gt;</h3>

<p>Cuckoo hash map. </p>
<p>Source</p><ul>
<li>[2007] M.Herlihy, N.Shavit, M.Tzafrir "Concurrent Cuckoo Hashing. Technical report"</li>
<li>[2008] Maurice Herlihy, Nir Shavit "The Art of Multiprocessor Programming"</li>
</ul>
<p><b>About Cuckoo hashing</b></p>
<p>[From "The Art of Multiprocessor Programming"] Cuckoo hashing is a hashing algorithm in which a newly added item displaces any earlier item occupying the same slot. For brevity, a table is a k-entry array of items. For a hash set f size N = 2k we use a two-entry array of tables, and two independent hash functions, <code> h0, h1: KeyRange -&gt; 0,...,k-1</code> mapping the set of possible keys to entries in he array. To test whether a value <code>x</code> is in the set, <code>find(x)</code> tests whether either <code>table[0][h0(x)]</code> or <code>table[1][h1(x)]</code> is equal to <code>x</code>. Similarly, <code>erase(x)</code>checks whether <code>x</code> is in either <code>table[0][h0(x)]</code> or <code>table[1][h1(x)]</code>, ad removes it if found.</p>
<p>The <code>insert(x)</code> successively "kicks out" conflicting items until every key has a slot. To add <code>x</code>, the method swaps <code>x</code> with <code>y</code>, the current occupant of <code>table[0][h0(x)]</code>. If the prior value was <code>nullptr</code>, it is done. Otherwise, it swaps the newly nest-less value <code>y</code> for the current occupant of <code>table[1][h1(y)]</code> in the same way. As before, if the prior value was <code>nullptr</code>, it is done. Otherwise, the method continues swapping entries (alternating tables) until it finds an empty slot. We might not find an empty slot, either because the table is full, or because the sequence of displacement forms a cycle. We therefore need an upper limit on the number of successive displacements we are willing to undertake. When this limit is exceeded, we resize the hash table, choose new hash functions and start over.</p>
<p>For concurrent cuckoo hashing, rather than organizing the set as a two-dimensional table of items, we use two-dimensional table of probe sets, where a probe set is a constant-sized set of items with the same hash code. Each probe set holds at most <code>PROBE_SIZE</code> items, but the algorithm tries to ensure that when the set is quiescent (i.e no method call in progress) each probe set holds no more than <code>THRESHOLD &lt; PROBE_SET</code> items. While method calls are in-flight, a probe set may temporarily hold more than <code>THRESHOLD</code> but never more than <code>PROBE_SET</code> items.</p>
<p>In current implementation, a probe set can be defined either as a (single-linked) list or as a fixed-sized vector, optionally ordered.</p>
<p>In description above two-table cuckoo hashing (<code>k = 2</code>) has been considered. We can generalize this approach for <code>k &gt;= 2</code> when we have <code>k</code> hash functions <code>h[0], ... h[k-1]</code> and <code>k</code> tables <code>table[0], ... table[k-1]</code>.</p>
<p>The search in probe set is linear, the complexity is <code> O(PROBE_SET) </code>. The probe set may be ordered or not. Ordered probe set can be a little better since the average search complexity is <code>O(PROBE_SET/2)</code>. However, the overhead of sorting can eliminate a gain of ordered search.</p>
<p>The probe set is ordered if <a class="el" href="structcds_1_1opt_1_1compare.html" title="[type-option] Option setter for key comparing ">opt::compare</a> or <a class="el" href="structcds_1_1opt_1_1less.html" title="[type-option] Option setter for less predicate ">opt::less</a> is specified in <code>CuckooSet</code> declaration. Otherwise, the probe set is unordered and <code>CuckooSet</code> must contain <a class="el" href="structcds_1_1opt_1_1equal__to.html" title="[type-option] Option setter for opt::equal_to predicate ">opt::equal_to</a> option.</p>
<p>Template arguments:</p><ul>
<li><code>Key</code> - key type</li>
<li><code>T</code> - the type stored in the map.</li>
<li><code>Traits</code> - map traits., default is <code><a class="el" href="structcds_1_1container_1_1cuckoo_1_1traits.html" title="Type traits for CuckooSet and CuckooMap classes. ">cuckoo::traits</a></code>. It is possible to declare option-based set with <code><a class="el" href="structcds_1_1container_1_1cuckoo_1_1make__traits.html" title="Metafunction converting option list to CuckooSet/CuckooMap traits. ">cuckoo::make_traits</a></code> metafunction result as <code>Traits</code> template argument.</li>
</ul>
<p><b>Examples</b></p>
<p>Declares cuckoo mapping from <code>std::string</code> to struct <code>foo</code>. For cuckoo hashing we should provide at least two hash functions: </p><div class="fragment"><div class="line"><span class="keyword">struct </span>hash1 {</div>
<div class="line">    <span class="keywordtype">size_t</span> operator()(std::string <span class="keyword">const</span>&amp; s)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">    </span>{</div>
<div class="line">        <span class="keywordflow">return</span> cds::opt::v::hash&lt;std::string&gt;( s );</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keyword">struct </span>hash2: <span class="keyword">private</span> hash1 {</div>
<div class="line">    <span class="keywordtype">size_t</span> operator()(std::string <span class="keyword">const</span>&amp; s)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">    </span>{</div>
<div class="line">        <span class="keywordtype">size_t</span> h = ~( hash1::operator()(s));</div>
<div class="line">        <span class="keywordflow">return</span> ~h + 0x9e3779b9 + (h &lt;&lt; 6) + (h &gt;&gt; 2);</div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><p>Cuckoo-map with list-based unordered probe set and storing hash values </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;cds/container/cuckoo_map.h&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Declare type traits</span></div>
<div class="line"><span class="keyword">struct </span>my_traits: <span class="keyword">public</span> <a class="code" href="structcds_1_1container_1_1cuckoo_1_1traits.html">cds::container::cuckoo::traits</a></div>
<div class="line">{</div>
<div class="line">    <span class="keyword">typedef</span> std::equal_to&lt; std::string &gt; equal_to;</div>
<div class="line">    <span class="keyword">typedef</span> std::tuple&lt; hash1, hash2 &gt;  <a class="code" href="classcds_1_1container_1_1_cuckoo_map.html#a40094438568aee8e8bf456585ff0c15d">hash</a>;</div>
<div class="line"></div>
<div class="line">    <span class="keyword">static</span> <span class="keywordtype">bool</span> <span class="keyword">const</span> store_hash = <span class="keyword">true</span>;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="comment">// Declare CuckooMap type</span></div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="classcds_1_1container_1_1_cuckoo_map.html">cds::container::CuckooMap&lt; std::string, foo, my_traits &gt;</a> my_cuckoo_map;</div>
<div class="line"></div>
<div class="line"><span class="comment">// Equal option-based declaration</span></div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="classcds_1_1container_1_1_cuckoo_map.html">cds::container::CuckooMap</a>&lt; std::string, foo,</div>
<div class="line">    <a class="code" href="structcds_1_1container_1_1cuckoo_1_1make__traits.html">cds::container::cuckoo::make_traits</a>&lt;</div>
<div class="line">        <a class="code" href="structcds_1_1opt_1_1hash.html">cds::opt::hash&lt; std::tuple&lt; hash1, hash2 &gt;</a> &gt;</div>
<div class="line">        ,<a class="code" href="structcds_1_1opt_1_1equal__to.html">cds::opt::equal_to&lt; std::equal_to&lt; std::string &gt;</a> &gt;</div>
<div class="line">        ,<a class="code" href="structcds_1_1container_1_1cuckoo_1_1store__hash.html">cds::container::cuckoo::store_hash&lt; true &gt;</a></div>
<div class="line">    &gt;::type</div>
<div class="line">&gt; opt_cuckoo_map;</div>
</div><!-- fragment --><p>If we provide <code>less</code> functor instead of <code>equal_to</code> we get as a result a cuckoo map with ordered probe set that may improve performance. Example for ordered vector-based probe-set:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;cds/container/cuckoo_map.h&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Declare type traits</span></div>
<div class="line"><span class="comment">// We use a vector of capacity 4 as probe-set container and store hash values in the node</span></div>
<div class="line"><span class="keyword">struct </span>my_traits: <span class="keyword">public</span> <a class="code" href="structcds_1_1container_1_1cuckoo_1_1traits.html">cds::container::cuckoo::traits</a></div>
<div class="line">{</div>
<div class="line">    <span class="keyword">typedef</span> std::less&lt; std::string &gt; less;</div>
<div class="line">    <span class="keyword">typedef</span> std::tuple&lt; hash1, hash2 &gt;  <a class="code" href="classcds_1_1container_1_1_cuckoo_map.html#a40094438568aee8e8bf456585ff0c15d">hash</a>;</div>
<div class="line">    <span class="keyword">typedef</span> cds::container::cuckoo::vector&lt;4&gt; probeset_type;</div>
<div class="line"></div>
<div class="line">    <span class="keyword">static</span> <span class="keywordtype">bool</span> <span class="keyword">const</span> store_hash = <span class="keyword">true</span>;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="comment">// Declare CuckooMap type</span></div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="classcds_1_1container_1_1_cuckoo_map.html">cds::container::CuckooMap&lt; std::string, foo, my_traits &gt;</a> my_cuckoo_map;</div>
<div class="line"></div>
<div class="line"><span class="comment">// Equal option-based declaration</span></div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="classcds_1_1container_1_1_cuckoo_map.html">cds::container::CuckooMap</a>&lt; std::string, foo,</div>
<div class="line">    <a class="code" href="structcds_1_1container_1_1cuckoo_1_1make__traits.html">cds::container::cuckoo::make_traits</a>&lt;</div>
<div class="line">        cds::opt::hash&lt; std::tuple&lt; hash1, hash2 &gt; &gt;</div>
<div class="line">        ,<a class="code" href="structcds_1_1opt_1_1less.html">cds::opt::less&lt; std::less&lt; std::string &gt;</a> &gt;</div>
<div class="line">        ,<a class="code" href="structcds_1_1container_1_1cuckoo_1_1probeset__type.html">cds::container::cuckoo::probeset_type&lt; cds::container::cuckoo::vector&lt;4&gt;</a> &gt;</div>
<div class="line">        ,<a class="code" href="structcds_1_1container_1_1cuckoo_1_1store__hash.html">cds::container::cuckoo::store_hash&lt; true &gt;</a></div>
<div class="line">    &gt;::type</div>
<div class="line">&gt; opt_cuckoo_map;</div>
</div><!-- fragment --> </div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a341c7da08ef0c77406969e8414e71b9d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T , typename Traits  = cuckoo::traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1container_1_1_cuckoo_map.html">cds::container::CuckooMap</a>&lt; Key, T, Traits &gt;::<a class="el" href="classcds_1_1container_1_1_cuckoo_map.html">CuckooMap</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor. </p>
<p>Initial size = <a class="el" href="classcds_1_1container_1_1_cuckoo_map.html#a92aad97a2dd8a8cc65dd6015e95512b3">c_nDefaultInitialSize</a></p>
<p>Probe set size:</p><ul>
<li><a class="el" href="classcds_1_1container_1_1_cuckoo_map.html#a3f7cdc6c06a45355e7616eacd12a361b">c_nDefaultProbesetSize</a> if <code>probeset_type</code> is <code>cuckoo::list</code> </li>
<li><code>Capacity</code> if <code>probeset_type</code> is <code> cuckoo::vector&lt;Capacity&gt; </code></li>
</ul>
<p>Probe set threshold = probe set size - 1 </p>

</div>
</div>
<a class="anchor" id="a9004754391ab93c87e581461b63fbb44"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T , typename Traits  = cuckoo::traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1container_1_1_cuckoo_map.html">cds::container::CuckooMap</a>&lt; Key, T, Traits &gt;::<a class="el" href="classcds_1_1container_1_1_cuckoo_map.html">CuckooMap</a> </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nInitialSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>nProbesetSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>nProbesetThreshold</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs an object with given probe set size and threshold. </p>
<p>If probe set type is <code> cuckoo::vector&lt;Capacity&gt; </code> vector then <code>nProbesetSize</code> should be equal to vector's <code>Capacity</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nInitialSize</td><td>Initial map size; if 0 - use default initial size <a class="el" href="classcds_1_1container_1_1_cuckoo_map.html#a92aad97a2dd8a8cc65dd6015e95512b3">c_nDefaultInitialSize</a> </td></tr>
    <tr><td class="paramname">nProbesetSize</td><td>probe set size </td></tr>
    <tr><td class="paramname">nProbesetThreshold</td><td>probe set threshold, <code>nProbesetThreshold &lt; nProbesetSize</code>. If 0, nProbesetThreshold = nProbesetSize - 1 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a779df6d9d36dc26634173734b851d277"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T , typename Traits  = cuckoo::traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1container_1_1_cuckoo_map.html">cds::container::CuckooMap</a>&lt; Key, T, Traits &gt;::<a class="el" href="classcds_1_1container_1_1_cuckoo_map.html">CuckooMap</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcds_1_1container_1_1_cuckoo_map.html#a875c8c5ecc6c99c802d7368b76cd1486">hash_tuple_type</a> const &amp;&#160;</td>
          <td class="paramname"><em>h</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs an object with given hash functor tuple. </p>
<p>The probe set size and threshold are set as default, see <a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a3e221ce6294ce2a9bd4ad4e6fe06b367" title="Default constructor. ">CuckooSet()</a> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>hash functor tuple of type <code>std::tuple&lt;H1, H2, ... Hn&gt;</code> where <code> n == <a class="el" href="classcds_1_1container_1_1_cuckoo_map.html#a35537f20a82788a4fa973c9f894ba74c">c_nArity</a> </code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac976f4836e512daeabfff6683f43d323"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T , typename Traits  = cuckoo::traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1container_1_1_cuckoo_map.html">cds::container::CuckooMap</a>&lt; Key, T, Traits &gt;::<a class="el" href="classcds_1_1container_1_1_cuckoo_map.html">CuckooMap</a> </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nInitialSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>nProbesetSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>nProbesetThreshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcds_1_1container_1_1_cuckoo_map.html#a875c8c5ecc6c99c802d7368b76cd1486">hash_tuple_type</a> const &amp;&#160;</td>
          <td class="paramname"><em>h</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a map with given probe set properties and hash functor tuple. </p>
<p>If probe set type is <code> cuckoo::vector&lt;Capacity&gt; </code> vector then <code>nProbesetSize</code> should be equal to vector's <code>Capacity</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nInitialSize</td><td>Initial map size; if 0 - use default initial size <a class="el" href="classcds_1_1container_1_1_cuckoo_map.html#a92aad97a2dd8a8cc65dd6015e95512b3">c_nDefaultInitialSize</a> </td></tr>
    <tr><td class="paramname">nProbesetSize</td><td>probe set size </td></tr>
    <tr><td class="paramname">nProbesetThreshold</td><td>probe set threshold, <code>nProbesetThreshold &lt; nProbesetSize</code>. If 0, nProbesetThreshold = nProbesetSize - 1 </td></tr>
    <tr><td class="paramname">h</td><td>hash functor tuple of type <code>std::tuple&lt;H1, H2, ... Hn&gt;</code> where <code> n == <a class="el" href="classcds_1_1container_1_1_cuckoo_map.html#a35537f20a82788a4fa973c9f894ba74c">c_nArity</a> </code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a16fd32ddba075fca3ffe33c44181fdb6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T , typename Traits  = cuckoo::traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1container_1_1_cuckoo_map.html">cds::container::CuckooMap</a>&lt; Key, T, Traits &gt;::<a class="el" href="classcds_1_1container_1_1_cuckoo_map.html">CuckooMap</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcds_1_1container_1_1_cuckoo_map.html#a875c8c5ecc6c99c802d7368b76cd1486">hash_tuple_type</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>h</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a map with given hash functor tuple (move semantics) </p>
<p>The probe set size and threshold are set as default, see <a class="el" href="classcds_1_1intrusive_1_1_cuckoo_set.html#a3e221ce6294ce2a9bd4ad4e6fe06b367" title="Default constructor. ">CuckooSet()</a> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>hash functor tuple of type <code>std::tuple&lt;H1, H2, ... Hn&gt;</code> where <code> n == <a class="el" href="classcds_1_1container_1_1_cuckoo_map.html#a35537f20a82788a4fa973c9f894ba74c">c_nArity</a> </code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9bf609fe428c69dd4f794a7936bb6428"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T , typename Traits  = cuckoo::traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1container_1_1_cuckoo_map.html">cds::container::CuckooMap</a>&lt; Key, T, Traits &gt;::<a class="el" href="classcds_1_1container_1_1_cuckoo_map.html">CuckooMap</a> </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nInitialSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>nProbesetSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>nProbesetThreshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcds_1_1container_1_1_cuckoo_map.html#a875c8c5ecc6c99c802d7368b76cd1486">hash_tuple_type</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>h</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a map with given probe set properties and hash functor tuple (move semantics) </p>
<p>If probe set type is <code> cuckoo::vector&lt;Capacity&gt; </code> vector then <code>nProbesetSize</code> should be equal to vector's <code>Capacity</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nInitialSize</td><td>Initial map size; if 0 - use default initial size <a class="el" href="classcds_1_1container_1_1_cuckoo_map.html#a92aad97a2dd8a8cc65dd6015e95512b3">c_nDefaultInitialSize</a> </td></tr>
    <tr><td class="paramname">nProbesetSize</td><td>probe set size </td></tr>
    <tr><td class="paramname">nProbesetThreshold</td><td>probe set threshold, <code>nProbesetThreshold &lt; nProbesetSize</code>. If 0, nProbesetThreshold = nProbesetSize - 1 </td></tr>
    <tr><td class="paramname">h</td><td>hash functor tuple of type <code>std::tuple&lt;H1, H2, ... Hn&gt;</code> where <code> n == <a class="el" href="classcds_1_1container_1_1_cuckoo_map.html#a35537f20a82788a4fa973c9f894ba74c">c_nArity</a> </code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a53711b0378aab7e54012f772657c8637"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T , typename Traits  = cuckoo::traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classcds_1_1container_1_1_cuckoo_map.html">cds::container::CuckooMap</a>&lt; Key, T, Traits &gt;::bucket_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the size of hash table. </p>
<p>The hash table size is non-constant and can be increased via resizing. </p>

</div>
</div>
<a class="anchor" id="a7585c9d40606e3e998633d76aebaeebd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T , typename Traits  = cuckoo::traits&gt; </div>
<div class="memtemplate">
template&lt;typename K &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_cuckoo_map.html">cds::container::CuckooMap</a>&lt; Key, T, Traits &gt;::contains </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether the map contains <code>key</code>. </p>
<p>The function searches the item with key equal to <code>key</code> and returns <code>true</code> if it is found, and <code>false</code> otherwise. </p>

</div>
</div>
<a class="anchor" id="a2dcd1949a45c4a9b284b6bee09dd5cd2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T , typename Traits  = cuckoo::traits&gt; </div>
<div class="memtemplate">
template&lt;typename K , typename Predicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_cuckoo_map.html">cds::container::CuckooMap</a>&lt; Key, T, Traits &gt;::contains </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Predicate&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether the map contains <code>key</code> using <code>pred</code> predicate for searching. </p>
<p>The function is similar to <code>contains( key )</code> but <code>pred</code> is used for key comparing. <code>Less</code> functor has the interface like <code>std::less</code>. <code>Less</code> must imply the same element order as the comparator used for building the map. </p>

</div>
</div>
<a class="anchor" id="ae7b5dac039c3782313e7491e84679f8e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T , typename Traits  = cuckoo::traits&gt; </div>
<div class="memtemplate">
template&lt;typename K , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_cuckoo_map.html">cds::container::CuckooMap</a>&lt; Key, T, Traits &gt;::emplace </td>
          <td>(</td>
          <td class="paramtype">K &amp;&amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For key <code>key</code> inserts data of type <a class="el" href="classcds_1_1container_1_1_cuckoo_map.html#a6b7029bea19087f7565784426abffcba">value_type</a> constructed with <code>std::forward&lt;Args&gt;(args)...</code> </p>
<p>Returns <code>true</code> if inserting successful, <code>false</code> otherwise. </p>

</div>
</div>
<a class="anchor" id="a13dd080b264b73565911c99c760116c2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T , typename Traits  = cuckoo::traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_cuckoo_map.html">cds::container::CuckooMap</a>&lt; Key, T, Traits &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the map is empty. </p>
<p>Emptiness is checked by item counting: if item count is zero then the map is empty. </p>

</div>
</div>
<a class="anchor" id="a949108e97bfa54780ef4816ba0db2ef0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T , typename Traits  = cuckoo::traits&gt; </div>
<div class="memtemplate">
template&lt;typename K &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_cuckoo_map.html">cds::container::CuckooMap</a>&lt; Key, T, Traits &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Delete <code>key</code> from the map. </p>
<p><a class="anchor" id="cds_nonintrusive_CuckooMap_erase_val"></a> Return <code>true</code> if <code>key</code> is found and deleted, <code>false</code> otherwise </p>

</div>
</div>
<a class="anchor" id="aadddd9a1a41b940289a1f7efdf78fcae"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T , typename Traits  = cuckoo::traits&gt; </div>
<div class="memtemplate">
template&lt;typename K , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_cuckoo_map.html">cds::container::CuckooMap</a>&lt; Key, T, Traits &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Delete <code>key</code> from the map. </p>
<p><a class="anchor" id="cds_nonintrusive_CuckooMap_erase_func"></a> The function searches an item with key <code>key</code>, calls <code>f</code> functor and deletes the item. If <code>key</code> is not found, the functor is not called.</p>
<p>The functor <code>Func</code> interface: </p><div class="fragment"><div class="line"><span class="keyword">struct </span>extractor {</div>
<div class="line">    <span class="keywordtype">void</span> operator()(<a class="code" href="classcds_1_1container_1_1_cuckoo_map.html#a6b7029bea19087f7565784426abffcba">value_type</a>&amp; item) { ... }</div>
<div class="line">};</div>
</div><!-- fragment --><p>Return <code>true</code> if key is found and deleted, <code>false</code> otherwise</p>
<p>See also: <a class="el" href="classcds_1_1container_1_1_cuckoo_map.html#a949108e97bfa54780ef4816ba0db2ef0">erase</a> </p>

</div>
</div>
<a class="anchor" id="a773b90f2861fd07a205b1d7113a2faee"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T , typename Traits  = cuckoo::traits&gt; </div>
<div class="memtemplate">
template&lt;typename K , typename Predicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_cuckoo_map.html">cds::container::CuckooMap</a>&lt; Key, T, Traits &gt;::erase_with </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Predicate&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deletes the item from the list using <code>pred</code> predicate for searching. </p>
<p>The function is an analog of <a class="el" href="classcds_1_1container_1_1_cuckoo_map.html#cds_nonintrusive_CuckooMap_erase_val">erase(Q const&amp;)</a> but <code>pred</code> is used for key comparing. If cuckoo map is ordered, then <code>Predicate</code> should have the interface and semantics like <code>std::less</code>. If cuckoo map is unordered, then <code>Predicate</code> should have the interface and semantics like <code>std::equal_to</code>. <code>Predicate</code> must imply the same element order as the comparator used for building the map. </p>

</div>
</div>
<a class="anchor" id="a89acd3bfb03ea7705a91f05af79e0be9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T , typename Traits  = cuckoo::traits&gt; </div>
<div class="memtemplate">
template&lt;typename K , typename Predicate , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_cuckoo_map.html">cds::container::CuckooMap</a>&lt; Key, T, Traits &gt;::erase_with </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Predicate&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deletes the item from the list using <code>pred</code> predicate for searching. </p>
<p>The function is an analog of <a class="el" href="classcds_1_1container_1_1_cuckoo_map.html#cds_nonintrusive_CuckooMap_erase_func">erase(Q const&amp;, Func)</a> but <code>pred</code> is used for key comparing. If cuckoo map is ordered, then <code>Predicate</code> should have the interface and semantics like <code>std::less</code>. If cuckoo map is unordered, then <code>Predicate</code> should have the interface and semantics like <code>std::equal_to</code>. <code>Predicate</code> must imply the same element order as the comparator used for building the map. </p>

</div>
</div>
<a class="anchor" id="a49e55b628a859e446f9751046c8fa464"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T , typename Traits  = cuckoo::traits&gt; </div>
<div class="memtemplate">
template&lt;typename K , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_cuckoo_map.html">cds::container::CuckooMap</a>&lt; Key, T, Traits &gt;::find </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the key <code>key</code>. </p>
<p><a class="anchor" id="cds_nonintrusive_CuckooMap_find_func"></a> The function searches the item with key equal to <code>key</code> and calls the functor <code>f</code> for item found. The interface of <code>Func</code> functor is: </p><div class="fragment"><div class="line"><span class="keyword">struct </span>functor {</div>
<div class="line">    <span class="keywordtype">void</span> operator()( <a class="code" href="classcds_1_1container_1_1_cuckoo_map.html#a6b7029bea19087f7565784426abffcba">value_type</a>&amp; item );</div>
<div class="line">};</div>
</div><!-- fragment --><p> where <code>item</code> is the item found.</p>
<p>The functor may change <code>item.second</code>.</p>
<p>The function returns <code>true</code> if <code>key</code> is found, <code>false</code> otherwise. </p>

</div>
</div>
<a class="anchor" id="ac0944519780b201d3f0e265f73e47771"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T , typename Traits  = cuckoo::traits&gt; </div>
<div class="memtemplate">
template&lt;typename K , typename Predicate , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_cuckoo_map.html">cds::container::CuckooMap</a>&lt; Key, T, Traits &gt;::find_with </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Predicate&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the key <code>val</code> using <code>pred</code> predicate for comparing. </p>
<p>The function is an analog of <a class="el" href="classcds_1_1container_1_1_cuckoo_map.html#cds_nonintrusive_CuckooMap_find_func">find(K const&amp;, Func)</a> but <code>pred</code> is used for key comparison. If you use ordered cuckoo map, then <code>Predicate</code> should have the interface and semantics like <code>std::less</code>. If you use unordered cuckoo map, then <code>Predicate</code> should have the interface and semantics like <code>std::equal_to</code>. <code>pred</code> must imply the same element order as the comparator used for building the map. </p>

</div>
</div>
<a class="anchor" id="a305d109764c5685e2f8d649c15f0ebc7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T , typename Traits  = cuckoo::traits&gt; </div>
<div class="memtemplate">
template&lt;typename K &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_cuckoo_map.html">cds::container::CuckooMap</a>&lt; Key, T, Traits &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts new node with key and default value. </p>
<p>The function creates a node with <code>key</code> and default value, and then inserts the node created into the map.</p>
<p>Preconditions:</p><ul>
<li>The <a class="el" href="classcds_1_1container_1_1_cuckoo_map.html#a3da032600868e73a64b352ee8fde1ad2">key_type</a> should be constructible from a value of type <code>K</code>. In trivial case, <code>K</code> is equal to <a class="el" href="classcds_1_1container_1_1_cuckoo_map.html#a3da032600868e73a64b352ee8fde1ad2">key_type</a>.</li>
<li>The <a class="el" href="classcds_1_1container_1_1_cuckoo_map.html#ab64c43804999ac92124b547ee9d35721">mapped_type</a> should be default-constructible.</li>
</ul>
<p>Returns <code>true</code> if inserting successful, <code>false</code> otherwise. </p>

</div>
</div>
<a class="anchor" id="ac30d8a9a5bff3cf218c0f55809bc12bf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T , typename Traits  = cuckoo::traits&gt; </div>
<div class="memtemplate">
template&lt;typename K , typename V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_cuckoo_map.html">cds::container::CuckooMap</a>&lt; Key, T, Traits &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">V const &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts new node. </p>
<p>The function creates a node with copy of <code>val</code> value and then inserts the node created into the map.</p>
<p>Preconditions:</p><ul>
<li>The <a class="el" href="classcds_1_1container_1_1_cuckoo_map.html#a3da032600868e73a64b352ee8fde1ad2">key_type</a> should be constructible from <code>key</code> of type <code>K</code>.</li>
<li>The <a class="el" href="classcds_1_1container_1_1_cuckoo_map.html#a6b7029bea19087f7565784426abffcba">value_type</a> should be constructible from <code>val</code> of type <code>V</code>.</li>
</ul>
<p>Returns <code>true</code> if <code>val</code> is inserted into the set, <code>false</code> otherwise. </p>

</div>
</div>
<a class="anchor" id="acab9998f29a722cc9d073d08aaf6a457"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T , typename Traits  = cuckoo::traits&gt; </div>
<div class="memtemplate">
template&lt;typename K , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_cuckoo_map.html">cds::container::CuckooMap</a>&lt; Key, T, Traits &gt;::insert_with </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts new node and initialize it by a functor. </p>
<p>This function inserts new node with key <code>key</code> and if inserting is successful then it calls <code>func</code> functor with signature </p><div class="fragment"><div class="line"><span class="keyword">struct </span>functor {</div>
<div class="line">    <span class="keywordtype">void</span> operator()( <a class="code" href="classcds_1_1container_1_1_cuckoo_map.html#a6b7029bea19087f7565784426abffcba">value_type</a>&amp; item );</div>
<div class="line">};</div>
</div><!-- fragment --><p>The argument <code>item</code> of user-defined functor <code>func</code> is the reference to the map's item inserted:</p><ul>
<li><code>item.first</code> is a const reference to item's key that cannot be changed.</li>
<li><code>item.second</code> is a reference to item's value that may be changed.</li>
</ul>
<p>The key_type should be constructible from value of type <code>K</code>.</p>
<p>The function allows to split creating of new item into two part:</p><ul>
<li>create item from <code>key</code>;</li>
<li>insert new item into the map;</li>
<li>if inserting is successful, initialize the value of item by calling <code>func</code> functor</li>
</ul>
<p>This can be useful if complete initialization of object of <code>value_type</code> is heavyweight and it is preferable that the initialization should be completed only if inserting is successful. </p>

</div>
</div>
<a class="anchor" id="a7f84095546cb5c807d5927286933a408"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T , typename Traits  = cuckoo::traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classcds_1_1container_1_1_cuckoo_map.html">cds::container::CuckooMap</a>&lt; Key, T, Traits &gt;::lock_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns lock array size. </p>
<p>The lock array size is constant. </p>

</div>
</div>
<a class="anchor" id="a4aba6537a931cd08f2664a10e09bdc29"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T , typename Traits  = cuckoo::traits&gt; </div>
<div class="memtemplate">
template&lt;typename K , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;bool, bool&gt; <a class="el" href="classcds_1_1container_1_1_cuckoo_map.html">cds::container::CuckooMap</a>&lt; Key, T, Traits &gt;::update </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bAllowInsert</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Updates the node. </p>
<p>The operation performs inserting or changing data with lock-free manner.</p>
<p>If <code>key</code> is not found in the map, then <code>key</code> is inserted iff <code>bAllowInsert</code> is <code>true</code>. Otherwise, the functor <code>func</code> is called with item found. The functor <code>func</code> signature is: </p><div class="fragment"><div class="line"><span class="keyword">struct </span>my_functor {</div>
<div class="line">    <span class="keywordtype">void</span> operator()( <span class="keywordtype">bool</span> bNew, <a class="code" href="classcds_1_1container_1_1_cuckoo_map.html#a6b7029bea19087f7565784426abffcba">value_type</a>&amp; item );</div>
<div class="line">};</div>
</div><!-- fragment --><p> with arguments:</p><ul>
<li><code>bNew</code> - <code>true</code> if the item has been inserted, <code>false</code> otherwise</li>
<li><code>item</code> - an item of the map for <code>key</code> </li>
</ul>
<p>Returns std::pair&lt;bool, bool&gt; where <code>first</code> is <code>true</code> if operation is successfull, i.e. the node has been inserted or updated, <code>second</code> is <code>true</code> if new item has been added or <code>false</code> if the item with <code>key</code> already exists. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>cds/container/cuckoo_map.h</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<hr/>
<div align="right">
  <b>cds</b> <b>2.1.0</b> 
  Developed by <i>Maxim Khizhinsky aka khizmax</i> 2007 - 2015
  <br/>
  <i>Autogenerated Wed Jan 6 2016 16:00:36 by Doxygen 1.8.10</i>
</div>
</body>
</html>
