<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>cds: cds::container::StripedSet&lt; Container, Options &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">cds
   &#160;<span id="projectnumber">2.1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="classes.html"><span>Data&#160;Structure&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Data&#160;Fields</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classcds_1_1container_1_1_striped_set.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">cds::container::StripedSet&lt; Container, Options &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__cds__nonintrusive__containers.html">Non-intrusive containers</a> &raquo; <a class="el" href="group__cds__nonintrusive__set.html">Set</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Striped hash set.  
 <a href="classcds_1_1container_1_1_striped_set.html#details">More...</a></p>

<p><code>#include &lt;cds/container/striped_set.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for cds::container::StripedSet&lt; Container, Options &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classcds_1_1container_1_1_striped_set.png" usemap="#cds::container::StripedSet&lt; Container, Options &gt;_map" alt=""/>
  <map id="cds::container::StripedSet&lt; Container, Options &gt;_map" name="cds::container::StripedSet&lt; Container, Options &gt;_map">
<area href="classcds_1_1intrusive_1_1_striped_set.html" alt="cds::intrusive::StripedSet&lt; Container, Options... &gt;" shape="rect" coords="0,0,293,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ab78f765a66999a851520edd05688f688"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab78f765a66999a851520edd05688f688"></a>
typedef Container&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_striped_set.html#ab78f765a66999a851520edd05688f688">underlying_container_type</a></td></tr>
<tr class="memdesc:ab78f765a66999a851520edd05688f688"><td class="mdescLeft">&#160;</td><td class="mdescRight">original intrusive container type for the bucket <br /></td></tr>
<tr class="separator:ab78f765a66999a851520edd05688f688"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd05847a606289e2125e22c390836e2d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acd05847a606289e2125e22c390836e2d"></a>
typedef base_class::bucket_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_striped_set.html#acd05847a606289e2125e22c390836e2d">bucket_type</a></td></tr>
<tr class="memdesc:acd05847a606289e2125e22c390836e2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">container type adapted for hash set <br /></td></tr>
<tr class="separator:acd05847a606289e2125e22c390836e2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2497aaa946640a16825e61d14a6d6189"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2497aaa946640a16825e61d14a6d6189"></a>
typedef bucket_type::value_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_striped_set.html#a2497aaa946640a16825e61d14a6d6189">value_type</a></td></tr>
<tr class="memdesc:a2497aaa946640a16825e61d14a6d6189"><td class="mdescLeft">&#160;</td><td class="mdescRight">value type stored in the set <br /></td></tr>
<tr class="separator:a2497aaa946640a16825e61d14a6d6189"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3b1488d09e53e4fdadf2581db30b311"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab3b1488d09e53e4fdadf2581db30b311"></a>
typedef base_class::hash&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_striped_set.html#ab3b1488d09e53e4fdadf2581db30b311">hash</a></td></tr>
<tr class="memdesc:ab3b1488d09e53e4fdadf2581db30b311"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hash functor. <br /></td></tr>
<tr class="separator:ab3b1488d09e53e4fdadf2581db30b311"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff8e128e84f4a17ae60a837867556050"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aff8e128e84f4a17ae60a837867556050"></a>
typedef base_class::item_counter&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_striped_set.html#aff8e128e84f4a17ae60a837867556050">item_counter</a></td></tr>
<tr class="memdesc:aff8e128e84f4a17ae60a837867556050"><td class="mdescLeft">&#160;</td><td class="mdescRight">Item counter. <br /></td></tr>
<tr class="separator:aff8e128e84f4a17ae60a837867556050"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a132347759ae9e7929c5dc75a53890687"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a132347759ae9e7929c5dc75a53890687"></a>
typedef base_class::resizing_policy&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_striped_set.html#a132347759ae9e7929c5dc75a53890687">resizing_policy</a></td></tr>
<tr class="memdesc:a132347759ae9e7929c5dc75a53890687"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resizing policy. <br /></td></tr>
<tr class="separator:a132347759ae9e7929c5dc75a53890687"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae456575fca3f9634a4cbc25504d01a2a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae456575fca3f9634a4cbc25504d01a2a"></a>
typedef base_class::allocator_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_striped_set.html#ae456575fca3f9634a4cbc25504d01a2a">allocator_type</a></td></tr>
<tr class="memdesc:ae456575fca3f9634a4cbc25504d01a2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">allocator type specified in options. <br /></td></tr>
<tr class="separator:ae456575fca3f9634a4cbc25504d01a2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52867de81f8ae19c2bc1d261694470ec"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a52867de81f8ae19c2bc1d261694470ec"></a>
typedef base_class::mutex_policy&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_striped_set.html#a52867de81f8ae19c2bc1d261694470ec">mutex_policy</a></td></tr>
<tr class="memdesc:a52867de81f8ae19c2bc1d261694470ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mutex policy. <br /></td></tr>
<tr class="separator:a52867de81f8ae19c2bc1d261694470ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a5b62b8c4af0730a78837e3c8a29994c2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5b62b8c4af0730a78837e3c8a29994c2"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_striped_set.html#a5b62b8c4af0730a78837e3c8a29994c2">StripedSet</a> ()</td></tr>
<tr class="memdesc:a5b62b8c4af0730a78837e3c8a29994c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default ctor. The initial capacity is 16. <br /></td></tr>
<tr class="separator:a5b62b8c4af0730a78837e3c8a29994c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a319c779ca7127d5fc03ade9a521a0338"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_striped_set.html#a319c779ca7127d5fc03ade9a521a0338">StripedSet</a> (size_t nCapacity)</td></tr>
<tr class="memdesc:a319c779ca7127d5fc03ade9a521a0338"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ctor with initial capacity specified.  <a href="#a319c779ca7127d5fc03ade9a521a0338">More...</a><br /></td></tr>
<tr class="separator:a319c779ca7127d5fc03ade9a521a0338"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d042ba5068bfcbc9ad5737938794cd7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_striped_set.html#a9d042ba5068bfcbc9ad5737938794cd7">StripedSet</a> (size_t nCapacity,<a class="el" href="classcds_1_1container_1_1_striped_set.html#a132347759ae9e7929c5dc75a53890687">resizing_policy</a> const &amp;resizingPolicy)</td></tr>
<tr class="memdesc:a9d042ba5068bfcbc9ad5737938794cd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ctor with resizing policy (copy semantics)  <a href="#a9d042ba5068bfcbc9ad5737938794cd7">More...</a><br /></td></tr>
<tr class="separator:a9d042ba5068bfcbc9ad5737938794cd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c0ef12897d8f8923a9725fa1c49d14d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_striped_set.html#a0c0ef12897d8f8923a9725fa1c49d14d">StripedSet</a> (size_t nCapacity,<a class="el" href="classcds_1_1container_1_1_striped_set.html#a132347759ae9e7929c5dc75a53890687">resizing_policy</a> &amp;&amp;resizingPolicy)</td></tr>
<tr class="memdesc:a0c0ef12897d8f8923a9725fa1c49d14d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ctor with resizing policy (move semantics)  <a href="#a0c0ef12897d8f8923a9725fa1c49d14d">More...</a><br /></td></tr>
<tr class="separator:a0c0ef12897d8f8923a9725fa1c49d14d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0eee4ba35c6a33a03d12ad436cefc832"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0eee4ba35c6a33a03d12ad436cefc832"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_striped_set.html#a0eee4ba35c6a33a03d12ad436cefc832">~StripedSet</a> ()</td></tr>
<tr class="memdesc:a0eee4ba35c6a33a03d12ad436cefc832"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor destroys internal data. <br /></td></tr>
<tr class="separator:a0eee4ba35c6a33a03d12ad436cefc832"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff8843b99b6f85ad37e9b4e4d920f523"><td class="memTemplParams" colspan="2">template&lt;typename Q &gt; </td></tr>
<tr class="memitem:aff8843b99b6f85ad37e9b4e4d920f523"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_striped_set.html#aff8843b99b6f85ad37e9b4e4d920f523">insert</a> (Q const &amp;val)</td></tr>
<tr class="memdesc:aff8843b99b6f85ad37e9b4e4d920f523"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new node.  <a href="#aff8843b99b6f85ad37e9b4e4d920f523">More...</a><br /></td></tr>
<tr class="separator:aff8843b99b6f85ad37e9b4e4d920f523"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6516d09d6a558712c1827bf57bd65b53"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Func &gt; </td></tr>
<tr class="memitem:a6516d09d6a558712c1827bf57bd65b53"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_striped_set.html#a6516d09d6a558712c1827bf57bd65b53">insert</a> (Q const &amp;val, Func f)</td></tr>
<tr class="memdesc:a6516d09d6a558712c1827bf57bd65b53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new node.  <a href="#a6516d09d6a558712c1827bf57bd65b53">More...</a><br /></td></tr>
<tr class="separator:a6516d09d6a558712c1827bf57bd65b53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a5007c5df1cb5cdea5f404ac25a88bd"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a6a5007c5df1cb5cdea5f404ac25a88bd"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_striped_set.html#a6a5007c5df1cb5cdea5f404ac25a88bd">emplace</a> (Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:a6a5007c5df1cb5cdea5f404ac25a88bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts data of type <code>value_type</code> constructed with <code>std::forward&lt;Args&gt;(args)...</code>  <a href="#a6a5007c5df1cb5cdea5f404ac25a88bd">More...</a><br /></td></tr>
<tr class="separator:a6a5007c5df1cb5cdea5f404ac25a88bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0bc8935f7925e4b446c6b1c1e37d247"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Func &gt; </td></tr>
<tr class="memitem:af0bc8935f7925e4b446c6b1c1e37d247"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; bool, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_striped_set.html#af0bc8935f7925e4b446c6b1c1e37d247">update</a> (Q const &amp;val, Func func, bool bAllowInsert=true)</td></tr>
<tr class="memdesc:af0bc8935f7925e4b446c6b1c1e37d247"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the node.  <a href="#af0bc8935f7925e4b446c6b1c1e37d247">More...</a><br /></td></tr>
<tr class="separator:af0bc8935f7925e4b446c6b1c1e37d247"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad89f2115ab187e2105c91dd933cb82d7"><td class="memTemplParams" colspan="2">template&lt;typename Q &gt; </td></tr>
<tr class="memitem:ad89f2115ab187e2105c91dd933cb82d7"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_striped_set.html#ad89f2115ab187e2105c91dd933cb82d7">erase</a> (Q const &amp;key)</td></tr>
<tr class="memdesc:ad89f2115ab187e2105c91dd933cb82d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete <code>key</code> from the set.  <a href="#ad89f2115ab187e2105c91dd933cb82d7">More...</a><br /></td></tr>
<tr class="separator:ad89f2115ab187e2105c91dd933cb82d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93bbd4712424855500108292e10935f7"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Less , typename Bucket  = bucket_type, typename  = typename std::enable_if&lt; Bucket::has_erase_with &gt;::type&gt; </td></tr>
<tr class="memitem:a93bbd4712424855500108292e10935f7"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_striped_set.html#a93bbd4712424855500108292e10935f7">erase_with</a> (Q const &amp;key, Less pred)</td></tr>
<tr class="memdesc:a93bbd4712424855500108292e10935f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the item from the set using <code>pred</code> predicate for searching.  <a href="#a93bbd4712424855500108292e10935f7">More...</a><br /></td></tr>
<tr class="separator:a93bbd4712424855500108292e10935f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c3e75924c53c72d92082b484975af7a"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Func &gt; </td></tr>
<tr class="memitem:a0c3e75924c53c72d92082b484975af7a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_striped_set.html#a0c3e75924c53c72d92082b484975af7a">erase</a> (Q const &amp;key, Func f)</td></tr>
<tr class="memdesc:a0c3e75924c53c72d92082b484975af7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete <code>key</code> from the set.  <a href="#a0c3e75924c53c72d92082b484975af7a">More...</a><br /></td></tr>
<tr class="separator:a0c3e75924c53c72d92082b484975af7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af161c84a97d8357664c37720bdf77879"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Less , typename Func , typename Bucket  = bucket_type, typename  = typename std::enable_if&lt; Bucket::has_erase_with &gt;::type&gt; </td></tr>
<tr class="memitem:af161c84a97d8357664c37720bdf77879"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_striped_set.html#af161c84a97d8357664c37720bdf77879">erase_with</a> (Q const &amp;key, Less pred, Func f)</td></tr>
<tr class="memdesc:af161c84a97d8357664c37720bdf77879"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the item from the set using <code>pred</code> predicate for searching.  <a href="#af161c84a97d8357664c37720bdf77879">More...</a><br /></td></tr>
<tr class="separator:af161c84a97d8357664c37720bdf77879"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a203525441d38698012f814d8408f6d36"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Func &gt; </td></tr>
<tr class="memitem:a203525441d38698012f814d8408f6d36"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_striped_set.html#a203525441d38698012f814d8408f6d36">find</a> (Q &amp;val, Func f)</td></tr>
<tr class="memdesc:a203525441d38698012f814d8408f6d36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the key <code>val</code>.  <a href="#a203525441d38698012f814d8408f6d36">More...</a><br /></td></tr>
<tr class="separator:a203525441d38698012f814d8408f6d36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7aaecb8e05cd335c57507c1a69ea3078"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Less , typename Func , typename Bucket  = bucket_type, typename  = typename std::enable_if&lt; Bucket::has_find_with &gt;::type&gt; </td></tr>
<tr class="memitem:a7aaecb8e05cd335c57507c1a69ea3078"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_striped_set.html#a7aaecb8e05cd335c57507c1a69ea3078">find_with</a> (Q &amp;val, Less pred, Func f)</td></tr>
<tr class="memdesc:a7aaecb8e05cd335c57507c1a69ea3078"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the key <code>val</code> using <code>pred</code> predicate.  <a href="#a7aaecb8e05cd335c57507c1a69ea3078">More...</a><br /></td></tr>
<tr class="separator:a7aaecb8e05cd335c57507c1a69ea3078"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb9099506c1034b3a5f437db5e73c1d0"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Func &gt; </td></tr>
<tr class="memitem:acb9099506c1034b3a5f437db5e73c1d0"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_striped_set.html#acb9099506c1034b3a5f437db5e73c1d0">find</a> (Q const &amp;val, Func f)</td></tr>
<tr class="memdesc:acb9099506c1034b3a5f437db5e73c1d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the key <code>val</code>.  <a href="#acb9099506c1034b3a5f437db5e73c1d0">More...</a><br /></td></tr>
<tr class="separator:acb9099506c1034b3a5f437db5e73c1d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a062a1d56946e140c120856be09b04a"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Less , typename Func , typename Bucket  = bucket_type, typename  = typename std::enable_if&lt; Bucket::has_find_with &gt;::type&gt; </td></tr>
<tr class="memitem:a6a062a1d56946e140c120856be09b04a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_striped_set.html#a6a062a1d56946e140c120856be09b04a">find_with</a> (Q const &amp;val, Less pred, Func f)</td></tr>
<tr class="memdesc:a6a062a1d56946e140c120856be09b04a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the key <code>val</code> using <code>pred</code> predicate.  <a href="#a6a062a1d56946e140c120856be09b04a">More...</a><br /></td></tr>
<tr class="separator:a6a062a1d56946e140c120856be09b04a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0dfbf9bd83bc92c1d7611532811c523"><td class="memTemplParams" colspan="2">template&lt;typename Q &gt; </td></tr>
<tr class="memitem:aa0dfbf9bd83bc92c1d7611532811c523"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_striped_set.html#aa0dfbf9bd83bc92c1d7611532811c523">contains</a> (Q const &amp;key)</td></tr>
<tr class="memdesc:aa0dfbf9bd83bc92c1d7611532811c523"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the set contains <code>key</code>.  <a href="#aa0dfbf9bd83bc92c1d7611532811c523">More...</a><br /></td></tr>
<tr class="separator:aa0dfbf9bd83bc92c1d7611532811c523"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4581ada4d40d30156be2138d96209008"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Less , typename Bucket  = bucket_type, typename  = typename std::enable_if&lt; Bucket::has_find_with &gt;::type&gt; </td></tr>
<tr class="memitem:a4581ada4d40d30156be2138d96209008"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_striped_set.html#a4581ada4d40d30156be2138d96209008">contains</a> (Q const &amp;key, Less pred)</td></tr>
<tr class="memdesc:a4581ada4d40d30156be2138d96209008"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the map contains <code>key</code> using <code>pred</code> predicate for searching.  <a href="#a4581ada4d40d30156be2138d96209008">More...</a><br /></td></tr>
<tr class="separator:a4581ada4d40d30156be2138d96209008"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bdfcbca5e48b3d517b9e450a06e9be1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_striped_set.html#a4bdfcbca5e48b3d517b9e450a06e9be1">clear</a> ()</td></tr>
<tr class="memdesc:a4bdfcbca5e48b3d517b9e450a06e9be1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the set.  <a href="#a4bdfcbca5e48b3d517b9e450a06e9be1">More...</a><br /></td></tr>
<tr class="separator:a4bdfcbca5e48b3d517b9e450a06e9be1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b79c0d6a40f53ba7db96555ab5680dc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_striped_set.html#a1b79c0d6a40f53ba7db96555ab5680dc">empty</a> () const </td></tr>
<tr class="memdesc:a1b79c0d6a40f53ba7db96555ab5680dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the set is empty.  <a href="#a1b79c0d6a40f53ba7db96555ab5680dc">More...</a><br /></td></tr>
<tr class="separator:a1b79c0d6a40f53ba7db96555ab5680dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2e178b0f136c087aeb2543162f4e134"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa2e178b0f136c087aeb2543162f4e134"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_striped_set.html#aa2e178b0f136c087aeb2543162f4e134">size</a> () const </td></tr>
<tr class="memdesc:aa2e178b0f136c087aeb2543162f4e134"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns item count in the set. <br /></td></tr>
<tr class="separator:aa2e178b0f136c087aeb2543162f4e134"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa84a8c4d24479a4a0a7f9bb843826f62"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_striped_set.html#aa84a8c4d24479a4a0a7f9bb843826f62">bucket_count</a> () const </td></tr>
<tr class="memdesc:aa84a8c4d24479a4a0a7f9bb843826f62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of hash table.  <a href="#aa84a8c4d24479a4a0a7f9bb843826f62">More...</a><br /></td></tr>
<tr class="separator:aa84a8c4d24479a4a0a7f9bb843826f62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0887399e0afc88882917adfa064a201b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0887399e0afc88882917adfa064a201b"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_striped_set.html#a0887399e0afc88882917adfa064a201b">lock_count</a> () const </td></tr>
<tr class="memdesc:a0887399e0afc88882917adfa064a201b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns lock array size. <br /></td></tr>
<tr class="separator:a0887399e0afc88882917adfa064a201b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28cf5f431dbb6c75f92ebad633c89c3d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a28cf5f431dbb6c75f92ebad633c89c3d"></a>
<a class="el" href="classcds_1_1container_1_1_striped_set.html#a132347759ae9e7929c5dc75a53890687">resizing_policy</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_striped_set.html#a28cf5f431dbb6c75f92ebad633c89c3d">get_resizing_policy</a> ()</td></tr>
<tr class="memdesc:a28cf5f431dbb6c75f92ebad633c89c3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns resizing policy object. <br /></td></tr>
<tr class="separator:a28cf5f431dbb6c75f92ebad633c89c3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a496636be80484deaf1ef07fac125bf13"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a496636be80484deaf1ef07fac125bf13"></a>
<a class="el" href="classcds_1_1container_1_1_striped_set.html#a132347759ae9e7929c5dc75a53890687">resizing_policy</a> const &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_striped_set.html#a496636be80484deaf1ef07fac125bf13">get_resizing_policy</a> () const </td></tr>
<tr class="memdesc:a496636be80484deaf1ef07fac125bf13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns resizing policy (const version) <br /></td></tr>
<tr class="separator:a496636be80484deaf1ef07fac125bf13"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_types_classcds_1_1intrusive_1_1_striped_set"><td colspan="2" onclick="javascript:toggleInherit('pro_types_classcds_1_1intrusive_1_1_striped_set')"><img src="closed.png" alt="-"/>&#160;Protected Types inherited from <a class="el" href="classcds_1_1intrusive_1_1_striped_set.html">cds::intrusive::StripedSet&lt; Container, Options... &gt;</a></td></tr>
<tr class="memitem:a30062f90ac31fe161c7cd4539fcaaf13 inherit pro_types_classcds_1_1intrusive_1_1_striped_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a30062f90ac31fe161c7cd4539fcaaf13"></a>
typedef Container&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#a30062f90ac31fe161c7cd4539fcaaf13">underlying_container_type</a></td></tr>
<tr class="memdesc:a30062f90ac31fe161c7cd4539fcaaf13 inherit pro_types_classcds_1_1intrusive_1_1_striped_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">original intrusive container type for the bucket <br /></td></tr>
<tr class="separator:a30062f90ac31fe161c7cd4539fcaaf13 inherit pro_types_classcds_1_1intrusive_1_1_striped_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0f7511b1b3c53680be6608678020bb5 inherit pro_types_classcds_1_1intrusive_1_1_striped_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac0f7511b1b3c53680be6608678020bb5"></a>
typedef <a class="el" href="classcds_1_1intrusive_1_1striped__set_1_1adapt.html">cds::intrusive::striped_set::adapt</a>&lt; <a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#a30062f90ac31fe161c7cd4539fcaaf13">underlying_container_type</a>, Options... &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#ac0f7511b1b3c53680be6608678020bb5">bucket_type</a></td></tr>
<tr class="memdesc:ac0f7511b1b3c53680be6608678020bb5 inherit pro_types_classcds_1_1intrusive_1_1_striped_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">container type adapted for hash set <br /></td></tr>
<tr class="separator:ac0f7511b1b3c53680be6608678020bb5 inherit pro_types_classcds_1_1intrusive_1_1_striped_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a999c16c7efc7a140c386cf8089d43f7b inherit pro_types_classcds_1_1intrusive_1_1_striped_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a999c16c7efc7a140c386cf8089d43f7b"></a>
typedef bucket_type::value_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#a999c16c7efc7a140c386cf8089d43f7b">value_type</a></td></tr>
<tr class="memdesc:a999c16c7efc7a140c386cf8089d43f7b inherit pro_types_classcds_1_1intrusive_1_1_striped_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">value type stored in the set <br /></td></tr>
<tr class="separator:a999c16c7efc7a140c386cf8089d43f7b inherit pro_types_classcds_1_1intrusive_1_1_striped_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b11af7149d2edcdcf89875dd82f29c3 inherit pro_types_classcds_1_1intrusive_1_1_striped_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3b11af7149d2edcdcf89875dd82f29c3"></a>
typedef options::hash&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#a3b11af7149d2edcdcf89875dd82f29c3">hash</a></td></tr>
<tr class="memdesc:a3b11af7149d2edcdcf89875dd82f29c3 inherit pro_types_classcds_1_1intrusive_1_1_striped_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hash functor. <br /></td></tr>
<tr class="separator:a3b11af7149d2edcdcf89875dd82f29c3 inherit pro_types_classcds_1_1intrusive_1_1_striped_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc27916ad8566742257adde4f5b0d36c inherit pro_types_classcds_1_1intrusive_1_1_striped_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abc27916ad8566742257adde4f5b0d36c"></a>
typedef options::item_counter&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#abc27916ad8566742257adde4f5b0d36c">item_counter</a></td></tr>
<tr class="memdesc:abc27916ad8566742257adde4f5b0d36c inherit pro_types_classcds_1_1intrusive_1_1_striped_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Item counter. <br /></td></tr>
<tr class="separator:abc27916ad8566742257adde4f5b0d36c inherit pro_types_classcds_1_1intrusive_1_1_striped_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73e9218d8f7724ddc07c1b41c8d91e7f inherit pro_types_classcds_1_1intrusive_1_1_striped_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a73e9218d8f7724ddc07c1b41c8d91e7f"></a>
typedef <a class="el" href="structcds_1_1opt_1_1select__default.html">cds::opt::select_default</a>&lt; typename options::resizing_policy, typename bucket_type::default_resizing_policy &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#a73e9218d8f7724ddc07c1b41c8d91e7f">resizing_policy</a></td></tr>
<tr class="memdesc:a73e9218d8f7724ddc07c1b41c8d91e7f inherit pro_types_classcds_1_1intrusive_1_1_striped_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resizing policy. <br /></td></tr>
<tr class="separator:a73e9218d8f7724ddc07c1b41c8d91e7f inherit pro_types_classcds_1_1intrusive_1_1_striped_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47cdc2d40853a651780c1a2afe7309ed inherit pro_types_classcds_1_1intrusive_1_1_striped_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a47cdc2d40853a651780c1a2afe7309ed"></a>
typedef options::allocator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#a47cdc2d40853a651780c1a2afe7309ed">allocator_type</a></td></tr>
<tr class="memdesc:a47cdc2d40853a651780c1a2afe7309ed inherit pro_types_classcds_1_1intrusive_1_1_striped_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">allocator type specified in options. <br /></td></tr>
<tr class="separator:a47cdc2d40853a651780c1a2afe7309ed inherit pro_types_classcds_1_1intrusive_1_1_striped_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af672d590a91e09833aa27621f7e35c26 inherit pro_types_classcds_1_1intrusive_1_1_striped_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af672d590a91e09833aa27621f7e35c26"></a>
typedef options::mutex_policy&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#af672d590a91e09833aa27621f7e35c26">mutex_policy</a></td></tr>
<tr class="memdesc:af672d590a91e09833aa27621f7e35c26 inherit pro_types_classcds_1_1intrusive_1_1_striped_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mutex policy. <br /></td></tr>
<tr class="separator:af672d590a91e09833aa27621f7e35c26 inherit pro_types_classcds_1_1intrusive_1_1_striped_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7217f5fc38b03f908957969c227dc28 inherit pro_types_classcds_1_1intrusive_1_1_striped_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad7217f5fc38b03f908957969c227dc28"></a>
typedef <a class="el" href="classcds_1_1details_1_1_allocator.html">cds::details::Allocator</a>&lt; <a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#ac0f7511b1b3c53680be6608678020bb5">bucket_type</a>, <a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#a47cdc2d40853a651780c1a2afe7309ed">allocator_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#ad7217f5fc38b03f908957969c227dc28">bucket_allocator</a></td></tr>
<tr class="memdesc:ad7217f5fc38b03f908957969c227dc28 inherit pro_types_classcds_1_1intrusive_1_1_striped_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">bucket allocator type based on allocator_type <br /></td></tr>
<tr class="separator:ad7217f5fc38b03f908957969c227dc28 inherit pro_types_classcds_1_1intrusive_1_1_striped_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classcds_1_1intrusive_1_1_striped_set"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classcds_1_1intrusive_1_1_striped_set')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classcds_1_1intrusive_1_1_striped_set.html">cds::intrusive::StripedSet&lt; Container, Options... &gt;</a></td></tr>
<tr class="memitem:a8c4b97b427950b0b119e6314337611a6 inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8c4b97b427950b0b119e6314337611a6"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#a8c4b97b427950b0b119e6314337611a6">StripedSet</a> ()</td></tr>
<tr class="memdesc:a8c4b97b427950b0b119e6314337611a6 inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default ctor. The initial capacity is 16. <br /></td></tr>
<tr class="separator:a8c4b97b427950b0b119e6314337611a6 inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a8ca33aa2ce383440759a0cf0a177e1 inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#a1a8ca33aa2ce383440759a0cf0a177e1">StripedSet</a> (size_t nCapacity)</td></tr>
<tr class="memdesc:a1a8ca33aa2ce383440759a0cf0a177e1 inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ctor with initial capacity specified.  <a href="#a1a8ca33aa2ce383440759a0cf0a177e1">More...</a><br /></td></tr>
<tr class="separator:a1a8ca33aa2ce383440759a0cf0a177e1 inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab742138d7bfcfb5ad100bff319baac1a inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#ab742138d7bfcfb5ad100bff319baac1a">StripedSet</a> (size_t nCapacity, <a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#a73e9218d8f7724ddc07c1b41c8d91e7f">resizing_policy</a> const &amp;resizingPolicy)</td></tr>
<tr class="memdesc:ab742138d7bfcfb5ad100bff319baac1a inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ctor with resizing policy (copy semantics)  <a href="#ab742138d7bfcfb5ad100bff319baac1a">More...</a><br /></td></tr>
<tr class="separator:ab742138d7bfcfb5ad100bff319baac1a inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f6cceace08ecb8ccae4c1c0c7841f88 inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#a9f6cceace08ecb8ccae4c1c0c7841f88">StripedSet</a> (size_t nCapacity, <a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#a73e9218d8f7724ddc07c1b41c8d91e7f">resizing_policy</a> &amp;&amp;resizingPolicy)</td></tr>
<tr class="memdesc:a9f6cceace08ecb8ccae4c1c0c7841f88 inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ctor with resizing policy (move semantics)  <a href="#a9f6cceace08ecb8ccae4c1c0c7841f88">More...</a><br /></td></tr>
<tr class="separator:a9f6cceace08ecb8ccae4c1c0c7841f88 inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a723409ba0e656ba3bbd54d41356ec710 inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a723409ba0e656ba3bbd54d41356ec710"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#a723409ba0e656ba3bbd54d41356ec710">~StripedSet</a> ()</td></tr>
<tr class="memdesc:a723409ba0e656ba3bbd54d41356ec710 inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor destroys internal data. <br /></td></tr>
<tr class="separator:a723409ba0e656ba3bbd54d41356ec710 inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9596e3aea5464a77437d6d8cdfc288f5 inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#a9596e3aea5464a77437d6d8cdfc288f5">insert</a> (<a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#a999c16c7efc7a140c386cf8089d43f7b">value_type</a> &amp;val)</td></tr>
<tr class="memdesc:a9596e3aea5464a77437d6d8cdfc288f5 inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new node.  <a href="#a9596e3aea5464a77437d6d8cdfc288f5">More...</a><br /></td></tr>
<tr class="separator:a9596e3aea5464a77437d6d8cdfc288f5 inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e8e96d52afa3d2c265c269af1a1ba3c inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#a4e8e96d52afa3d2c265c269af1a1ba3c">insert</a> (<a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#a999c16c7efc7a140c386cf8089d43f7b">value_type</a> &amp;val, Func f)</td></tr>
<tr class="memdesc:a4e8e96d52afa3d2c265c269af1a1ba3c inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new node.  <a href="#a4e8e96d52afa3d2c265c269af1a1ba3c">More...</a><br /></td></tr>
<tr class="separator:a4e8e96d52afa3d2c265c269af1a1ba3c inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a432eb9fc2f0cf92fcf3a3b22ef6d8510 inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="memItemLeft" align="right" valign="top">std::pair&lt; bool, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#a432eb9fc2f0cf92fcf3a3b22ef6d8510">update</a> (<a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#a999c16c7efc7a140c386cf8089d43f7b">value_type</a> &amp;val, Func func, bool bAllowInsert=true)</td></tr>
<tr class="memdesc:a432eb9fc2f0cf92fcf3a3b22ef6d8510 inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the node.  <a href="#a432eb9fc2f0cf92fcf3a3b22ef6d8510">More...</a><br /></td></tr>
<tr class="separator:a432eb9fc2f0cf92fcf3a3b22ef6d8510 inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbc4dd64160d03646b1f7c163f95369e inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#adbc4dd64160d03646b1f7c163f95369e">unlink</a> (<a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#a999c16c7efc7a140c386cf8089d43f7b">value_type</a> &amp;val)</td></tr>
<tr class="memdesc:adbc4dd64160d03646b1f7c163f95369e inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlink the item <code>val</code> from the set.  <a href="#adbc4dd64160d03646b1f7c163f95369e">More...</a><br /></td></tr>
<tr class="separator:adbc4dd64160d03646b1f7c163f95369e inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93f0b317f12dd1db7b57ac7f9c4c68b2 inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#a999c16c7efc7a140c386cf8089d43f7b">value_type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#a93f0b317f12dd1db7b57ac7f9c4c68b2">erase</a> (Q const &amp;val)</td></tr>
<tr class="memdesc:a93f0b317f12dd1db7b57ac7f9c4c68b2 inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the item from the set.  <a href="#a93f0b317f12dd1db7b57ac7f9c4c68b2">More...</a><br /></td></tr>
<tr class="separator:a93f0b317f12dd1db7b57ac7f9c4c68b2 inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d0800c569994d8548264435b032b1e6 inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#a999c16c7efc7a140c386cf8089d43f7b">value_type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#a4d0800c569994d8548264435b032b1e6">erase</a> (Q const &amp;val, Func f)</td></tr>
<tr class="memdesc:a4d0800c569994d8548264435b032b1e6 inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the item from the set.  <a href="#a4d0800c569994d8548264435b032b1e6">More...</a><br /></td></tr>
<tr class="separator:a4d0800c569994d8548264435b032b1e6 inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f556ecd285484def76ab232f515e2af inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#a999c16c7efc7a140c386cf8089d43f7b">value_type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#a2f556ecd285484def76ab232f515e2af">erase_with</a> (Q const &amp;val, Less pred)</td></tr>
<tr class="memdesc:a2f556ecd285484def76ab232f515e2af inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the item from the set using <code>pred</code> predicate for searching.  <a href="#a2f556ecd285484def76ab232f515e2af">More...</a><br /></td></tr>
<tr class="separator:a2f556ecd285484def76ab232f515e2af inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae449671e2a1b7bfda93312d17b2a85cd inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#a999c16c7efc7a140c386cf8089d43f7b">value_type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#ae449671e2a1b7bfda93312d17b2a85cd">erase_with</a> (Q const &amp;val, Less pred, Func f)</td></tr>
<tr class="memdesc:ae449671e2a1b7bfda93312d17b2a85cd inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the item from the set using <code>pred</code> predicate for searching.  <a href="#ae449671e2a1b7bfda93312d17b2a85cd">More...</a><br /></td></tr>
<tr class="separator:ae449671e2a1b7bfda93312d17b2a85cd inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af54fb6ea73d499f07611f75973244685 inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#af54fb6ea73d499f07611f75973244685">find</a> (Q &amp;val, Func f)</td></tr>
<tr class="memdesc:af54fb6ea73d499f07611f75973244685 inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the key <code>val</code>.  <a href="#af54fb6ea73d499f07611f75973244685">More...</a><br /></td></tr>
<tr class="separator:af54fb6ea73d499f07611f75973244685 inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d1c82507b338a1f5e835117652f48d2 inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#a1d1c82507b338a1f5e835117652f48d2">find</a> (Q const &amp;val, Func f)</td></tr>
<tr class="memdesc:a1d1c82507b338a1f5e835117652f48d2 inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the key <code>val</code>.  <a href="#a1d1c82507b338a1f5e835117652f48d2">More...</a><br /></td></tr>
<tr class="separator:a1d1c82507b338a1f5e835117652f48d2 inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af47d38de7746c0701b794c02d7cc79bd inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#af47d38de7746c0701b794c02d7cc79bd">find_with</a> (Q &amp;val, Less pred, Func f)</td></tr>
<tr class="memdesc:af47d38de7746c0701b794c02d7cc79bd inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the key <code>val</code> using <code>pred</code> predicate.  <a href="#af47d38de7746c0701b794c02d7cc79bd">More...</a><br /></td></tr>
<tr class="separator:af47d38de7746c0701b794c02d7cc79bd inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4947957c41d99bd6d75ce5b04a975bf5 inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#a4947957c41d99bd6d75ce5b04a975bf5">find_with</a> (Q const &amp;val, Less pred, Func f)</td></tr>
<tr class="memdesc:a4947957c41d99bd6d75ce5b04a975bf5 inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the key <code>val</code> using <code>pred</code> predicate.  <a href="#a4947957c41d99bd6d75ce5b04a975bf5">More...</a><br /></td></tr>
<tr class="separator:a4947957c41d99bd6d75ce5b04a975bf5 inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e681eacb6163d341cacf39607e1471c inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#a5e681eacb6163d341cacf39607e1471c">contains</a> (Q const &amp;key)</td></tr>
<tr class="memdesc:a5e681eacb6163d341cacf39607e1471c inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the set contains <code>key</code>.  <a href="#a5e681eacb6163d341cacf39607e1471c">More...</a><br /></td></tr>
<tr class="separator:a5e681eacb6163d341cacf39607e1471c inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeec51f0495dce5375e33dbdad5129488 inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#aeec51f0495dce5375e33dbdad5129488">contains</a> (Q const &amp;key, Less pred)</td></tr>
<tr class="memdesc:aeec51f0495dce5375e33dbdad5129488 inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the set contains <code>key</code> using <code>pred</code> predicate for searching.  <a href="#aeec51f0495dce5375e33dbdad5129488">More...</a><br /></td></tr>
<tr class="separator:aeec51f0495dce5375e33dbdad5129488 inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c5b7ec995eb6c9ab0de511b4848c356 inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#a8c5b7ec995eb6c9ab0de511b4848c356">clear</a> ()</td></tr>
<tr class="memdesc:a8c5b7ec995eb6c9ab0de511b4848c356 inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the set.  <a href="#a8c5b7ec995eb6c9ab0de511b4848c356">More...</a><br /></td></tr>
<tr class="separator:a8c5b7ec995eb6c9ab0de511b4848c356 inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a922615dc212b034f6946253747c92567 inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#a922615dc212b034f6946253747c92567">clear_and_dispose</a> (Disposer disposer)</td></tr>
<tr class="memdesc:a922615dc212b034f6946253747c92567 inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the set and calls <code>disposer</code> for each item.  <a href="#a922615dc212b034f6946253747c92567">More...</a><br /></td></tr>
<tr class="separator:a922615dc212b034f6946253747c92567 inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb5f9adf6fbe7822d3e00454b0ed44af inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#abb5f9adf6fbe7822d3e00454b0ed44af">empty</a> () const</td></tr>
<tr class="memdesc:abb5f9adf6fbe7822d3e00454b0ed44af inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the set is empty.  <a href="#abb5f9adf6fbe7822d3e00454b0ed44af">More...</a><br /></td></tr>
<tr class="separator:abb5f9adf6fbe7822d3e00454b0ed44af inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a354fc053c00d03040f9390f5cb472cdb inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a354fc053c00d03040f9390f5cb472cdb"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#a354fc053c00d03040f9390f5cb472cdb">size</a> () const</td></tr>
<tr class="memdesc:a354fc053c00d03040f9390f5cb472cdb inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns item count in the set. <br /></td></tr>
<tr class="separator:a354fc053c00d03040f9390f5cb472cdb inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3eb93bedca5734685f3564c15b8d5a57 inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#a3eb93bedca5734685f3564c15b8d5a57">bucket_count</a> () const</td></tr>
<tr class="memdesc:a3eb93bedca5734685f3564c15b8d5a57 inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of hash table.  <a href="#a3eb93bedca5734685f3564c15b8d5a57">More...</a><br /></td></tr>
<tr class="separator:a3eb93bedca5734685f3564c15b8d5a57 inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a440c7cfed101aedb28eb89d37e760cf7 inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a440c7cfed101aedb28eb89d37e760cf7"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#a440c7cfed101aedb28eb89d37e760cf7">lock_count</a> () const</td></tr>
<tr class="memdesc:a440c7cfed101aedb28eb89d37e760cf7 inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns lock array size. <br /></td></tr>
<tr class="separator:a440c7cfed101aedb28eb89d37e760cf7 inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeecf47c14957c54d2286e1780ac05191 inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aeecf47c14957c54d2286e1780ac05191"></a>
<a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#a73e9218d8f7724ddc07c1b41c8d91e7f">resizing_policy</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#aeecf47c14957c54d2286e1780ac05191">get_resizing_policy</a> ()</td></tr>
<tr class="memdesc:aeecf47c14957c54d2286e1780ac05191 inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns resizing policy object. <br /></td></tr>
<tr class="separator:aeecf47c14957c54d2286e1780ac05191 inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf9a811bafc54d916c11dea45a0332ea inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acf9a811bafc54d916c11dea45a0332ea"></a>
<a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#a73e9218d8f7724ddc07c1b41c8d91e7f">resizing_policy</a> const &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#acf9a811bafc54d916c11dea45a0332ea">get_resizing_policy</a> () const</td></tr>
<tr class="memdesc:acf9a811bafc54d916c11dea45a0332ea inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns resizing policy (const version) <br /></td></tr>
<tr class="separator:acf9a811bafc54d916c11dea45a0332ea inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_classcds_1_1intrusive_1_1_striped_set"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classcds_1_1intrusive_1_1_striped_set')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classcds_1_1intrusive_1_1_striped_set.html">cds::intrusive::StripedSet&lt; Container, Options... &gt;</a></td></tr>
<tr class="memitem:aa37baad9eed29bf24f0ddf890e0d01e8 inherit pro_attribs_classcds_1_1intrusive_1_1_striped_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa37baad9eed29bf24f0ddf890e0d01e8"></a>
<a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#ac0f7511b1b3c53680be6608678020bb5">bucket_type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#aa37baad9eed29bf24f0ddf890e0d01e8">m_Buckets</a></td></tr>
<tr class="memdesc:aa37baad9eed29bf24f0ddf890e0d01e8 inherit pro_attribs_classcds_1_1intrusive_1_1_striped_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bucket table. <br /></td></tr>
<tr class="separator:aa37baad9eed29bf24f0ddf890e0d01e8 inherit pro_attribs_classcds_1_1intrusive_1_1_striped_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ce4bd75c1b37fc12b1d5ea2ae0da65e inherit pro_attribs_classcds_1_1intrusive_1_1_striped_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1ce4bd75c1b37fc12b1d5ea2ae0da65e"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#a1ce4bd75c1b37fc12b1d5ea2ae0da65e">m_nBucketMask</a></td></tr>
<tr class="memdesc:a1ce4bd75c1b37fc12b1d5ea2ae0da65e inherit pro_attribs_classcds_1_1intrusive_1_1_striped_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bucket table size - 1. m_nBucketMask + 1 should be power of two. <br /></td></tr>
<tr class="separator:a1ce4bd75c1b37fc12b1d5ea2ae0da65e inherit pro_attribs_classcds_1_1intrusive_1_1_striped_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1657b63e8f07fd22c313304f2d3ca0c5 inherit pro_attribs_classcds_1_1intrusive_1_1_striped_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1657b63e8f07fd22c313304f2d3ca0c5"></a>
<a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#abc27916ad8566742257adde4f5b0d36c">item_counter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#a1657b63e8f07fd22c313304f2d3ca0c5">m_ItemCounter</a></td></tr>
<tr class="memdesc:a1657b63e8f07fd22c313304f2d3ca0c5 inherit pro_attribs_classcds_1_1intrusive_1_1_striped_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Item counter. <br /></td></tr>
<tr class="separator:a1657b63e8f07fd22c313304f2d3ca0c5 inherit pro_attribs_classcds_1_1intrusive_1_1_striped_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13b44bfb69b63d39d2a966b416736716 inherit pro_attribs_classcds_1_1intrusive_1_1_striped_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a13b44bfb69b63d39d2a966b416736716"></a>
<a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#a3b11af7149d2edcdcf89875dd82f29c3">hash</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#a13b44bfb69b63d39d2a966b416736716">m_Hash</a></td></tr>
<tr class="memdesc:a13b44bfb69b63d39d2a966b416736716 inherit pro_attribs_classcds_1_1intrusive_1_1_striped_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hash functor. <br /></td></tr>
<tr class="separator:a13b44bfb69b63d39d2a966b416736716 inherit pro_attribs_classcds_1_1intrusive_1_1_striped_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a104ff1225ca65268f90dd235698e6f36 inherit pro_attribs_classcds_1_1intrusive_1_1_striped_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a104ff1225ca65268f90dd235698e6f36"></a>
<a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#af672d590a91e09833aa27621f7e35c26">mutex_policy</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#a104ff1225ca65268f90dd235698e6f36">m_MutexPolicy</a></td></tr>
<tr class="memdesc:a104ff1225ca65268f90dd235698e6f36 inherit pro_attribs_classcds_1_1intrusive_1_1_striped_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mutex policy. <br /></td></tr>
<tr class="separator:a104ff1225ca65268f90dd235698e6f36 inherit pro_attribs_classcds_1_1intrusive_1_1_striped_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6a40adaba75040b3646fab1ad4bc133 inherit pro_attribs_classcds_1_1intrusive_1_1_striped_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab6a40adaba75040b3646fab1ad4bc133"></a>
<a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#a73e9218d8f7724ddc07c1b41c8d91e7f">resizing_policy</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#ab6a40adaba75040b3646fab1ad4bc133">m_ResizingPolicy</a></td></tr>
<tr class="memdesc:ab6a40adaba75040b3646fab1ad4bc133 inherit pro_attribs_classcds_1_1intrusive_1_1_striped_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resizing policy. <br /></td></tr>
<tr class="separator:ab6a40adaba75040b3646fab1ad4bc133 inherit pro_attribs_classcds_1_1intrusive_1_1_striped_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_static_attribs_classcds_1_1intrusive_1_1_striped_set"><td colspan="2" onclick="javascript:toggleInherit('pro_static_attribs_classcds_1_1intrusive_1_1_striped_set')"><img src="closed.png" alt="-"/>&#160;Static Protected Attributes inherited from <a class="el" href="classcds_1_1intrusive_1_1_striped_set.html">cds::intrusive::StripedSet&lt; Container, Options... &gt;</a></td></tr>
<tr class="memitem:acd3aab8a3065331de1f6ad410fa94d7f inherit pro_static_attribs_classcds_1_1intrusive_1_1_striped_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acd3aab8a3065331de1f6ad410fa94d7f"></a>
static const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#acd3aab8a3065331de1f6ad410fa94d7f">c_nMinimalCapacity</a></td></tr>
<tr class="memdesc:acd3aab8a3065331de1f6ad410fa94d7f inherit pro_static_attribs_classcds_1_1intrusive_1_1_striped_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimal capacity. <br /></td></tr>
<tr class="separator:acd3aab8a3065331de1f6ad410fa94d7f inherit pro_static_attribs_classcds_1_1intrusive_1_1_striped_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class Container, typename... Options&gt;<br />
class cds::container::StripedSet&lt; Container, Options &gt;</h3>

<p>Striped hash set. </p>
<p>Source</p><ul>
<li>[2008] Maurice Herlihy, Nir Shavit "The Art of Multiprocessor Programming"</li>
</ul>
<p>Lock striping is very simple technique. The set consists of the bucket table and the array of locks. Initially, the capacity of lock array and bucket table is the same. When set is resized, bucket table capacity will be doubled but lock array will not. The lock <code>i</code> protects each bucket <code>j</code>, where <code> j = i mod L </code>, where <code>L</code> - the size of lock array.</p>
<p>Template arguments:</p><ul>
<li><code>Container</code> - the container class that is used as bucket table entry. The <code>Container</code> class should support an uniform interface described below.</li>
<li><code>Options</code> - options</li>
</ul>
<p>The <code>StripedSet</code> class does not exactly dictate the type of container that should be used as a <code>Container</code> bucket. Instead, the class supports different container type for the bucket, for exampe, <code>std::list</code>, <code>std::set</code> and others.</p>
<p>Remember that <code>StripedSet</code> class algorithm ensures sequential blocking access to its bucket through the mutex type you specify among <code>Options</code> template arguments.</p>
<p>The <code>Options</code> are:</p><ul>
<li><code><a class="el" href="structcds_1_1opt_1_1mutex__policy.html" title="[type-option] Concurrent access policy ">opt::mutex_policy</a></code> - concurrent access policy. Available policies: <code><a class="el" href="classcds_1_1intrusive_1_1striped__set_1_1striping.html" title="Lock striping concurrent access policy. ">intrusive::striped_set::striping</a></code>, <code><a class="el" href="classcds_1_1intrusive_1_1striped__set_1_1refinable.html" title="Refinable concurrent access policy. ">intrusive::striped_set::refinable</a></code>. Default is <code>striped_set::striping</code>.</li>
<li><code><a class="el" href="structcds_1_1opt_1_1hash.html" title="[type-option] Option setter for a hash function ">opt::hash</a></code> - hash functor. Default option value see <code>opt::v::hash_selector&lt;opt::none&gt; </code> which selects default hash functor for your compiler.</li>
<li><code><a class="el" href="structcds_1_1opt_1_1compare.html" title="[type-option] Option setter for key comparing ">opt::compare</a></code> - key comparison functor. No default functor is provided. If the option is not specified, the <code>opt::less</code> is used.</li>
<li><code><a class="el" href="structcds_1_1opt_1_1less.html" title="[type-option] Option setter for less predicate ">opt::less</a></code> - specifies binary predicate used for key comparison. Default is <code>std::less&lt;T&gt;</code>.</li>
<li><code><a class="el" href="structcds_1_1opt_1_1item__counter.html" title="[type-option] Option setter for item counting ">opt::item_counter</a></code> - item counter type. Default is <code><a class="el" href="classcds_1_1atomicity_1_1item__counter.html" title="Atomic item counter. ">atomicity::item_counter</a></code> since some operation on the counter is performed without locks. Note that item counting is an essential part of the set algorithm, so dummy counter like as <code><a class="el" href="classcds_1_1atomicity_1_1empty__item__counter.html" title="Empty item counter. ">atomicity::empty_item_counter</a></code> is not suitable.</li>
<li><code><a class="el" href="structcds_1_1opt_1_1allocator.html" title="[type-option] Option setter for an allocator ">opt::allocator</a></code> - the allocator type using for memory allocation of bucket table and lock array. Default is <a class="el" href="user__setup_2allocator_8h.html#ad5fb7e3cbe8cf24295f0ea3c165a2d82">CDS_DEFAULT_ALLOCATOR</a>.</li>
<li><code><a class="el" href="structcds_1_1opt_1_1resizing__policy.html" title="Resizing policy option. ">opt::resizing_policy</a></code> - the resizing policy that is a functor that decides when to resize the hash set. Default option value depends on bucket container type: for sequential containers like <code>std::list</code>, <code>std::vector</code> the resizing policy is <code><a class="el" href="namespacecds_1_1container_1_1striped__set.html#a0a7761cda5122caa1ea5f22ac7182e65" title="Load factor based resizing policy. ">striped_set::load_factor_resizing&lt;4&gt;</a> </code>; for other type of containers like <code>std::set</code>, <code>std::unordered_set</code> the resizing policy is <code><a class="el" href="namespacecds_1_1container_1_1striped__set.html#a1a6926eacdbf9fb4fc264d6d85d353c2" title="Dummy resizing policy. ">striped_set::no_resizing</a></code>. See <a class="el" href="group__cds__striped__resizing__policy.html">available resizing policy</a>. Note that the choose of resizing policy depends of <code>Container</code> type: for sequential containers like <code>std::list</code>, <code>std::vector</code> and so on, right choosing of the policy can significantly improve performance. For other, non-sequential types of <code>Container</code> (like a <code>std::set</code>) the resizing policy is not so important.</li>
<li><code><a class="el" href="structcds_1_1opt_1_1copy__policy.html" title="Copy policy option. ">opt::copy_policy</a></code> - the copy policy which is used to copy items from the old set to the new one when resizing. The policy can be optionally used in adapted bucket container for performance reasons of resizing. The detail of copy algorithm depends on type of bucket container and explains below.</li>
</ul>
<p><code>opt::compare</code> or <code>opt::less</code> options are used in some <code>Container</code> class for searching an item. <code>opt::compare</code> option has the highest priority: if <code>opt::compare</code> is specified, <code>opt::less</code> is not used.</p>
<p>You can pass other option that would be passed to <code>adapt</code> metafunction, see below.</p>
<p><b>Internal details</b></p>
<p>The <code>StripedSet</code> class cannot utilize the <code>Container</code> container specified directly, but only its adapted variant which supports an unified interface. Internally, the adaptation is made via <a class="el" href="classcds_1_1container_1_1striped__set_1_1adapt.html" title="Default adapter for hash set. ">striped_set::adapt</a> metafunction that wraps bucket container and provides the unified bucket interface suitable for <code>StripedSet</code>. Such adaptation is completely transparent for you - you don't need to call <code>adapt</code> metafunction directly, <code>StripedSet</code> class's internal machinery itself invokes appropriate <code>adapt</code> metafunction to adjust your <code>Container</code> container class to <code>StripedSet</code> bucket's internal interface. All you need is to include a right header before <code>striped_hash_set.h</code>.</p>
<p>By default, <code>striped_set::adapt&lt;AnyContainer, Options...&gt; </code> metafunction does not make any wrapping to <code>AnyContainer</code>, so, the result <code><a class="el" href="classcds_1_1container_1_1striped__set_1_1adapt.html#a23593acb49868d12286d076f61cd45cf" title="adapted container type ">striped_set::adapt&lt;AnyContainer, Options...&gt;::type</a> </code> is the same as <code>AnyContainer</code>. However, there are a lot of specializations of <code><a class="el" href="classcds_1_1container_1_1striped__set_1_1adapt.html" title="Default adapter for hash set. ">striped_set::adapt</a></code> for well-known containers, see table below. Any of this specialization wraps corresponding container making it suitable for the set's bucket. Remember, you should include the proper header file for <code>adapt</code> <b>before</b> including <code>striped_hash_set.h</code>. </p><table class="doxtable">
<tr>
<th>Container </th><th>.h-file for <code>adapt</code>  </th><th>Example </th><th>Notes  </th></tr>
<tr>
<td><code>std::list</code>  </td><td><code>&lt;cds/container/striped_set/std_list.h&gt;</code> </td><td><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;cds/container/striped_set/std_list.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;cds/container/striped_hash_set.h&gt;</span></div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="classcds_1_1container_1_1_striped_set.html">cds::container::StripedSet</a>&lt;</div>
<div class="line">    std::list&lt;T&gt;,</div>
<div class="line">    <a class="code" href="structcds_1_1opt_1_1less.html">cds::opt::less&lt; std::less&lt;T&gt;</a> &gt;</div>
<div class="line">&gt; striped_set;</div>
</div><!-- fragment -->  </td><td>The list is ordered. Template argument pack <code>Options</code> <b>must</b> contain <a class="el" href="structcds_1_1opt_1_1less.html" title="[type-option] Option setter for less predicate ">cds::opt::less</a> or <a class="el" href="structcds_1_1opt_1_1compare.html" title="[type-option] Option setter for key comparing ">cds::opt::compare</a> for type <code>T</code> stored in the list   </td></tr>
<tr>
<td><code>std::vector</code>  </td><td><code>&lt;cds/container/striped_set/std_vector.h&gt;</code> </td><td><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;cds/container/striped_set/std_vector.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;cds/container/striped_hash_set.h&gt;</span></div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="classcds_1_1container_1_1_striped_set.html">cds::container::StripedSet</a>&lt;</div>
<div class="line">    std::vector&lt;T&gt;,</div>
<div class="line">    <a class="code" href="structcds_1_1opt_1_1less.html">cds::opt::less&lt; std::less&lt;T&gt;</a> &gt;</div>
<div class="line">&gt; striped_set;</div>
</div><!-- fragment -->  </td><td>The vector is ordered. Template argument pack <code>Options</code> <b>must</b> contain <code><a class="el" href="structcds_1_1opt_1_1less.html" title="[type-option] Option setter for less predicate ">cds::opt::less</a></code> or <code><a class="el" href="structcds_1_1opt_1_1compare.html" title="[type-option] Option setter for key comparing ">cds::opt::compare</a></code> for type <code>T</code> stored in the list   </td></tr>
<tr>
<td><code>std::set</code>  </td><td><code>&lt;cds/container/striped_set/std_set.h&gt;</code> </td><td><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;cds/container/striped_set/std_set.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;cds/container/striped_hash_set.h&gt;</span></div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="classcds_1_1container_1_1_striped_set.html">cds::container::StripedSet</a>&lt;</div>
<div class="line">    std::set&lt; T, std::less&lt;T&gt; &gt;</div>
<div class="line">&gt; striped_set;</div>
</div><!-- fragment -->  </td><td></td></tr>
<tr>
<td><code>std::unordered_set</code>  </td><td><code>&lt;cds/container/striped_set/std_hash_set.h&gt;</code> </td><td><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;cds/container/striped_set/std_hash_set.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;cds/container/striped_hash_set.h&gt;</span></div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="classcds_1_1container_1_1_striped_set.html">cds::container::StripedSet</a>&lt;</div>
<div class="line">    std::unordered_set&lt;</div>
<div class="line">        T,</div>
<div class="line">        hash&lt;T&gt;,</div>
<div class="line">        equal&lt;T&gt;</div>
<div class="line">    &gt;</div>
<div class="line">&gt; striped_set;</div>
</div><!-- fragment -->  </td><td>You should provide two different hash function <code>h1</code> and <code>h2</code> - one for <code>std::unordered_set</code> and other for <code>StripedSet</code>. For the best result, <code>h1</code> and <code>h2</code> must be orthogonal i.e. <code> h1(X) != h2(X) </code> for any value <code>X</code>.   </td></tr>
<tr>
<td><code>boost::container::slist</code>  </td><td><code>&lt;cds/container/striped_set/boost_slist.h&gt;</code> </td><td><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;cds/container/striped_set/boost_slist.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;cds/container/striped_hash_set.h&gt;</span></div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="classcds_1_1container_1_1_striped_set.html">cds::container::StripedSet</a>&lt;</div>
<div class="line">    boost::container::slist&lt;T&gt;</div>
<div class="line">&gt; striped_set;</div>
</div><!-- fragment -->  </td><td>The list is ordered. <code>Options</code> <b>must</b> contain <code><a class="el" href="structcds_1_1opt_1_1less.html" title="[type-option] Option setter for less predicate ">cds::opt::less</a></code> or <code><a class="el" href="structcds_1_1opt_1_1compare.html" title="[type-option] Option setter for key comparing ">cds::opt::compare</a></code>.   </td></tr>
<tr>
<td><code>boost::container::list</code>  </td><td><code>&lt;cds/container/striped_set/boost_list.h&gt;</code> </td><td><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;cds/container/striped_set/boost_list.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;cds/container/striped_hash_set.h&gt;</span></div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="classcds_1_1container_1_1_striped_set.html">cds::container::StripedSet</a>&lt;</div>
<div class="line">    boost::container::list&lt;T&gt;</div>
<div class="line">&gt; striped_set;</div>
</div><!-- fragment -->  </td><td>The list is ordered. <code>Options</code> <b>must</b> contain <code><a class="el" href="structcds_1_1opt_1_1less.html" title="[type-option] Option setter for less predicate ">cds::opt::less</a></code> or <code><a class="el" href="structcds_1_1opt_1_1compare.html" title="[type-option] Option setter for key comparing ">cds::opt::compare</a></code>.   </td></tr>
<tr>
<td><code>boost::container::vector</code>  </td><td><code>&lt;cds/container/striped_set/boost_vector.h&gt;</code> </td><td><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;cds/container/striped_set/boost_vector.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;cds/container/striped_hash_set.h&gt;</span></div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="classcds_1_1container_1_1_striped_set.html">cds::container::StripedSet</a>&lt;</div>
<div class="line">    boost::container::vector&lt;T&gt;,</div>
<div class="line">    <a class="code" href="structcds_1_1opt_1_1less.html">cds::opt::less&lt; std::less&lt;T&gt;</a> &gt;</div>
<div class="line">&gt; striped_set;</div>
</div><!-- fragment -->  </td><td>The vector is ordered. Template argument pack <code>Options</code> <b>must</b> contain <code><a class="el" href="structcds_1_1opt_1_1less.html" title="[type-option] Option setter for less predicate ">cds::opt::less</a></code> or <code><a class="el" href="structcds_1_1opt_1_1compare.html" title="[type-option] Option setter for key comparing ">cds::opt::compare</a></code> for type <code>T</code> stored in the vector   </td></tr>
<tr>
<td><code>boost::container::stable_vector</code>  </td><td><code>&lt;cds/container/striped_set/boost_stable_vector.h&gt;</code> </td><td><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;cds/container/striped_set/boost_stable_vector.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;cds/container/striped_hash_set.h&gt;</span></div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="classcds_1_1container_1_1_striped_set.html">cds::container::StripedSet</a>&lt;</div>
<div class="line">    boost::container::stable_vector&lt;T&gt;,</div>
<div class="line">    <a class="code" href="structcds_1_1opt_1_1less.html">cds::opt::less&lt; std::less&lt;T&gt;</a> &gt;</div>
<div class="line">&gt; striped_set;</div>
</div><!-- fragment -->  </td><td>The vector is ordered. Template argument pack <code>Options</code> <b>must</b> contain <code><a class="el" href="structcds_1_1opt_1_1less.html" title="[type-option] Option setter for less predicate ">cds::opt::less</a></code> or <code><a class="el" href="structcds_1_1opt_1_1compare.html" title="[type-option] Option setter for key comparing ">cds::opt::compare</a></code> for type <code>T</code> stored in the vector   </td></tr>
<tr>
<td><code>boost::container::set</code>  </td><td><code>&lt;cds/container/striped_set/boost_set.h&gt;</code> </td><td><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;cds/container/striped_set/boost_set.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;cds/container/striped_hash_set.h&gt;</span></div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="classcds_1_1container_1_1_striped_set.html">cds::container::StripedSet</a>&lt;</div>
<div class="line">    boost::container::set&lt; T, std::less&lt;T&gt; &gt;</div>
<div class="line">&gt; striped_set;</div>
</div><!-- fragment -->  </td><td></td></tr>
<tr>
<td><code>boost::container::flat_set</code>  </td><td><code>&lt;cds/container/striped_set/boost_flat_set.h&gt;</code> </td><td><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;cds/container/striped_set/boost_flat_set.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;cds/container/striped_hash_set.h&gt;</span></div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="classcds_1_1container_1_1_striped_set.html">cds::container::StripedSet</a>&lt;</div>
<div class="line">    boost::container::flat_set&lt; T, std::less&lt;T&gt; &gt;</div>
<div class="line">&gt; striped_set;</div>
</div><!-- fragment -->  </td><td></td></tr>
<tr>
<td><code>boost::unordered_set</code>  </td><td><code>&lt;cds/container/striped_set/boost_unordered_set.h&gt;</code> </td><td><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;cds/container/striped_set/boost_unordered_set.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;cds/container/striped_hash_set.h&gt;</span></div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="classcds_1_1container_1_1_striped_set.html">cds::container::StripedSet</a>&lt;</div>
<div class="line">    boost::unordered_set&lt;</div>
<div class="line">        T,</div>
<div class="line">        hash&lt;T&gt;,</div>
<div class="line">        equal&lt;T&gt;</div>
<div class="line">    &gt;</div>
<div class="line">&gt; striped_set;</div>
</div><!-- fragment -->  </td><td>You should provide two different hash function <code>h1</code> and <code>h2</code> - one for <code>boost::unordered_set</code> and other for <code>StripedSet</code>. For the best result, <code>h1</code> and <code>h2</code> must be orthogonal i.e. <code> h1(X) != h2(X) </code> for any value <code>X</code>.   </td></tr>
</table>
<p>You can use another container type as set's bucket. Suppose, you have a container class <code>MyBestContainer</code> and you want to integrate it with <code>StripedSet</code> as bucket type. There are two possibility:</p><ul>
<li>either your <code>MyBestContainer</code> class has native support of bucket's interface; in this case, you can use default <code><a class="el" href="classcds_1_1container_1_1striped__set_1_1adapt.html" title="Default adapter for hash set. ">striped_set::adapt</a></code> metafunction;</li>
<li>or your <code>MyBestContainer</code> class does not support bucket's interface, which means, that you should develop a specialization <code>cds::container::striped_set::adapt&lt;MyBestContainer&gt; </code> metafunction providing necessary interface.</li>
</ul>
<p>The <code>striped_set::adapt&lt; Container, Options... &gt;</code> metafunction has two template argument:</p><ul>
<li><code>Container</code> is the class that should be used as the bucket, for example, <code>std::list&lt; T &gt;</code>.</li>
<li><code>Options</code> pack is the options from <code>StripedSet</code> declaration. The <code>adapt</code> metafunction can use any option from <code>Options</code> for its internal use. For example, a <code>compare</code> option can be passed to <code>adapt</code> metafunction via <code>Options</code> argument of <code>StripedSet</code> declaration.</li>
</ul>
<p>See <a class="el" href="classcds_1_1container_1_1striped__set_1_1adapt.html" title="Default adapter for hash set. ">striped_set::adapt</a> metafunction for the description of interface that the bucket container must provide to be StripedSet compatible.</p>
<p><b>Copy policy</b> There are three predefined copy policy:</p><ul>
<li><code>cds::container::striped_set::copy_item</code> - copy item from old bucket to new one when resizing using copy ctor. It is default policy for any compiler that do not support move semantics</li>
<li><code>cds::container::striped_set::move_item</code> - move item from old bucket to new one when resizing using move semantics. It is default policy for any compiler that support move semantics. If compiler does not support move semantics, the move policy is the same as <code>copy_item</code> </li>
<li><code>cds::container::striped_set::swap_item</code> - copy item from old bucket to new one when resizing using <code>std::swap</code>. Not all containers support this copy policy, see details in table below.</li>
</ul>
<p>You can define your own copy policy specifically for your case. Note, right copy policy can significantly improve the performance of resizing.</p>
<table class="doxtable">
<tr>
<th>Container </th><th>Policies  </th></tr>
<tr>
<td><ul>
<li><code>std::list</code> </li>
<li><code>std::vector</code> </li>
<li><code>boost::list</code> </li>
<li><code>boost::vector</code> </li>
<li><code>boost::stable_vector</code>  </li>
</ul>
</td><td><div class="fragment"><div class="line"><span class="keyword">struct </span>copy_item {</div>
<div class="line">    <span class="keywordtype">void</span> operator()( std::list&lt;T&gt;&amp; list, std::list&lt;T&gt;::iterator itInsert, std::list&lt;T&gt;::iterator itWhat )</div>
<div class="line">    {</div>
<div class="line">        list.insert( itInsert, *itWhat );</div>
<div class="line">    }</div>
<div class="line">} </div>
</div><!-- fragment --><div class="fragment"><div class="line"><span class="comment">// The type T stored in the list must be swappable</span></div>
<div class="line"><span class="keyword">struct </span>swap_item {</div>
<div class="line">    <span class="keywordtype">void</span> operator()( std::list&lt;T&gt;&amp; list, std::list&lt;T&gt;::iterator itInsert, std::list&lt;T&gt;::iterator itWhat )</div>
<div class="line">    {</div>
<div class="line">        std::swap( *list.insert( itInsert, T() ), *itWhat );</div>
<div class="line">    }</div>
<div class="line">} </div>
</div><!-- fragment --><div class="fragment"><div class="line"><span class="keyword">struct </span>move_item {</div>
<div class="line">    <span class="keywordtype">void</span> operator()( std::list&lt;T&gt;&amp; list, std::list&lt;T&gt;::iterator itInsert, std::list&lt;T&gt;::iterator itWhat )</div>
<div class="line">    {</div>
<div class="line">        list.insert( itInsert, std::move( *itWhat ) );</div>
<div class="line">    }</div>
<div class="line">} </div>
</div><!-- fragment -->   </td></tr>
<tr>
<td><ul>
<li><code>std::set</code> </li>
<li><code>std::unordered_set</code>  </li>
</ul>
</td><td><div class="fragment"><div class="line"><span class="keyword">struct </span>copy_item {</div>
<div class="line">    <span class="keywordtype">void</span> operator()( std::set&lt;T&gt;&amp; set, std::set&lt;T&gt;::iterator itWhat )</div>
<div class="line">    {</div>
<div class="line">        set.insert( *itWhat );</div>
<div class="line">    }</div>
<div class="line">} </div>
</div><!-- fragment --><p> <code>swap_item</code> is not applicable (same as <code>copy_item</code>)</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>move_item {</div>
<div class="line">    <span class="keywordtype">void</span> operator()( std::set&lt;T&gt;&amp; set, std::set&lt;T&gt;::iterator itWhat )</div>
<div class="line">    {</div>
<div class="line">        set.insert( std::move( *itWhat ));</div>
<div class="line">    }</div>
<div class="line">} </div>
</div><!-- fragment -->  </td></tr>
<tr>
<td><ul>
<li><code>boost::container::slist</code>  </li>
</ul>
</td><td><div class="fragment"><div class="line"><span class="keyword">struct </span>copy_item {</div>
<div class="line">    <span class="keywordtype">void</span> operator()( bc::slist&lt;T&gt;&amp; list, bc::slist&lt;T&gt;::iterator itInsert, bc::slist&lt;T&gt;::iterator itWhat )</div>
<div class="line">    {</div>
<div class="line">        list.insert_after( itInsert, *itWhat );</div>
<div class="line">    }</div>
<div class="line">} </div>
</div><!-- fragment --><div class="fragment"><div class="line"><span class="comment">// The type T stored in the list must be swappable</span></div>
<div class="line"><span class="keyword">struct </span>swap_item {</div>
<div class="line">    <span class="keywordtype">void</span> operator()( bc::slist&lt;T&gt;&amp; list, bc::slist&lt;T&gt;::iterator itInsert, bc::slist&lt;T&gt;::iterator itWhat )</div>
<div class="line">    {</div>
<div class="line">        std::swap( *list.insert_after( itInsert, T() ), *itWhat );</div>
<div class="line">    }</div>
<div class="line">} </div>
</div><!-- fragment --><div class="fragment"><div class="line"><span class="keyword">struct </span>move_item {</div>
<div class="line">    <span class="keywordtype">void</span> operator()( bc::slist&lt;T&gt;&amp; list, bc::slist&lt;T&gt;::iterator itInsert, bc::slist&lt;T&gt;::iterator itWhat )</div>
<div class="line">    {</div>
<div class="line">        list.insert_after( itInsert, std::move( *itWhat ) );</div>
<div class="line">    }</div>
<div class="line">} </div>
</div><!-- fragment -->   </td></tr>
</table>
<p><b>Advanced functions</b></p>
<p><b>libcds</b> provides some advanced functions like <code><a class="el" href="classcds_1_1container_1_1_striped_set.html#a93bbd4712424855500108292e10935f7" title="Deletes the item from the set using pred predicate for searching. ">erase_with()</a></code>, <code><a class="el" href="classcds_1_1container_1_1_striped_set.html#a7aaecb8e05cd335c57507c1a69ea3078" title="Find the key val using pred predicate. ">find_with()</a></code>, that cannot be supported by all underlying containers. The table below shows whether underlying container supports those functions (the sign "+" means "container supports the function"):</p>
<table class="doxtable">
<tr>
<th>Container </th><th><code>find_with</code>  </th><th><code>erse_with</code>   </th></tr>
<tr>
<td><code>std::list</code>  </td><td>+ </td><td>+  </td></tr>
<tr>
<td><code>std::vector</code>  </td><td>+ </td><td>+  </td></tr>
<tr>
<td><code>std::set</code>  </td><td>- </td><td>-  </td></tr>
<tr>
<td><code>std::unordered_set</code>  </td><td>- </td><td>-  </td></tr>
<tr>
<td><code>boost::container::slist</code>  </td><td>+ </td><td>+  </td></tr>
<tr>
<td><code>boost::container::list</code>  </td><td>+ </td><td>+  </td></tr>
<tr>
<td><code>boost::container::vector</code>  </td><td>+ </td><td>+  </td></tr>
<tr>
<td><code>boost::container::stable_vector</code>  </td><td>+ </td><td>+  </td></tr>
<tr>
<td><code>boost::container::set</code>  </td><td>- </td><td>-  </td></tr>
<tr>
<td><code>boost::container::flat_set</code>  </td><td>- </td><td>-  </td></tr>
<tr>
<td><code>boost::unordered_set</code>  </td><td>- </td><td>-  </td></tr>
</table>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a319c779ca7127d5fc03ade9a521a0338"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container, typename... Options&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1container_1_1_striped_set.html">cds::container::StripedSet</a>&lt; Container, Options &gt;::<a class="el" href="classcds_1_1container_1_1_striped_set.html">StripedSet</a> </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nCapacity</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Ctor with initial capacity specified. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nCapacity</td><td>Initial size of bucket table and lock array. Must be power of two, the minimum is 16. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9d042ba5068bfcbc9ad5737938794cd7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container, typename... Options&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1container_1_1_striped_set.html">cds::container::StripedSet</a>&lt; Container, Options &gt;::<a class="el" href="classcds_1_1container_1_1_striped_set.html">StripedSet</a> </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nCapacity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcds_1_1container_1_1_striped_set.html#a132347759ae9e7929c5dc75a53890687">resizing_policy</a> const &amp;&#160;</td>
          <td class="paramname"><em>resizingPolicy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Ctor with resizing policy (copy semantics) </p>
<p>This constructor initializes m_ResizingPolicy member with copy of <code>resizingPolicy</code> parameter </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nCapacity</td><td>Initial size of bucket table and lock array. Must be power of two, the minimum is 16. </td></tr>
    <tr><td class="paramname">resizingPolicy</td><td>Resizing policy </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0c0ef12897d8f8923a9725fa1c49d14d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container, typename... Options&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1container_1_1_striped_set.html">cds::container::StripedSet</a>&lt; Container, Options &gt;::<a class="el" href="classcds_1_1container_1_1_striped_set.html">StripedSet</a> </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nCapacity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcds_1_1container_1_1_striped_set.html#a132347759ae9e7929c5dc75a53890687">resizing_policy</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>resizingPolicy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Ctor with resizing policy (move semantics) </p>
<p>This constructor initializes m_ResizingPolicy member moving <code>resizingPolicy</code> parameter Move semantics is used. Available only for the compilers that supports C++11 rvalue reference. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nCapacity</td><td>Initial size of bucket table and lock array. Must be power of two, the minimum is 16. </td></tr>
    <tr><td class="paramname">resizingPolicy</td><td>Resizing policy </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="aa84a8c4d24479a4a0a7f9bb843826f62"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container, typename... Options&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classcds_1_1container_1_1_striped_set.html">cds::container::StripedSet</a>&lt; Container, Options &gt;::bucket_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the size of hash table. </p>
<p>The hash table size is non-constant and can be increased via resizing. </p>

</div>
</div>
<a class="anchor" id="a4bdfcbca5e48b3d517b9e450a06e9be1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container, typename... Options&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcds_1_1container_1_1_striped_set.html">cds::container::StripedSet</a>&lt; Container, Options &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clears the set. </p>
<p>The function erases all items from the set. </p>

</div>
</div>
<a class="anchor" id="aa0dfbf9bd83bc92c1d7611532811c523"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container, typename... Options&gt; </div>
<div class="memtemplate">
template&lt;typename Q &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_striped_set.html">cds::container::StripedSet</a>&lt; Container, Options &gt;::contains </td>
          <td>(</td>
          <td class="paramtype">Q const &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether the set contains <code>key</code>. </p>
<p>The function searches the item with key equal to <code>key</code> and returns <code>true</code> if it is found, and <code>false</code> otherwise.</p>
<p>Note the hash functor specified for class <code>Traits</code> template parameter should accept a parameter of type <code>Q</code> that can be not the same as <code>value_type</code>. Otherwise, you may use <code><a class="el" href="classcds_1_1container_1_1_striped_set.html#a4581ada4d40d30156be2138d96209008" title="Checks whether the map contains key using pred predicate for searching. ">contains( Q const&amp;, Less pred )</a></code> functions with explicit predicate for key comparing. </p>

</div>
</div>
<a class="anchor" id="a4581ada4d40d30156be2138d96209008"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container, typename... Options&gt; </div>
<div class="memtemplate">
template&lt;typename Q , typename Less , typename Bucket  = bucket_type, typename  = typename std::enable_if&lt; Bucket::has_find_with &gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_striped_set.html">cds::container::StripedSet</a>&lt; Container, Options &gt;::contains </td>
          <td>(</td>
          <td class="paramtype">Q const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Less&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether the map contains <code>key</code> using <code>pred</code> predicate for searching. </p>
<p>The function is similar to <code>contains( key )</code> but <code>pred</code> is used for key comparing. <code>Less</code> functor has the interface like <code>std::less</code>. <code>Less</code> must imply the same element order as the comparator used for building the map. </p>

</div>
</div>
<a class="anchor" id="a6a5007c5df1cb5cdea5f404ac25a88bd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container, typename... Options&gt; </div>
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_striped_set.html">cds::container::StripedSet</a>&lt; Container, Options &gt;::emplace </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts data of type <code>value_type</code> constructed with <code>std::forward&lt;Args&gt;(args)...</code> </p>
<p>Returns <code>true</code> if inserting successful, <code>false</code> otherwise. </p>

</div>
</div>
<a class="anchor" id="a1b79c0d6a40f53ba7db96555ab5680dc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container, typename... Options&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_striped_set.html">cds::container::StripedSet</a>&lt; Container, Options &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the set is empty. </p>
<p>Emptiness is checked by item counting: if item count is zero then the set is empty. </p>

</div>
</div>
<a class="anchor" id="ad89f2115ab187e2105c91dd933cb82d7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container, typename... Options&gt; </div>
<div class="memtemplate">
template&lt;typename Q &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_striped_set.html">cds::container::StripedSet</a>&lt; Container, Options &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">Q const &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Delete <code>key</code> from the set. </p>
<p><a class="anchor" id="cds_nonintrusive_StripedSet_erase"></a> The set item comparator should be able to compare the type <code>value_type</code> and the type <code>Q</code>. Return <code>true</code> if key is found and deleted, <code>false</code> otherwise </p>

</div>
</div>
<a class="anchor" id="a0c3e75924c53c72d92082b484975af7a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container, typename... Options&gt; </div>
<div class="memtemplate">
template&lt;typename Q , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_striped_set.html">cds::container::StripedSet</a>&lt; Container, Options &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">Q const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Delete <code>key</code> from the set. </p>
<p><a class="anchor" id="cds_nonintrusive_StripedSet_erase_func"></a> The function searches an item with key <code>key</code>, calls <code>f</code> functor with item found and deletes it. If <code>key</code> is not found, the functor is not called.</p>
<p>The functor <code>Func</code> interface is: </p><div class="fragment"><div class="line"><span class="keyword">struct </span>functor {</div>
<div class="line">    <span class="keywordtype">void</span> operator()(<a class="code" href="classcds_1_1container_1_1_striped_set.html#a2497aaa946640a16825e61d14a6d6189">value_type</a> <span class="keyword">const</span>&amp; val);</div>
<div class="line">};</div>
</div><!-- fragment --><p>Return <code>true</code> if key is found and deleted, <code>false</code> otherwise </p>

</div>
</div>
<a class="anchor" id="a93bbd4712424855500108292e10935f7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container, typename... Options&gt; </div>
<div class="memtemplate">
template&lt;typename Q , typename Less , typename Bucket  = bucket_type, typename  = typename std::enable_if&lt; Bucket::has_erase_with &gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_striped_set.html">cds::container::StripedSet</a>&lt; Container, Options &gt;::erase_with </td>
          <td>(</td>
          <td class="paramtype">Q const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Less&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deletes the item from the set using <code>pred</code> predicate for searching. </p>
<p>The function is an analog of <a class="el" href="classcds_1_1container_1_1_striped_set.html#cds_nonintrusive_StripedSet_erase">erase(Q const&amp;)</a> but <code>pred</code> is used for key comparing. <code>Less</code> functor has the interface like <code>std::less</code>. <code>pred</code> must imply the same element order as the comparator used for building the set.</p>
<dl class="section note"><dt>Note</dt><dd>This function is enabled if the compiler supports C++11 default template arguments for function template <b>and</b> the underlying container supports <code>erase_with</code> feature. </dd></dl>

</div>
</div>
<a class="anchor" id="af161c84a97d8357664c37720bdf77879"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container, typename... Options&gt; </div>
<div class="memtemplate">
template&lt;typename Q , typename Less , typename Func , typename Bucket  = bucket_type, typename  = typename std::enable_if&lt; Bucket::has_erase_with &gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_striped_set.html">cds::container::StripedSet</a>&lt; Container, Options &gt;::erase_with </td>
          <td>(</td>
          <td class="paramtype">Q const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Less&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deletes the item from the set using <code>pred</code> predicate for searching. </p>
<p>The function is an analog of <a class="el" href="classcds_1_1container_1_1_striped_set.html#cds_nonintrusive_StripedSet_erase_func">erase(Q const&amp;, Func)</a> but <code>pred</code> is used for key comparing. <code>Less</code> functor has the interface like <code>std::less</code>. <code>pred</code> must imply the same element order as the comparator used for building the set.</p>
<dl class="section note"><dt>Note</dt><dd>This function is enabled if the compiler supports C++11 default template arguments for function template <b>and</b> the underlying container supports <code>erase_with</code> feature. </dd></dl>

</div>
</div>
<a class="anchor" id="a203525441d38698012f814d8408f6d36"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container, typename... Options&gt; </div>
<div class="memtemplate">
template&lt;typename Q , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_striped_set.html">cds::container::StripedSet</a>&lt; Container, Options &gt;::find </td>
          <td>(</td>
          <td class="paramtype">Q &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the key <code>val</code>. </p>
<p><a class="anchor" id="cds_nonintrusive_StripedSet_find_func"></a> The function searches the item with key equal to <code>val</code> and calls the functor <code>f</code> for item found. The interface of <code>Func</code> functor is: </p><div class="fragment"><div class="line"><span class="keyword">struct </span>functor {</div>
<div class="line">    <span class="keywordtype">void</span> operator()( <a class="code" href="classcds_1_1container_1_1_striped_set.html#a2497aaa946640a16825e61d14a6d6189">value_type</a>&amp; item, Q&amp; val );</div>
<div class="line">};</div>
</div><!-- fragment --><p> where <code>item</code> is the item found, <code>val</code> is the <code>find</code> function argument.</p>
<p>The functor can change non-key fields of <code>item</code>. The <code>val</code> argument is non-const since it can be used as <code>f</code> functor destination i.e., the functor can modify both arguments.</p>
<p>The type <code>Q</code> can differ from <code>value_type</code> of items storing in the container. Therefore, the <code>value_type</code> should be comparable with type <code>Q</code>.</p>
<p>The function returns <code>true</code> if <code>val</code> is found, <code>false</code> otherwise. </p>

</div>
</div>
<a class="anchor" id="acb9099506c1034b3a5f437db5e73c1d0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container, typename... Options&gt; </div>
<div class="memtemplate">
template&lt;typename Q , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_striped_set.html">cds::container::StripedSet</a>&lt; Container, Options &gt;::find </td>
          <td>(</td>
          <td class="paramtype">Q const &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the key <code>val</code>. </p>
<p><a class="anchor" id="cds_nonintrusive_StripedSet_find_cfunc"></a> The function searches the item with key equal to <code>val</code> and calls the functor <code>f</code> for item found. The interface of <code>Func</code> functor is: </p><div class="fragment"><div class="line"><span class="keyword">struct </span>functor {</div>
<div class="line">    <span class="keywordtype">void</span> operator()( <a class="code" href="classcds_1_1container_1_1_striped_set.html#a2497aaa946640a16825e61d14a6d6189">value_type</a>&amp; item, Q <span class="keyword">const</span>&amp; val );</div>
<div class="line">};</div>
</div><!-- fragment --><p> where <code>item</code> is the item found, <code>val</code> is the <code>find</code> function argument.</p>
<p>The functor can change non-key fields of <code>item</code>.</p>
<p>The type <code>Q</code> can differ from <code>value_type</code> of items storing in the container. Therefore, the <code>value_type</code> should be comparable with type <code>Q</code>.</p>
<p>The function returns <code>true</code> if <code>val</code> is found, <code>false</code> otherwise. </p>

</div>
</div>
<a class="anchor" id="a7aaecb8e05cd335c57507c1a69ea3078"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container, typename... Options&gt; </div>
<div class="memtemplate">
template&lt;typename Q , typename Less , typename Func , typename Bucket  = bucket_type, typename  = typename std::enable_if&lt; Bucket::has_find_with &gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_striped_set.html">cds::container::StripedSet</a>&lt; Container, Options &gt;::find_with </td>
          <td>(</td>
          <td class="paramtype">Q &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Less&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the key <code>val</code> using <code>pred</code> predicate. </p>
<p>The function is an analog of <a class="el" href="classcds_1_1container_1_1_striped_set.html#cds_nonintrusive_StripedSet_find_func">find(Q&amp;, Func)</a> but <code>pred</code> is used for key comparing <code>Less</code> has the interface like <code>std::less</code>. <code>pred</code> must imply the same element order as the comparator used for building the set.</p>
<dl class="section note"><dt>Note</dt><dd>This function is enabled if the compiler supports C++11 default template arguments for function template <b>and</b> the underlying container supports <code>find_with</code> feature. </dd></dl>

</div>
</div>
<a class="anchor" id="a6a062a1d56946e140c120856be09b04a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container, typename... Options&gt; </div>
<div class="memtemplate">
template&lt;typename Q , typename Less , typename Func , typename Bucket  = bucket_type, typename  = typename std::enable_if&lt; Bucket::has_find_with &gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_striped_set.html">cds::container::StripedSet</a>&lt; Container, Options &gt;::find_with </td>
          <td>(</td>
          <td class="paramtype">Q const &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Less&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the key <code>val</code> using <code>pred</code> predicate. </p>
<p>The function is an analog of <a class="el" href="classcds_1_1container_1_1_striped_set.html#cds_nonintrusive_StripedSet_find_cfunc">find(Q const&amp;, Func)</a> but <code>pred</code> is used for key comparing <code>Less</code> has the interface like <code>std::less</code>. <code>pred</code> must imply the same element order as the comparator used for building the set.</p>
<dl class="section note"><dt>Note</dt><dd>This function is enabled if the compiler supports C++11 default template arguments for function template <b>and</b> the underlying container supports <code>find_with</code> feature. </dd></dl>

</div>
</div>
<a class="anchor" id="aff8843b99b6f85ad37e9b4e4d920f523"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container, typename... Options&gt; </div>
<div class="memtemplate">
template&lt;typename Q &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_striped_set.html">cds::container::StripedSet</a>&lt; Container, Options &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">Q const &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts new node. </p>
<p>The function creates a node with copy of <code>val</code> value and then inserts the node created into the set.</p>
<p>The type <code>Q</code> should contain as minimum the complete key for the node. The object of <code>value_type</code> should be constructible from a value of type <code>Q</code>. In trivial case, <code>Q</code> is equal to <code>value_type</code>.</p>
<p>Returns <code>true</code> if <code>val</code> is inserted into the set, <code>false</code> otherwise. </p>

</div>
</div>
<a class="anchor" id="a6516d09d6a558712c1827bf57bd65b53"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container, typename... Options&gt; </div>
<div class="memtemplate">
template&lt;typename Q , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_striped_set.html">cds::container::StripedSet</a>&lt; Container, Options &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">Q const &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts new node. </p>
<p>The function allows to split creating of new item into two part:</p><ul>
<li>create item with key only</li>
<li>insert new item into the set</li>
<li>if inserting is success, calls <code>f</code> functor to initialize value-field of new item .</li>
</ul>
<p>The functor signature is: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> func( <a class="code" href="classcds_1_1container_1_1_striped_set.html#a2497aaa946640a16825e61d14a6d6189">value_type</a>&amp; item );</div>
</div><!-- fragment --><p> where <code>item</code> is the item inserted.</p>
<p>The type <code>Q</code> can differ from <code>value_type</code> of items storing in the set. Therefore, the <code>value_type</code> should be constructible from type <code>Q</code>.</p>
<p>The user-defined functor is called only if the inserting is success. </p>

</div>
</div>
<a class="anchor" id="af0bc8935f7925e4b446c6b1c1e37d247"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container, typename... Options&gt; </div>
<div class="memtemplate">
template&lt;typename Q , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;bool, bool&gt; <a class="el" href="classcds_1_1container_1_1_striped_set.html">cds::container::StripedSet</a>&lt; Container, Options &gt;::update </td>
          <td>(</td>
          <td class="paramtype">Q const &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bAllowInsert</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Updates the node. </p>
<p>The operation performs inserting or changing data with lock-free manner.</p>
<p>If <code>key</code> is not found in the set, then <code>key</code> is inserted iff <code>bAllowInsert</code> is <code>true</code>. Otherwise, the functor <code>func</code> is called with item found.</p>
<p>The functor signature is: </p><div class="fragment"><div class="line"><span class="keyword">struct </span>my_functor {</div>
<div class="line">    <span class="keywordtype">void</span> operator()( <span class="keywordtype">bool</span> bNew, <a class="code" href="classcds_1_1container_1_1_striped_set.html#a2497aaa946640a16825e61d14a6d6189">value_type</a>&amp; item, <span class="keyword">const</span> Q&amp; val );</div>
<div class="line">};</div>
</div><!-- fragment --><p> with arguments:</p><ul>
<li><code>bNew</code> - <code>true</code> if the item has been inserted, <code>false</code> otherwise</li>
<li><code>item</code> - item of the set</li>
<li><code>val</code> - argument <code>val</code> passed into the <code>update</code>() function</li>
</ul>
<p>The functor may change non-key fields of the <code>item</code>.</p>
<p>Returns <code> std::pair&lt;bool, bool&gt; </code> where <code>first</code> is true if operation is successfull, <code>second</code> is true if new item has been added or <code>false</code> if the item with <code>key</code> already is in the map. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>cds/container/striped_set.h</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<hr/>
<div align="right">
  <b>cds</b> <b>2.1.0</b> 
  Developed by <i>Maxim Khizhinsky aka khizmax</i> 2007 - 2015
  <br/>
  <i>Autogenerated Wed Jan 6 2016 16:00:41 by Doxygen 1.8.10</i>
</div>
</body>
</html>
