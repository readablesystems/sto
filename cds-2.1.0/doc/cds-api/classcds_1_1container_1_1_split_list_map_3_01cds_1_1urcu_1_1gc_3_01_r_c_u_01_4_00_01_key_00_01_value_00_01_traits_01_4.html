<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>cds: cds::container::SplitListMap&lt; cds::urcu::gc&lt; RCU &gt;, Key, Value, Traits &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">cds
   &#160;<span id="projectnumber">2.1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="classes.html"><span>Data&#160;Structure&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Data&#160;Fields</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a>  </div>
  <div class="headertitle">
<div class="title">cds::container::SplitListMap&lt; cds::urcu::gc&lt; RCU &gt;, Key, Value, Traits &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__cds__nonintrusive__containers.html">Non-intrusive containers</a> &raquo; <a class="el" href="group__cds__nonintrusive__map.html">Map</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Split-ordered list map (template specialization for <a class="el" href="namespacecds_1_1urcu.html#cds_urcu_desc">RCU</a>)  
 <a href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#details">More...</a></p>

<p><code>#include &lt;cds/container/split_list_map_rcu.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for cds::container::SplitListMap&lt; cds::urcu::gc&lt; RCU &gt;, Key, Value, Traits &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.png" usemap="#cds::container::SplitListMap&lt; cds::urcu::gc&lt; RCU &gt;, Key, Value, Traits &gt;_map" alt=""/>
  <map id="cds::container::SplitListMap&lt; cds::urcu::gc&lt; RCU &gt;, Key, Value, Traits &gt;_map" name="cds::container::SplitListMap&lt; cds::urcu::gc&lt; RCU &gt;, Key, Value, Traits &gt;_map">
<area href="classcds_1_1container_1_1_split_list_set.html" alt="cds::container::SplitListSet&lt; cds::urcu::gc&lt; RCU &gt;, std::pair&lt; Key const, Value &gt;, split_list::details::wrap_map_traits&lt; Key, Value, Traits &gt; &gt;" shape="rect" coords="0,56,1013,80"/>
<area href="classcds_1_1intrusive_1_1_split_list_set.html" alt="cds::intrusive::SplitListSet&lt; cds::urcu::gc&lt; RCU &gt;, split_list::details::wrap_map_traits&lt; Key, Value, Traits &gt;::ordered_list, split_list::details::wrap_map_traits&lt; Key, Value, Traits &gt; &gt;" shape="rect" coords="0,0,1013,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:aab17bead6a5a976f13d19ed61b239266"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aab17bead6a5a976f13d19ed61b239266"></a>
typedef cds::urcu::gc&lt; RCU &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#aab17bead6a5a976f13d19ed61b239266">gc</a></td></tr>
<tr class="memdesc:aab17bead6a5a976f13d19ed61b239266"><td class="mdescLeft">&#160;</td><td class="mdescRight">Garbage collector. <br /></td></tr>
<tr class="separator:aab17bead6a5a976f13d19ed61b239266"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e25dd8f881eb1af7bf624a64330ab18"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9e25dd8f881eb1af7bf624a64330ab18"></a>
typedef Key&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#a9e25dd8f881eb1af7bf624a64330ab18">key_type</a></td></tr>
<tr class="memdesc:a9e25dd8f881eb1af7bf624a64330ab18"><td class="mdescLeft">&#160;</td><td class="mdescRight">key type <br /></td></tr>
<tr class="separator:a9e25dd8f881eb1af7bf624a64330ab18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99d1fdbb6c05b121221d300031c7ac19"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a99d1fdbb6c05b121221d300031c7ac19"></a>
typedef Value&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#a99d1fdbb6c05b121221d300031c7ac19">mapped_type</a></td></tr>
<tr class="memdesc:a99d1fdbb6c05b121221d300031c7ac19"><td class="mdescLeft">&#160;</td><td class="mdescRight">type of value to be stored in the map <br /></td></tr>
<tr class="separator:a99d1fdbb6c05b121221d300031c7ac19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d23be354cf94a60bf34b9c4b94a22a5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8d23be354cf94a60bf34b9c4b94a22a5"></a>
typedef Traits&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#a8d23be354cf94a60bf34b9c4b94a22a5">traits</a></td></tr>
<tr class="memdesc:a8d23be354cf94a60bf34b9c4b94a22a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map traits. <br /></td></tr>
<tr class="separator:a8d23be354cf94a60bf34b9c4b94a22a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a682405bbab11f0cd0287f763ac14f5a5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a682405bbab11f0cd0287f763ac14f5a5"></a>
typedef std::pair&lt; <a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#a9e25dd8f881eb1af7bf624a64330ab18">key_type</a> const, <a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#a99d1fdbb6c05b121221d300031c7ac19">mapped_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#a682405bbab11f0cd0287f763ac14f5a5">value_type</a></td></tr>
<tr class="memdesc:a682405bbab11f0cd0287f763ac14f5a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">key-value pair type <br /></td></tr>
<tr class="separator:a682405bbab11f0cd0287f763ac14f5a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4e33ceb9acfeec3ae22f3e54075bf40"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad4e33ceb9acfeec3ae22f3e54075bf40"></a>
typedef base_class::ordered_list&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#ad4e33ceb9acfeec3ae22f3e54075bf40">ordered_list</a></td></tr>
<tr class="memdesc:ad4e33ceb9acfeec3ae22f3e54075bf40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Underlying ordered list class. <br /></td></tr>
<tr class="separator:ad4e33ceb9acfeec3ae22f3e54075bf40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bbdea9db64a3c1b833c13e8507dc2ee"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7bbdea9db64a3c1b833c13e8507dc2ee"></a>
typedef base_class::key_comparator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#a7bbdea9db64a3c1b833c13e8507dc2ee">key_comparator</a></td></tr>
<tr class="memdesc:a7bbdea9db64a3c1b833c13e8507dc2ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">key comparison functor <br /></td></tr>
<tr class="separator:a7bbdea9db64a3c1b833c13e8507dc2ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3f287833bda6211df83817d566d526d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad3f287833bda6211df83817d566d526d"></a>
typedef base_class::hash&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#ad3f287833bda6211df83817d566d526d">hash</a></td></tr>
<tr class="memdesc:ad3f287833bda6211df83817d566d526d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hash functor for <a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#a9e25dd8f881eb1af7bf624a64330ab18">key_type</a>. <br /></td></tr>
<tr class="separator:ad3f287833bda6211df83817d566d526d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6170d9bb565f6fb4441bd76131d61130"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6170d9bb565f6fb4441bd76131d61130"></a>
typedef base_class::item_counter&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#a6170d9bb565f6fb4441bd76131d61130">item_counter</a></td></tr>
<tr class="memdesc:a6170d9bb565f6fb4441bd76131d61130"><td class="mdescLeft">&#160;</td><td class="mdescRight">Item counter type. <br /></td></tr>
<tr class="separator:a6170d9bb565f6fb4441bd76131d61130"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae10f892fa310e8bfa8b72794f4584d5b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae10f892fa310e8bfa8b72794f4584d5b"></a>
typedef base_class::stat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#ae10f892fa310e8bfa8b72794f4584d5b">stat</a></td></tr>
<tr class="memdesc:ae10f892fa310e8bfa8b72794f4584d5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal statistics. <br /></td></tr>
<tr class="separator:ae10f892fa310e8bfa8b72794f4584d5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3d21dad6f6df3f9fa8b2471c1664a8d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa3d21dad6f6df3f9fa8b2471c1664a8d"></a>
typedef base_class::rcu_lock&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#aa3d21dad6f6df3f9fa8b2471c1664a8d">rcu_lock</a></td></tr>
<tr class="memdesc:aa3d21dad6f6df3f9fa8b2471c1664a8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">RCU scoped lock. <br /></td></tr>
<tr class="separator:aa3d21dad6f6df3f9fa8b2471c1664a8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2b237bfaeb025412114274e5ca57b14"><td class="memItemLeft" align="right" valign="top">typedef base_class::exempt_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#af2b237bfaeb025412114274e5ca57b14">exempt_ptr</a></td></tr>
<tr class="separator:af2b237bfaeb025412114274e5ca57b14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa307bb5de70335cf963bb9195017f62"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afa307bb5de70335cf963bb9195017f62"></a>
typedef base_class::raw_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#afa307bb5de70335cf963bb9195017f62">raw_ptr</a></td></tr>
<tr class="memdesc:afa307bb5de70335cf963bb9195017f62"><td class="mdescLeft">&#160;</td><td class="mdescRight">type of <code><a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#aeee9a675a958ee274c2de200432a00ca" title="Finds key and return the item found. ">get()</a></code> return value <br /></td></tr>
<tr class="separator:afa307bb5de70335cf963bb9195017f62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa91b81aead03e9460711e566824a2713"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa91b81aead03e9460711e566824a2713"></a>
typedef base_class::iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#aa91b81aead03e9460711e566824a2713">iterator</a></td></tr>
<tr class="memdesc:aa91b81aead03e9460711e566824a2713"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forward iterator. <br /></td></tr>
<tr class="separator:aa91b81aead03e9460711e566824a2713"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9039192cd438d5b60e8583d510f79e9f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9039192cd438d5b60e8583d510f79e9f"></a>
typedef base_class::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#a9039192cd438d5b60e8583d510f79e9f">const_iterator</a></td></tr>
<tr class="memdesc:a9039192cd438d5b60e8583d510f79e9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const forward iterator. <br /></td></tr>
<tr class="separator:a9039192cd438d5b60e8583d510f79e9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a2e9a7ffed701fe108e98e27790782042"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#aa91b81aead03e9460711e566824a2713">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#a2e9a7ffed701fe108e98e27790782042">begin</a> ()</td></tr>
<tr class="memdesc:a2e9a7ffed701fe108e98e27790782042"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a forward iterator addressing the first element in a map.  <a href="#a2e9a7ffed701fe108e98e27790782042">More...</a><br /></td></tr>
<tr class="separator:a2e9a7ffed701fe108e98e27790782042"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9411b38419a5dc5ce92ba48f48339e52"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#aa91b81aead03e9460711e566824a2713">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#a9411b38419a5dc5ce92ba48f48339e52">end</a> ()</td></tr>
<tr class="memdesc:a9411b38419a5dc5ce92ba48f48339e52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator that addresses the location succeeding the last element in a map.  <a href="#a9411b38419a5dc5ce92ba48f48339e52">More...</a><br /></td></tr>
<tr class="separator:a9411b38419a5dc5ce92ba48f48339e52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0392614ddcd0ada7bb78136dc97bbc85"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#a0392614ddcd0ada7bb78136dc97bbc85">SplitListMap</a> ()</td></tr>
<tr class="memdesc:a0392614ddcd0ada7bb78136dc97bbc85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes split-ordered map of default capacity.  <a href="#a0392614ddcd0ada7bb78136dc97bbc85">More...</a><br /></td></tr>
<tr class="separator:a0392614ddcd0ada7bb78136dc97bbc85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bcf30da24623b50f97a1f5e49e2bc55"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#a4bcf30da24623b50f97a1f5e49e2bc55">SplitListMap</a> (size_t nItemCount, size_t nLoadFactor=1)</td></tr>
<tr class="memdesc:a4bcf30da24623b50f97a1f5e49e2bc55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes split-ordered map.  <a href="#a4bcf30da24623b50f97a1f5e49e2bc55">More...</a><br /></td></tr>
<tr class="separator:a4bcf30da24623b50f97a1f5e49e2bc55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9732e42943b07d8e216d25c42def7f01"><td class="memTemplParams" colspan="2">template&lt;typename K &gt; </td></tr>
<tr class="memitem:a9732e42943b07d8e216d25c42def7f01"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#a9732e42943b07d8e216d25c42def7f01">insert</a> (K const &amp;key)</td></tr>
<tr class="memdesc:a9732e42943b07d8e216d25c42def7f01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new node with key and default value.  <a href="#a9732e42943b07d8e216d25c42def7f01">More...</a><br /></td></tr>
<tr class="separator:a9732e42943b07d8e216d25c42def7f01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37e1da831a875c8ef38964f7a63d68fb"><td class="memTemplParams" colspan="2">template&lt;typename K , typename V &gt; </td></tr>
<tr class="memitem:a37e1da831a875c8ef38964f7a63d68fb"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#a37e1da831a875c8ef38964f7a63d68fb">insert</a> (K const &amp;key, V const &amp;val)</td></tr>
<tr class="memdesc:a37e1da831a875c8ef38964f7a63d68fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new node.  <a href="#a37e1da831a875c8ef38964f7a63d68fb">More...</a><br /></td></tr>
<tr class="separator:a37e1da831a875c8ef38964f7a63d68fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a977a9f295cffc445355b5ac4c23bdf39"><td class="memTemplParams" colspan="2">template&lt;typename K , typename Func &gt; </td></tr>
<tr class="memitem:a977a9f295cffc445355b5ac4c23bdf39"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#a977a9f295cffc445355b5ac4c23bdf39">insert_with</a> (K const &amp;key, Func func)</td></tr>
<tr class="memdesc:a977a9f295cffc445355b5ac4c23bdf39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new node and initialize it by a functor.  <a href="#a977a9f295cffc445355b5ac4c23bdf39">More...</a><br /></td></tr>
<tr class="separator:a977a9f295cffc445355b5ac4c23bdf39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c7d84aee09c4327f325c43a43548600"><td class="memTemplParams" colspan="2">template&lt;typename K , typename... Args&gt; </td></tr>
<tr class="memitem:a9c7d84aee09c4327f325c43a43548600"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#a9c7d84aee09c4327f325c43a43548600">emplace</a> (K &amp;&amp;key, Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:a9c7d84aee09c4327f325c43a43548600"><td class="mdescLeft">&#160;</td><td class="mdescRight">For key <code>key</code> inserts data of type <code>mapped_type</code> created in-place from <code>args</code>.  <a href="#a9c7d84aee09c4327f325c43a43548600">More...</a><br /></td></tr>
<tr class="separator:a9c7d84aee09c4327f325c43a43548600"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04090173571564ec3983bd37b19699bb"><td class="memTemplParams" colspan="2">template&lt;typename K , typename Func &gt; </td></tr>
<tr class="memitem:a04090173571564ec3983bd37b19699bb"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; bool, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#a04090173571564ec3983bd37b19699bb">update</a> (K const &amp;key, Func func, bool bAllowInsert=true)</td></tr>
<tr class="memdesc:a04090173571564ec3983bd37b19699bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates data by <code>key</code>.  <a href="#a04090173571564ec3983bd37b19699bb">More...</a><br /></td></tr>
<tr class="separator:a04090173571564ec3983bd37b19699bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebb1f2b166d2b12f9f2a84344e264003"><td class="memTemplParams" colspan="2">template&lt;typename K &gt; </td></tr>
<tr class="memitem:aebb1f2b166d2b12f9f2a84344e264003"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#aebb1f2b166d2b12f9f2a84344e264003">erase</a> (K const &amp;key)</td></tr>
<tr class="memdesc:aebb1f2b166d2b12f9f2a84344e264003"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes <code>key</code> from the map.  <a href="#aebb1f2b166d2b12f9f2a84344e264003">More...</a><br /></td></tr>
<tr class="separator:aebb1f2b166d2b12f9f2a84344e264003"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e6674c5f0b6b4f0f523fcd4cba878c0"><td class="memTemplParams" colspan="2">template&lt;typename K , typename Less &gt; </td></tr>
<tr class="memitem:a6e6674c5f0b6b4f0f523fcd4cba878c0"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#a6e6674c5f0b6b4f0f523fcd4cba878c0">erase_with</a> (K const &amp;key, Less pred)</td></tr>
<tr class="memdesc:a6e6674c5f0b6b4f0f523fcd4cba878c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the item from the map using <code>pred</code> predicate for searching.  <a href="#a6e6674c5f0b6b4f0f523fcd4cba878c0">More...</a><br /></td></tr>
<tr class="separator:a6e6674c5f0b6b4f0f523fcd4cba878c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e0d10489ab3ad0da3fd7ed9aa32e994"><td class="memTemplParams" colspan="2">template&lt;typename K , typename Func &gt; </td></tr>
<tr class="memitem:a4e0d10489ab3ad0da3fd7ed9aa32e994"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#a4e0d10489ab3ad0da3fd7ed9aa32e994">erase</a> (K const &amp;key, Func f)</td></tr>
<tr class="memdesc:a4e0d10489ab3ad0da3fd7ed9aa32e994"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes <code>key</code> from the map.  <a href="#a4e0d10489ab3ad0da3fd7ed9aa32e994">More...</a><br /></td></tr>
<tr class="separator:a4e0d10489ab3ad0da3fd7ed9aa32e994"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93282b6aba0332c6fce60c3fedf23115"><td class="memTemplParams" colspan="2">template&lt;typename K , typename Less , typename Func &gt; </td></tr>
<tr class="memitem:a93282b6aba0332c6fce60c3fedf23115"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#a93282b6aba0332c6fce60c3fedf23115">erase_with</a> (K const &amp;key, Less pred, Func f)</td></tr>
<tr class="memdesc:a93282b6aba0332c6fce60c3fedf23115"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the item from the map using <code>pred</code> predicate for searching.  <a href="#a93282b6aba0332c6fce60c3fedf23115">More...</a><br /></td></tr>
<tr class="separator:a93282b6aba0332c6fce60c3fedf23115"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42d26ad0509a27b9c8ce94e2ef84aab8"><td class="memTemplParams" colspan="2">template&lt;typename K &gt; </td></tr>
<tr class="memitem:a42d26ad0509a27b9c8ce94e2ef84aab8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#af2b237bfaeb025412114274e5ca57b14">exempt_ptr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#a42d26ad0509a27b9c8ce94e2ef84aab8">extract</a> (K const &amp;key)</td></tr>
<tr class="memdesc:a42d26ad0509a27b9c8ce94e2ef84aab8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts an item from the map.  <a href="#a42d26ad0509a27b9c8ce94e2ef84aab8">More...</a><br /></td></tr>
<tr class="separator:a42d26ad0509a27b9c8ce94e2ef84aab8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d1f93f1f491242438c6ba9071fd0f69"><td class="memTemplParams" colspan="2">template&lt;typename K , typename Less &gt; </td></tr>
<tr class="memitem:a7d1f93f1f491242438c6ba9071fd0f69"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#af2b237bfaeb025412114274e5ca57b14">exempt_ptr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#a7d1f93f1f491242438c6ba9071fd0f69">extract_with</a> (K const &amp;key, Less pred)</td></tr>
<tr class="memdesc:a7d1f93f1f491242438c6ba9071fd0f69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts an item from the map using <code>pred</code> predicate for searching.  <a href="#a7d1f93f1f491242438c6ba9071fd0f69">More...</a><br /></td></tr>
<tr class="separator:a7d1f93f1f491242438c6ba9071fd0f69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1b497490353d85557018c5b908f82f0"><td class="memTemplParams" colspan="2">template&lt;typename K , typename Func &gt; </td></tr>
<tr class="memitem:ab1b497490353d85557018c5b908f82f0"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#ab1b497490353d85557018c5b908f82f0">find</a> (K const &amp;key, Func f)</td></tr>
<tr class="memdesc:ab1b497490353d85557018c5b908f82f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the key <code>key</code>.  <a href="#ab1b497490353d85557018c5b908f82f0">More...</a><br /></td></tr>
<tr class="separator:ab1b497490353d85557018c5b908f82f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad593abbddb349e7e7d5642269f70d0cd"><td class="memTemplParams" colspan="2">template&lt;typename K , typename Less , typename Func &gt; </td></tr>
<tr class="memitem:ad593abbddb349e7e7d5642269f70d0cd"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#ad593abbddb349e7e7d5642269f70d0cd">find_with</a> (K const &amp;key, Less pred, Func f)</td></tr>
<tr class="memdesc:ad593abbddb349e7e7d5642269f70d0cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the key <code>key</code> using <code>pred</code> predicate for searching.  <a href="#ad593abbddb349e7e7d5642269f70d0cd">More...</a><br /></td></tr>
<tr class="separator:ad593abbddb349e7e7d5642269f70d0cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a961195d3d1094db952437c69c7be9767"><td class="memTemplParams" colspan="2">template&lt;typename K &gt; </td></tr>
<tr class="memitem:a961195d3d1094db952437c69c7be9767"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#a961195d3d1094db952437c69c7be9767">contains</a> (K const &amp;key)</td></tr>
<tr class="memdesc:a961195d3d1094db952437c69c7be9767"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the map contains <code>key</code>.  <a href="#a961195d3d1094db952437c69c7be9767">More...</a><br /></td></tr>
<tr class="separator:a961195d3d1094db952437c69c7be9767"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6070cade4eb1619e92abf568b7d1659d"><td class="memTemplParams" colspan="2">template&lt;typename K , typename Less &gt; </td></tr>
<tr class="memitem:a6070cade4eb1619e92abf568b7d1659d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#a6070cade4eb1619e92abf568b7d1659d">contains</a> (K const &amp;key, Less pred)</td></tr>
<tr class="memdesc:a6070cade4eb1619e92abf568b7d1659d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the map contains <code>key</code> using <code>pred</code> predicate for searching.  <a href="#a6070cade4eb1619e92abf568b7d1659d">More...</a><br /></td></tr>
<tr class="separator:a6070cade4eb1619e92abf568b7d1659d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeee9a675a958ee274c2de200432a00ca"><td class="memTemplParams" colspan="2">template&lt;typename K &gt; </td></tr>
<tr class="memitem:aeee9a675a958ee274c2de200432a00ca"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#afa307bb5de70335cf963bb9195017f62">raw_ptr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#aeee9a675a958ee274c2de200432a00ca">get</a> (K const &amp;key)</td></tr>
<tr class="memdesc:aeee9a675a958ee274c2de200432a00ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds <code>key</code> and return the item found.  <a href="#aeee9a675a958ee274c2de200432a00ca">More...</a><br /></td></tr>
<tr class="separator:aeee9a675a958ee274c2de200432a00ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bee6446a58cf200ac613d54c24c8b9a"><td class="memTemplParams" colspan="2">template&lt;typename K , typename Less &gt; </td></tr>
<tr class="memitem:a9bee6446a58cf200ac613d54c24c8b9a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#afa307bb5de70335cf963bb9195017f62">raw_ptr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#a9bee6446a58cf200ac613d54c24c8b9a">get_with</a> (K const &amp;key, Less pred)</td></tr>
<tr class="memdesc:a9bee6446a58cf200ac613d54c24c8b9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds <code>key</code> with predicate specified and return the item found.  <a href="#a9bee6446a58cf200ac613d54c24c8b9a">More...</a><br /></td></tr>
<tr class="separator:a9bee6446a58cf200ac613d54c24c8b9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22bba93ee1391b60e4155702a3f32fbf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a22bba93ee1391b60e4155702a3f32fbf"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#a22bba93ee1391b60e4155702a3f32fbf">clear</a> ()</td></tr>
<tr class="memdesc:a22bba93ee1391b60e4155702a3f32fbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the map (not atomic) <br /></td></tr>
<tr class="separator:a22bba93ee1391b60e4155702a3f32fbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a524158157038188845708bc6058b630f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#a524158157038188845708bc6058b630f">empty</a> () const </td></tr>
<tr class="memdesc:a524158157038188845708bc6058b630f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the map is empty.  <a href="#a524158157038188845708bc6058b630f">More...</a><br /></td></tr>
<tr class="separator:a524158157038188845708bc6058b630f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac25c58f3c6aff8c4750893a0e9e7e142"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac25c58f3c6aff8c4750893a0e9e7e142"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#ac25c58f3c6aff8c4750893a0e9e7e142">size</a> () const </td></tr>
<tr class="memdesc:ac25c58f3c6aff8c4750893a0e9e7e142"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns item count in the map. <br /></td></tr>
<tr class="separator:ac25c58f3c6aff8c4750893a0e9e7e142"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad837effd8219aaa5d2439b8a374b9ffb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad837effd8219aaa5d2439b8a374b9ffb"></a>
<a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#ae10f892fa310e8bfa8b72794f4584d5b">stat</a> const &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#ad837effd8219aaa5d2439b8a374b9ffb">statistics</a> () const </td></tr>
<tr class="memdesc:ad837effd8219aaa5d2439b8a374b9ffb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns internal statistics. <br /></td></tr>
<tr class="separator:ad837effd8219aaa5d2439b8a374b9ffb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a59ca6c0583eb55382220eeefc22fd569"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a59ca6c0583eb55382220eeefc22fd569"></a>
<a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#a9039192cd438d5b60e8583d510f79e9f">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#a59ca6c0583eb55382220eeefc22fd569">begin</a> () const </td></tr>
<tr class="memdesc:a59ca6c0583eb55382220eeefc22fd569"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a forward const iterator addressing the first element in a map. <br /></td></tr>
<tr class="separator:a59ca6c0583eb55382220eeefc22fd569"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ec52593ad9fd35e3c2c2798e2bad145"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8ec52593ad9fd35e3c2c2798e2bad145"></a>
<a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#a9039192cd438d5b60e8583d510f79e9f">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cbegin</b> () const </td></tr>
<tr class="separator:a8ec52593ad9fd35e3c2c2798e2bad145"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a7c887c4f2cbc89fd5e7cc40f0f08b2b7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7c887c4f2cbc89fd5e7cc40f0f08b2b7"></a>
<a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#a9039192cd438d5b60e8583d510f79e9f">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#a7c887c4f2cbc89fd5e7cc40f0f08b2b7">end</a> () const </td></tr>
<tr class="memdesc:a7c887c4f2cbc89fd5e7cc40f0f08b2b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an const iterator that addresses the location succeeding the last element in a map. <br /></td></tr>
<tr class="separator:a7c887c4f2cbc89fd5e7cc40f0f08b2b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86e32f6fe5795d00348076e2ff641d8a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a86e32f6fe5795d00348076e2ff641d8a"></a>
<a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#a9039192cd438d5b60e8583d510f79e9f">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cend</b> () const </td></tr>
<tr class="separator:a86e32f6fe5795d00348076e2ff641d8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a9e7433d0460d1c7dbae0d40bcee89c1e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9e7433d0460d1c7dbae0d40bcee89c1e"></a>
static constexpr const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#a9e7433d0460d1c7dbae0d40bcee89c1e">c_bExtractLockExternal</a> = base_class::c_bExtractLockExternal</td></tr>
<tr class="memdesc:a9e7433d0460d1c7dbae0d40bcee89c1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Group of <code>extract_xxx</code> functions require external locking if underlying ordered list requires that. <br /></td></tr>
<tr class="separator:a9e7433d0460d1c7dbae0d40bcee89c1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_types_classcds_1_1container_1_1_split_list_set"><td colspan="2" onclick="javascript:toggleInherit('pro_types_classcds_1_1container_1_1_split_list_set')"><img src="closed.png" alt="-"/>&#160;Protected Types inherited from <a class="el" href="classcds_1_1container_1_1_split_list_set.html">cds::container::SplitListSet&lt; cds::urcu::gc&lt; RCU &gt;, std::pair&lt; Key const, Value &gt;, split_list::details::wrap_map_traits&lt; Key, Value, Traits &gt; &gt;</a></td></tr>
<tr class="memitem:a7b2c74a504580b5971e333db4c29248d inherit pro_types_classcds_1_1container_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7b2c74a504580b5971e333db4c29248d"></a>
typedef cds::urcu::gc&lt; RCU &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_set.html#a7b2c74a504580b5971e333db4c29248d">gc</a></td></tr>
<tr class="memdesc:a7b2c74a504580b5971e333db4c29248d inherit pro_types_classcds_1_1container_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Garbage collector. <br /></td></tr>
<tr class="separator:a7b2c74a504580b5971e333db4c29248d inherit pro_types_classcds_1_1container_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb30a4ce7b104b6cea584e4987029aeb inherit pro_types_classcds_1_1container_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acb30a4ce7b104b6cea584e4987029aeb"></a>
typedef std::pair&lt; Key const, Value &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_set.html#acb30a4ce7b104b6cea584e4987029aeb">value_type</a></td></tr>
<tr class="memdesc:acb30a4ce7b104b6cea584e4987029aeb inherit pro_types_classcds_1_1container_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of vlue to be stored in split-list. <br /></td></tr>
<tr class="separator:acb30a4ce7b104b6cea584e4987029aeb inherit pro_types_classcds_1_1container_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b05520aea1e3dab4ae7bb080df7c9d5 inherit pro_types_classcds_1_1container_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5b05520aea1e3dab4ae7bb080df7c9d5"></a>
typedef split_list::details::wrap_map_traits&lt; Key, Value, Traits &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_set.html#a5b05520aea1e3dab4ae7bb080df7c9d5">traits</a></td></tr>
<tr class="memdesc:a5b05520aea1e3dab4ae7bb080df7c9d5 inherit pro_types_classcds_1_1container_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>Traits</code> template argument <br /></td></tr>
<tr class="separator:a5b05520aea1e3dab4ae7bb080df7c9d5 inherit pro_types_classcds_1_1container_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a843cd4ac855f36a0ea09b2a91318533e inherit pro_types_classcds_1_1container_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a843cd4ac855f36a0ea09b2a91318533e"></a>
typedef maker::ordered_list&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_set.html#a843cd4ac855f36a0ea09b2a91318533e">ordered_list</a></td></tr>
<tr class="memdesc:a843cd4ac855f36a0ea09b2a91318533e inherit pro_types_classcds_1_1container_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Underlying ordered list class. <br /></td></tr>
<tr class="separator:a843cd4ac855f36a0ea09b2a91318533e inherit pro_types_classcds_1_1container_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5497c22d61d56489cbca457a5e7f047 inherit pro_types_classcds_1_1container_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af5497c22d61d56489cbca457a5e7f047"></a>
typedef base_class::key_comparator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_set.html#af5497c22d61d56489cbca457a5e7f047">key_comparator</a></td></tr>
<tr class="memdesc:af5497c22d61d56489cbca457a5e7f047 inherit pro_types_classcds_1_1container_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">key compare functor <br /></td></tr>
<tr class="separator:af5497c22d61d56489cbca457a5e7f047 inherit pro_types_classcds_1_1container_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa2ab388cbeccec46d1dc63e66ea5ec7 inherit pro_types_classcds_1_1container_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaa2ab388cbeccec46d1dc63e66ea5ec7"></a>
typedef base_class::hash&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_set.html#aaa2ab388cbeccec46d1dc63e66ea5ec7">hash</a></td></tr>
<tr class="memdesc:aaa2ab388cbeccec46d1dc63e66ea5ec7 inherit pro_types_classcds_1_1container_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hash functor for <code>value_type</code> and all its derivatives that you use. <br /></td></tr>
<tr class="separator:aaa2ab388cbeccec46d1dc63e66ea5ec7 inherit pro_types_classcds_1_1container_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b0847071460189800f9002e2d03ef99 inherit pro_types_classcds_1_1container_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7b0847071460189800f9002e2d03ef99"></a>
typedef base_class::item_counter&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_set.html#a7b0847071460189800f9002e2d03ef99">item_counter</a></td></tr>
<tr class="memdesc:a7b0847071460189800f9002e2d03ef99 inherit pro_types_classcds_1_1container_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Item counter type. <br /></td></tr>
<tr class="separator:a7b0847071460189800f9002e2d03ef99 inherit pro_types_classcds_1_1container_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad39196ac90597908219c5b130b37f47c inherit pro_types_classcds_1_1container_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad39196ac90597908219c5b130b37f47c"></a>
typedef base_class::stat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_set.html#ad39196ac90597908219c5b130b37f47c">stat</a></td></tr>
<tr class="memdesc:ad39196ac90597908219c5b130b37f47c inherit pro_types_classcds_1_1container_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal statistics. <br /></td></tr>
<tr class="separator:ad39196ac90597908219c5b130b37f47c inherit pro_types_classcds_1_1container_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1a910658827d385bc3ee5564bfa1c05 inherit pro_types_classcds_1_1container_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab1a910658827d385bc3ee5564bfa1c05"></a>
typedef gc::template <a class="el" href="classcds_1_1container_1_1_split_list_set.html#ab1a910658827d385bc3ee5564bfa1c05">guarded_ptr</a>&lt; <a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#aee655bc764efdc41d05fe77e4b19b1f9">node_type</a>, <a class="el" href="classcds_1_1container_1_1_split_list_set.html#acb30a4ce7b104b6cea584e4987029aeb">value_type</a>, details::guarded_ptr_cast_set&lt; <a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#aee655bc764efdc41d05fe77e4b19b1f9">node_type</a>, <a class="el" href="classcds_1_1container_1_1_split_list_set.html#acb30a4ce7b104b6cea584e4987029aeb">value_type</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_set.html#ab1a910658827d385bc3ee5564bfa1c05">guarded_ptr</a></td></tr>
<tr class="memdesc:ab1a910658827d385bc3ee5564bfa1c05 inherit pro_types_classcds_1_1container_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Guarded pointer. <br /></td></tr>
<tr class="separator:ab1a910658827d385bc3ee5564bfa1c05 inherit pro_types_classcds_1_1container_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bb1e96121f36af3252e2aa1ea09ff1b inherit pro_types_classcds_1_1container_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3bb1e96121f36af3252e2aa1ea09ff1b"></a>
typedef iterator_type&lt; false &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_set.html#a3bb1e96121f36af3252e2aa1ea09ff1b">iterator</a></td></tr>
<tr class="memdesc:a3bb1e96121f36af3252e2aa1ea09ff1b inherit pro_types_classcds_1_1container_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forward iterator. <br /></td></tr>
<tr class="separator:a3bb1e96121f36af3252e2aa1ea09ff1b inherit pro_types_classcds_1_1container_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a944c54c5061ce4d8d2b04dbe1dea152f inherit pro_types_classcds_1_1container_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a944c54c5061ce4d8d2b04dbe1dea152f"></a>
typedef iterator_type&lt; true &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_set.html#a944c54c5061ce4d8d2b04dbe1dea152f">const_iterator</a></td></tr>
<tr class="memdesc:a944c54c5061ce4d8d2b04dbe1dea152f inherit pro_types_classcds_1_1container_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const forward iterator. <br /></td></tr>
<tr class="separator:a944c54c5061ce4d8d2b04dbe1dea152f inherit pro_types_classcds_1_1container_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_types_classcds_1_1intrusive_1_1_split_list_set"><td colspan="2" onclick="javascript:toggleInherit('pro_types_classcds_1_1intrusive_1_1_split_list_set')"><img src="closed.png" alt="-"/>&#160;Protected Types inherited from <a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html">cds::intrusive::SplitListSet&lt; cds::urcu::gc&lt; RCU &gt;, split_list::details::wrap_map_traits&lt; Key, Value, Traits &gt;::ordered_list, split_list::details::wrap_map_traits&lt; Key, Value, Traits &gt; &gt;</a></td></tr>
<tr class="memitem:a201b859e6aed58eec5f6fd6a0675e5b2 inherit pro_types_classcds_1_1intrusive_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a201b859e6aed58eec5f6fd6a0675e5b2"></a>
typedef ordered_list::node_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#a201b859e6aed58eec5f6fd6a0675e5b2">list_node_type</a></td></tr>
<tr class="memdesc:a201b859e6aed58eec5f6fd6a0675e5b2 inherit pro_types_classcds_1_1intrusive_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Node type as declared in ordered list. <br /></td></tr>
<tr class="separator:a201b859e6aed58eec5f6fd6a0675e5b2 inherit pro_types_classcds_1_1intrusive_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee655bc764efdc41d05fe77e4b19b1f9 inherit pro_types_classcds_1_1intrusive_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aee655bc764efdc41d05fe77e4b19b1f9"></a>
typedef <a class="el" href="structcds_1_1intrusive_1_1split__list_1_1node.html">split_list::node</a>&lt; <a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#a201b859e6aed58eec5f6fd6a0675e5b2">list_node_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#aee655bc764efdc41d05fe77e4b19b1f9">node_type</a></td></tr>
<tr class="memdesc:aee655bc764efdc41d05fe77e4b19b1f9 inherit pro_types_classcds_1_1intrusive_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">split-list node type <br /></td></tr>
<tr class="separator:aee655bc764efdc41d05fe77e4b19b1f9 inherit pro_types_classcds_1_1intrusive_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a020349ff19b12af6d9486cf56aadf083 inherit pro_types_classcds_1_1intrusive_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a020349ff19b12af6d9486cf56aadf083"></a>
typedef <a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#aee655bc764efdc41d05fe77e4b19b1f9">node_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#a020349ff19b12af6d9486cf56aadf083">dummy_node_type</a></td></tr>
<tr class="memdesc:a020349ff19b12af6d9486cf56aadf083 inherit pro_types_classcds_1_1intrusive_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">dummy node type <br /></td></tr>
<tr class="separator:a020349ff19b12af6d9486cf56aadf083 inherit pro_types_classcds_1_1intrusive_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaf536340156f632edfd5bd4f8947e71 inherit pro_types_classcds_1_1intrusive_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structcds_1_1intrusive_1_1split__list_1_1node__traits.html">split_list::node_traits</a>&lt; typename ordered_list::node_traits &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#aeaf536340156f632edfd5bd4f8947e71">node_traits</a></td></tr>
<tr class="memdesc:aeaf536340156f632edfd5bd4f8947e71 inherit pro_types_classcds_1_1intrusive_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split-list node traits.  <a href="#aeaf536340156f632edfd5bd4f8947e71">More...</a><br /></td></tr>
<tr class="separator:aeaf536340156f632edfd5bd4f8947e71 inherit pro_types_classcds_1_1intrusive_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea2de69bd86f37bd184ca50d50e29f0e inherit pro_types_classcds_1_1intrusive_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aea2de69bd86f37bd184ca50d50e29f0e"></a>
typedef cds::urcu::gc&lt; RCU &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#aea2de69bd86f37bd184ca50d50e29f0e">gc</a></td></tr>
<tr class="memdesc:aea2de69bd86f37bd184ca50d50e29f0e inherit pro_types_classcds_1_1intrusive_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Garbage collector. <br /></td></tr>
<tr class="separator:aea2de69bd86f37bd184ca50d50e29f0e inherit pro_types_classcds_1_1intrusive_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8244c115c0dd6b116c9edb9a456c2ee inherit pro_types_classcds_1_1intrusive_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab8244c115c0dd6b116c9edb9a456c2ee"></a>
typedef split_list::details::wrap_map_traits&lt; Key, Value, Traits &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#ab8244c115c0dd6b116c9edb9a456c2ee">traits</a></td></tr>
<tr class="memdesc:ab8244c115c0dd6b116c9edb9a456c2ee inherit pro_types_classcds_1_1intrusive_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set traits. <br /></td></tr>
<tr class="separator:ab8244c115c0dd6b116c9edb9a456c2ee inherit pro_types_classcds_1_1intrusive_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a719263aaf48921d5ced55707389f961a inherit pro_types_classcds_1_1intrusive_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a719263aaf48921d5ced55707389f961a"></a>
typedef split_list::details::wrap_map_traits&lt; Key, Value, Traits &gt;::<a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#a719263aaf48921d5ced55707389f961a">ordered_list</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#a719263aaf48921d5ced55707389f961a">ordered_list</a></td></tr>
<tr class="memdesc:a719263aaf48921d5ced55707389f961a inherit pro_types_classcds_1_1intrusive_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">type of ordered list used as a base for split-list <br /></td></tr>
<tr class="separator:a719263aaf48921d5ced55707389f961a inherit pro_types_classcds_1_1intrusive_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afae9f358f06403565d75e8a6666e0f8f inherit pro_types_classcds_1_1intrusive_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afae9f358f06403565d75e8a6666e0f8f"></a>
typedef ordered_list::value_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#afae9f358f06403565d75e8a6666e0f8f">value_type</a></td></tr>
<tr class="memdesc:afae9f358f06403565d75e8a6666e0f8f inherit pro_types_classcds_1_1intrusive_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">type of value stored in the split-list <br /></td></tr>
<tr class="separator:afae9f358f06403565d75e8a6666e0f8f inherit pro_types_classcds_1_1intrusive_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4ac7447e2749a53db596bef99378f0a inherit pro_types_classcds_1_1intrusive_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac4ac7447e2749a53db596bef99378f0a"></a>
typedef ordered_list::key_comparator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#ac4ac7447e2749a53db596bef99378f0a">key_comparator</a></td></tr>
<tr class="memdesc:ac4ac7447e2749a53db596bef99378f0a inherit pro_types_classcds_1_1intrusive_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">key comparison functor <br /></td></tr>
<tr class="separator:ac4ac7447e2749a53db596bef99378f0a inherit pro_types_classcds_1_1intrusive_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4cfc2f23920086d62cef263e4b4f879 inherit pro_types_classcds_1_1intrusive_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa4cfc2f23920086d62cef263e4b4f879"></a>
typedef ordered_list::disposer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#aa4cfc2f23920086d62cef263e4b4f879">disposer</a></td></tr>
<tr class="memdesc:aa4cfc2f23920086d62cef263e4b4f879 inherit pro_types_classcds_1_1intrusive_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Node disposer functor. <br /></td></tr>
<tr class="separator:aa4cfc2f23920086d62cef263e4b4f879 inherit pro_types_classcds_1_1intrusive_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1255a3a554c960d60f7c07d8c0d71b9 inherit pro_types_classcds_1_1intrusive_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af1255a3a554c960d60f7c07d8c0d71b9"></a>
typedef cds::opt::v::hash_selector&lt; typename traits::hash &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#af1255a3a554c960d60f7c07d8c0d71b9">hash</a></td></tr>
<tr class="memdesc:af1255a3a554c960d60f7c07d8c0d71b9 inherit pro_types_classcds_1_1intrusive_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hash functor for <code>value_type</code> and all its derivatives that you use. <br /></td></tr>
<tr class="separator:af1255a3a554c960d60f7c07d8c0d71b9 inherit pro_types_classcds_1_1intrusive_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1562c4a7ce60945722157d589606eb0 inherit pro_types_classcds_1_1intrusive_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa1562c4a7ce60945722157d589606eb0"></a>
typedef traits::item_counter&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#aa1562c4a7ce60945722157d589606eb0">item_counter</a></td></tr>
<tr class="memdesc:aa1562c4a7ce60945722157d589606eb0 inherit pro_types_classcds_1_1intrusive_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Item counter type. <br /></td></tr>
<tr class="separator:aa1562c4a7ce60945722157d589606eb0 inherit pro_types_classcds_1_1intrusive_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab69886a6028245b341ac8dfaaaf70a40 inherit pro_types_classcds_1_1intrusive_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab69886a6028245b341ac8dfaaaf70a40"></a>
typedef traits::back_off&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#ab69886a6028245b341ac8dfaaaf70a40">back_off</a></td></tr>
<tr class="memdesc:ab69886a6028245b341ac8dfaaaf70a40 inherit pro_types_classcds_1_1intrusive_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">back-off strategy for spinning <br /></td></tr>
<tr class="separator:ab69886a6028245b341ac8dfaaaf70a40 inherit pro_types_classcds_1_1intrusive_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac781a58af799ac8bcfeb5027d1b03536 inherit pro_types_classcds_1_1intrusive_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac781a58af799ac8bcfeb5027d1b03536"></a>
typedef traits::memory_model&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#ac781a58af799ac8bcfeb5027d1b03536">memory_model</a></td></tr>
<tr class="memdesc:ac781a58af799ac8bcfeb5027d1b03536 inherit pro_types_classcds_1_1intrusive_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Memory ordering. See <a class="el" href="structcds_1_1opt_1_1memory__model.html" title="[type-option] Option setter for C++ memory model ">cds::opt::memory_model</a> option. <br /></td></tr>
<tr class="separator:ac781a58af799ac8bcfeb5027d1b03536 inherit pro_types_classcds_1_1intrusive_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b3b57584e1fd7f743b1ab806c138a72 inherit pro_types_classcds_1_1intrusive_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6b3b57584e1fd7f743b1ab806c138a72"></a>
typedef traits::stat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#a6b3b57584e1fd7f743b1ab806c138a72">stat</a></td></tr>
<tr class="memdesc:a6b3b57584e1fd7f743b1ab806c138a72 inherit pro_types_classcds_1_1intrusive_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal statistics, see <code>spit_list::stat</code>. <br /></td></tr>
<tr class="separator:a6b3b57584e1fd7f743b1ab806c138a72 inherit pro_types_classcds_1_1intrusive_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0933c1b9d510566c2538779f1ad81e14 inherit pro_types_classcds_1_1intrusive_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0933c1b9d510566c2538779f1ad81e14"></a>
typedef ordered_list::guarded_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#a0933c1b9d510566c2538779f1ad81e14">guarded_ptr</a></td></tr>
<tr class="memdesc:a0933c1b9d510566c2538779f1ad81e14 inherit pro_types_classcds_1_1intrusive_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Guarded pointer. <br /></td></tr>
<tr class="separator:a0933c1b9d510566c2538779f1ad81e14 inherit pro_types_classcds_1_1intrusive_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c70b5bacc4b3d7d69efbf122f4d2c0b inherit pro_types_classcds_1_1intrusive_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top">typedef iterator_type&lt; false &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#a2c70b5bacc4b3d7d69efbf122f4d2c0b">iterator</a></td></tr>
<tr class="memdesc:a2c70b5bacc4b3d7d69efbf122f4d2c0b inherit pro_types_classcds_1_1intrusive_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forward iterator.  <a href="#a2c70b5bacc4b3d7d69efbf122f4d2c0b">More...</a><br /></td></tr>
<tr class="separator:a2c70b5bacc4b3d7d69efbf122f4d2c0b inherit pro_types_classcds_1_1intrusive_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e6498e34acc524dd27767347acefbdb inherit pro_types_classcds_1_1intrusive_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top">typedef iterator_type&lt; true &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#a1e6498e34acc524dd27767347acefbdb">const_iterator</a></td></tr>
<tr class="memdesc:a1e6498e34acc524dd27767347acefbdb inherit pro_types_classcds_1_1intrusive_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const forward iterator.  <a href="#a1e6498e34acc524dd27767347acefbdb">More...</a><br /></td></tr>
<tr class="separator:a1e6498e34acc524dd27767347acefbdb inherit pro_types_classcds_1_1intrusive_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classcds_1_1container_1_1_split_list_set"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classcds_1_1container_1_1_split_list_set')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classcds_1_1container_1_1_split_list_set.html">cds::container::SplitListSet&lt; cds::urcu::gc&lt; RCU &gt;, std::pair&lt; Key const, Value &gt;, split_list::details::wrap_map_traits&lt; Key, Value, Traits &gt; &gt;</a></td></tr>
<tr class="memitem:aa5670755719b66f046d52f43292a0611 inherit pro_methods_classcds_1_1container_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_set.html#aa5670755719b66f046d52f43292a0611">SplitListSet</a> ()</td></tr>
<tr class="memdesc:aa5670755719b66f046d52f43292a0611 inherit pro_methods_classcds_1_1container_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes split-ordered list of default capacity.  <a href="#aa5670755719b66f046d52f43292a0611">More...</a><br /></td></tr>
<tr class="separator:aa5670755719b66f046d52f43292a0611 inherit pro_methods_classcds_1_1container_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16928087454c9e0ac58e2eb94a2346b2 inherit pro_methods_classcds_1_1container_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_set.html#a16928087454c9e0ac58e2eb94a2346b2">SplitListSet</a> (size_t nItemCount, size_t nLoadFactor=1)</td></tr>
<tr class="memdesc:a16928087454c9e0ac58e2eb94a2346b2 inherit pro_methods_classcds_1_1container_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes split-ordered list.  <a href="#a16928087454c9e0ac58e2eb94a2346b2">More...</a><br /></td></tr>
<tr class="separator:a16928087454c9e0ac58e2eb94a2346b2 inherit pro_methods_classcds_1_1container_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dedb00d0e55b82a0f7975993c9b2975 inherit pro_methods_classcds_1_1container_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1container_1_1_split_list_set.html#a3bb1e96121f36af3252e2aa1ea09ff1b">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_set.html#a5dedb00d0e55b82a0f7975993c9b2975">begin</a> ()</td></tr>
<tr class="memdesc:a5dedb00d0e55b82a0f7975993c9b2975 inherit pro_methods_classcds_1_1container_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a forward iterator addressing the first element in a set.  <a href="#a5dedb00d0e55b82a0f7975993c9b2975">More...</a><br /></td></tr>
<tr class="separator:a5dedb00d0e55b82a0f7975993c9b2975 inherit pro_methods_classcds_1_1container_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53acbc7da38bd1884be534bce6bebe4e inherit pro_methods_classcds_1_1container_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a53acbc7da38bd1884be534bce6bebe4e"></a>
<a class="el" href="classcds_1_1container_1_1_split_list_set.html#a944c54c5061ce4d8d2b04dbe1dea152f">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_set.html#a53acbc7da38bd1884be534bce6bebe4e">begin</a> () const</td></tr>
<tr class="memdesc:a53acbc7da38bd1884be534bce6bebe4e inherit pro_methods_classcds_1_1container_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a forward const iterator addressing the first element in a set. <br /></td></tr>
<tr class="separator:a53acbc7da38bd1884be534bce6bebe4e inherit pro_methods_classcds_1_1container_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae399126f499a0d084959f66a6dc5115d inherit pro_methods_classcds_1_1container_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1container_1_1_split_list_set.html#a3bb1e96121f36af3252e2aa1ea09ff1b">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_set.html#ae399126f499a0d084959f66a6dc5115d">end</a> ()</td></tr>
<tr class="memdesc:ae399126f499a0d084959f66a6dc5115d inherit pro_methods_classcds_1_1container_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator that addresses the location succeeding the last element in a set.  <a href="#ae399126f499a0d084959f66a6dc5115d">More...</a><br /></td></tr>
<tr class="separator:ae399126f499a0d084959f66a6dc5115d inherit pro_methods_classcds_1_1container_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f3aa2d459a68456441ec09726957a0f inherit pro_methods_classcds_1_1container_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3f3aa2d459a68456441ec09726957a0f"></a>
<a class="el" href="classcds_1_1container_1_1_split_list_set.html#a944c54c5061ce4d8d2b04dbe1dea152f">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_set.html#a3f3aa2d459a68456441ec09726957a0f">end</a> () const</td></tr>
<tr class="memdesc:a3f3aa2d459a68456441ec09726957a0f inherit pro_methods_classcds_1_1container_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an const iterator that addresses the location succeeding the last element in a set. <br /></td></tr>
<tr class="separator:a3f3aa2d459a68456441ec09726957a0f inherit pro_methods_classcds_1_1container_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae256e95d28e0a7eb094a58b9ba2d7004 inherit pro_methods_classcds_1_1container_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae256e95d28e0a7eb094a58b9ba2d7004"></a>
<a class="el" href="classcds_1_1container_1_1_split_list_set.html#a944c54c5061ce4d8d2b04dbe1dea152f">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_set.html#ae256e95d28e0a7eb094a58b9ba2d7004">cbegin</a> () const</td></tr>
<tr class="memdesc:ae256e95d28e0a7eb094a58b9ba2d7004 inherit pro_methods_classcds_1_1container_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a forward const iterator addressing the first element in a set. <br /></td></tr>
<tr class="separator:ae256e95d28e0a7eb094a58b9ba2d7004 inherit pro_methods_classcds_1_1container_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac29313baf011e047f9f7c8980b8b21fa inherit pro_methods_classcds_1_1container_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac29313baf011e047f9f7c8980b8b21fa"></a>
<a class="el" href="classcds_1_1container_1_1_split_list_set.html#a944c54c5061ce4d8d2b04dbe1dea152f">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_set.html#ac29313baf011e047f9f7c8980b8b21fa">cend</a> () const</td></tr>
<tr class="memdesc:ac29313baf011e047f9f7c8980b8b21fa inherit pro_methods_classcds_1_1container_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an const iterator that addresses the location succeeding the last element in a set. <br /></td></tr>
<tr class="separator:ac29313baf011e047f9f7c8980b8b21fa inherit pro_methods_classcds_1_1container_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ffc4541e96c58705ad55b1b416488eb inherit pro_methods_classcds_1_1container_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_set.html#a5ffc4541e96c58705ad55b1b416488eb">insert</a> (Q const &amp;val)</td></tr>
<tr class="memdesc:a5ffc4541e96c58705ad55b1b416488eb inherit pro_methods_classcds_1_1container_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new node.  <a href="#a5ffc4541e96c58705ad55b1b416488eb">More...</a><br /></td></tr>
<tr class="separator:a5ffc4541e96c58705ad55b1b416488eb inherit pro_methods_classcds_1_1container_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29e36d03c7a55355574dd6597e3e5bc8 inherit pro_methods_classcds_1_1container_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_set.html#a29e36d03c7a55355574dd6597e3e5bc8">insert</a> (Q const &amp;val, Func f)</td></tr>
<tr class="memdesc:a29e36d03c7a55355574dd6597e3e5bc8 inherit pro_methods_classcds_1_1container_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new node.  <a href="#a29e36d03c7a55355574dd6597e3e5bc8">More...</a><br /></td></tr>
<tr class="separator:a29e36d03c7a55355574dd6597e3e5bc8 inherit pro_methods_classcds_1_1container_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a347a71108230967dfb626ebfd6339d inherit pro_methods_classcds_1_1container_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_set.html#a3a347a71108230967dfb626ebfd6339d">emplace</a> (Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:a3a347a71108230967dfb626ebfd6339d inherit pro_methods_classcds_1_1container_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts data of type <code>value_type</code> created from <code>args</code>.  <a href="#a3a347a71108230967dfb626ebfd6339d">More...</a><br /></td></tr>
<tr class="separator:a3a347a71108230967dfb626ebfd6339d inherit pro_methods_classcds_1_1container_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6f6c4081a777af969b7a6a78704fa8d inherit pro_methods_classcds_1_1container_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top">std::pair&lt; bool, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_set.html#ab6f6c4081a777af969b7a6a78704fa8d">update</a> (Q const &amp;val, Func func, bool bAllowInsert=true)</td></tr>
<tr class="memdesc:ab6f6c4081a777af969b7a6a78704fa8d inherit pro_methods_classcds_1_1container_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the node.  <a href="#ab6f6c4081a777af969b7a6a78704fa8d">More...</a><br /></td></tr>
<tr class="separator:ab6f6c4081a777af969b7a6a78704fa8d inherit pro_methods_classcds_1_1container_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab79de44e57ed7a992995eb9d81cfb41e inherit pro_methods_classcds_1_1container_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_set.html#ab79de44e57ed7a992995eb9d81cfb41e">erase</a> (Q const &amp;key)</td></tr>
<tr class="memdesc:ab79de44e57ed7a992995eb9d81cfb41e inherit pro_methods_classcds_1_1container_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes <code>key</code> from the set.  <a href="#ab79de44e57ed7a992995eb9d81cfb41e">More...</a><br /></td></tr>
<tr class="separator:ab79de44e57ed7a992995eb9d81cfb41e inherit pro_methods_classcds_1_1container_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b1e1f60b52aeab4963ff44d17f2f347 inherit pro_methods_classcds_1_1container_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_set.html#a5b1e1f60b52aeab4963ff44d17f2f347">erase</a> (Q const &amp;key, Func f)</td></tr>
<tr class="memdesc:a5b1e1f60b52aeab4963ff44d17f2f347 inherit pro_methods_classcds_1_1container_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes <code>key</code> from the set.  <a href="#a5b1e1f60b52aeab4963ff44d17f2f347">More...</a><br /></td></tr>
<tr class="separator:a5b1e1f60b52aeab4963ff44d17f2f347 inherit pro_methods_classcds_1_1container_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcd6216eb4f162b274299a6e31c5713c inherit pro_methods_classcds_1_1container_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_set.html#afcd6216eb4f162b274299a6e31c5713c">erase_with</a> (Q const &amp;key, Less pred)</td></tr>
<tr class="memdesc:afcd6216eb4f162b274299a6e31c5713c inherit pro_methods_classcds_1_1container_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the item from the set using <code>pred</code> predicate for searching.  <a href="#afcd6216eb4f162b274299a6e31c5713c">More...</a><br /></td></tr>
<tr class="separator:afcd6216eb4f162b274299a6e31c5713c inherit pro_methods_classcds_1_1container_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac564ef5c7e381397898aa53b83c58d58 inherit pro_methods_classcds_1_1container_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_set.html#ac564ef5c7e381397898aa53b83c58d58">erase_with</a> (Q const &amp;key, Less pred, Func f)</td></tr>
<tr class="memdesc:ac564ef5c7e381397898aa53b83c58d58 inherit pro_methods_classcds_1_1container_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the item from the set using <code>pred</code> predicate for searching.  <a href="#ac564ef5c7e381397898aa53b83c58d58">More...</a><br /></td></tr>
<tr class="separator:ac564ef5c7e381397898aa53b83c58d58 inherit pro_methods_classcds_1_1container_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7636eacfce8c2960b7775a342938292 inherit pro_methods_classcds_1_1container_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1container_1_1_split_list_set.html#ab1a910658827d385bc3ee5564bfa1c05">guarded_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_set.html#ab7636eacfce8c2960b7775a342938292">extract</a> (Q const &amp;key)</td></tr>
<tr class="memdesc:ab7636eacfce8c2960b7775a342938292 inherit pro_methods_classcds_1_1container_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the item with specified <code>key</code>.  <a href="#ab7636eacfce8c2960b7775a342938292">More...</a><br /></td></tr>
<tr class="separator:ab7636eacfce8c2960b7775a342938292 inherit pro_methods_classcds_1_1container_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97fec9dee7ee988e20549d3a3aa53c27 inherit pro_methods_classcds_1_1container_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1container_1_1_split_list_set.html#ab1a910658827d385bc3ee5564bfa1c05">guarded_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_set.html#a97fec9dee7ee988e20549d3a3aa53c27">extract_with</a> (Q const &amp;key, Less pred)</td></tr>
<tr class="memdesc:a97fec9dee7ee988e20549d3a3aa53c27 inherit pro_methods_classcds_1_1container_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the item using compare functor <code>pred</code>.  <a href="#a97fec9dee7ee988e20549d3a3aa53c27">More...</a><br /></td></tr>
<tr class="separator:a97fec9dee7ee988e20549d3a3aa53c27 inherit pro_methods_classcds_1_1container_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19488fdbd28c4c0490f6b55adc60d4fd inherit pro_methods_classcds_1_1container_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_set.html#a19488fdbd28c4c0490f6b55adc60d4fd">find</a> (Q &amp;key, Func f)</td></tr>
<tr class="memdesc:a19488fdbd28c4c0490f6b55adc60d4fd inherit pro_methods_classcds_1_1container_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the key <code>key</code>.  <a href="#a19488fdbd28c4c0490f6b55adc60d4fd">More...</a><br /></td></tr>
<tr class="separator:a19488fdbd28c4c0490f6b55adc60d4fd inherit pro_methods_classcds_1_1container_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2afaabe2cfffe1454ce1b17242d1cd9f inherit pro_methods_classcds_1_1container_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_set.html#a2afaabe2cfffe1454ce1b17242d1cd9f">find_with</a> (Q &amp;key, Less pred, Func f)</td></tr>
<tr class="memdesc:a2afaabe2cfffe1454ce1b17242d1cd9f inherit pro_methods_classcds_1_1container_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the key <code>key</code> using <code>pred</code> predicate for searching.  <a href="#a2afaabe2cfffe1454ce1b17242d1cd9f">More...</a><br /></td></tr>
<tr class="separator:a2afaabe2cfffe1454ce1b17242d1cd9f inherit pro_methods_classcds_1_1container_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa77525470b724f8833e96608c0309caa inherit pro_methods_classcds_1_1container_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_set.html#aa77525470b724f8833e96608c0309caa">contains</a> (Q const &amp;key)</td></tr>
<tr class="memdesc:aa77525470b724f8833e96608c0309caa inherit pro_methods_classcds_1_1container_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the set contains <code>key</code>.  <a href="#aa77525470b724f8833e96608c0309caa">More...</a><br /></td></tr>
<tr class="separator:aa77525470b724f8833e96608c0309caa inherit pro_methods_classcds_1_1container_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad32c2131830853f016bb9180f07a3129 inherit pro_methods_classcds_1_1container_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_set.html#ad32c2131830853f016bb9180f07a3129">contains</a> (Q const &amp;key, Less pred)</td></tr>
<tr class="memdesc:ad32c2131830853f016bb9180f07a3129 inherit pro_methods_classcds_1_1container_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the map contains <code>key</code> using <code>pred</code> predicate for searching.  <a href="#ad32c2131830853f016bb9180f07a3129">More...</a><br /></td></tr>
<tr class="separator:ad32c2131830853f016bb9180f07a3129 inherit pro_methods_classcds_1_1container_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16d4175df387c0cf1fae98d485efa174 inherit pro_methods_classcds_1_1container_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1container_1_1_split_list_set.html#ab1a910658827d385bc3ee5564bfa1c05">guarded_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_set.html#a16d4175df387c0cf1fae98d485efa174">get</a> (Q const &amp;key)</td></tr>
<tr class="memdesc:a16d4175df387c0cf1fae98d485efa174 inherit pro_methods_classcds_1_1container_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the key <code>key</code> and return the item found.  <a href="#a16d4175df387c0cf1fae98d485efa174">More...</a><br /></td></tr>
<tr class="separator:a16d4175df387c0cf1fae98d485efa174 inherit pro_methods_classcds_1_1container_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f4ce221e181457872bd54e63728ab95 inherit pro_methods_classcds_1_1container_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1container_1_1_split_list_set.html#ab1a910658827d385bc3ee5564bfa1c05">guarded_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_set.html#a9f4ce221e181457872bd54e63728ab95">get_with</a> (Q const &amp;key, Less pred)</td></tr>
<tr class="memdesc:a9f4ce221e181457872bd54e63728ab95 inherit pro_methods_classcds_1_1container_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds <code>key</code> and return the item found.  <a href="#a9f4ce221e181457872bd54e63728ab95">More...</a><br /></td></tr>
<tr class="separator:a9f4ce221e181457872bd54e63728ab95 inherit pro_methods_classcds_1_1container_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1472496ebd650294f6a3d7695bb1b4a6 inherit pro_methods_classcds_1_1container_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1472496ebd650294f6a3d7695bb1b4a6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_set.html#a1472496ebd650294f6a3d7695bb1b4a6">clear</a> ()</td></tr>
<tr class="memdesc:a1472496ebd650294f6a3d7695bb1b4a6 inherit pro_methods_classcds_1_1container_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the set (not atomic) <br /></td></tr>
<tr class="separator:a1472496ebd650294f6a3d7695bb1b4a6 inherit pro_methods_classcds_1_1container_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6ce6b20ce55b786a6338dd13fcc5b16 inherit pro_methods_classcds_1_1container_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_set.html#ab6ce6b20ce55b786a6338dd13fcc5b16">empty</a> () const</td></tr>
<tr class="memdesc:ab6ce6b20ce55b786a6338dd13fcc5b16 inherit pro_methods_classcds_1_1container_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the set is empty.  <a href="#ab6ce6b20ce55b786a6338dd13fcc5b16">More...</a><br /></td></tr>
<tr class="separator:ab6ce6b20ce55b786a6338dd13fcc5b16 inherit pro_methods_classcds_1_1container_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97eb246e095d3236f2eafd4e5a330488 inherit pro_methods_classcds_1_1container_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a97eb246e095d3236f2eafd4e5a330488"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_set.html#a97eb246e095d3236f2eafd4e5a330488">size</a> () const</td></tr>
<tr class="memdesc:a97eb246e095d3236f2eafd4e5a330488 inherit pro_methods_classcds_1_1container_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns item count in the set. <br /></td></tr>
<tr class="separator:a97eb246e095d3236f2eafd4e5a330488 inherit pro_methods_classcds_1_1container_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe73645c1b6f7ba7d4c0955b0f67cdcc inherit pro_methods_classcds_1_1container_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afe73645c1b6f7ba7d4c0955b0f67cdcc"></a>
<a class="el" href="classcds_1_1container_1_1_split_list_set.html#ad39196ac90597908219c5b130b37f47c">stat</a> const &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_split_list_set.html#afe73645c1b6f7ba7d4c0955b0f67cdcc">statistics</a> () const</td></tr>
<tr class="memdesc:afe73645c1b6f7ba7d4c0955b0f67cdcc inherit pro_methods_classcds_1_1container_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns internal statistics. <br /></td></tr>
<tr class="separator:afe73645c1b6f7ba7d4c0955b0f67cdcc inherit pro_methods_classcds_1_1container_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classcds_1_1intrusive_1_1_split_list_set')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html">cds::intrusive::SplitListSet&lt; cds::urcu::gc&lt; RCU &gt;, split_list::details::wrap_map_traits&lt; Key, Value, Traits &gt;::ordered_list, split_list::details::wrap_map_traits&lt; Key, Value, Traits &gt; &gt;</a></td></tr>
<tr class="memitem:a685c56051b1ffc44511a5ec12b80b2d0 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#a685c56051b1ffc44511a5ec12b80b2d0">SplitListSet</a> ()</td></tr>
<tr class="memdesc:a685c56051b1ffc44511a5ec12b80b2d0 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize split-ordered list of default capacity.  <a href="#a685c56051b1ffc44511a5ec12b80b2d0">More...</a><br /></td></tr>
<tr class="separator:a685c56051b1ffc44511a5ec12b80b2d0 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56c73356d78265849a8cce93155480eb inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#a56c73356d78265849a8cce93155480eb">SplitListSet</a> (size_t nItemCount, size_t nLoadFactor=1)</td></tr>
<tr class="memdesc:a56c73356d78265849a8cce93155480eb inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize split-ordered list.  <a href="#a56c73356d78265849a8cce93155480eb">More...</a><br /></td></tr>
<tr class="separator:a56c73356d78265849a8cce93155480eb inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fa996ee4f495c0a059c3bb031f7aa06 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#a5fa996ee4f495c0a059c3bb031f7aa06">insert</a> (<a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#afae9f358f06403565d75e8a6666e0f8f">value_type</a> &amp;val)</td></tr>
<tr class="memdesc:a5fa996ee4f495c0a059c3bb031f7aa06 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new node.  <a href="#a5fa996ee4f495c0a059c3bb031f7aa06">More...</a><br /></td></tr>
<tr class="separator:a5fa996ee4f495c0a059c3bb031f7aa06 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93fc790b0a2969b2795ddad438d4243a inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#a93fc790b0a2969b2795ddad438d4243a">insert</a> (<a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#afae9f358f06403565d75e8a6666e0f8f">value_type</a> &amp;val, Func f)</td></tr>
<tr class="memdesc:a93fc790b0a2969b2795ddad438d4243a inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new node.  <a href="#a93fc790b0a2969b2795ddad438d4243a">More...</a><br /></td></tr>
<tr class="separator:a93fc790b0a2969b2795ddad438d4243a inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7ab1789e44fe8fec6bfb5bbc3a1d4c2 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top">std::pair&lt; bool, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#ac7ab1789e44fe8fec6bfb5bbc3a1d4c2">update</a> (<a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#afae9f358f06403565d75e8a6666e0f8f">value_type</a> &amp;val, Func func, bool bAllowInsert=true)</td></tr>
<tr class="memdesc:ac7ab1789e44fe8fec6bfb5bbc3a1d4c2 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the node.  <a href="#ac7ab1789e44fe8fec6bfb5bbc3a1d4c2">More...</a><br /></td></tr>
<tr class="separator:ac7ab1789e44fe8fec6bfb5bbc3a1d4c2 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a4e3d7523dc3b7b2d1a0ac73fec4c3e inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#a0a4e3d7523dc3b7b2d1a0ac73fec4c3e">unlink</a> (<a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#afae9f358f06403565d75e8a6666e0f8f">value_type</a> &amp;val)</td></tr>
<tr class="memdesc:a0a4e3d7523dc3b7b2d1a0ac73fec4c3e inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlinks the item <code>val</code> from the set.  <a href="#a0a4e3d7523dc3b7b2d1a0ac73fec4c3e">More...</a><br /></td></tr>
<tr class="separator:a0a4e3d7523dc3b7b2d1a0ac73fec4c3e inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25ab99e28bc6bc1147c12ef0994e7c0e inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#a25ab99e28bc6bc1147c12ef0994e7c0e">erase</a> (Q const &amp;key)</td></tr>
<tr class="memdesc:a25ab99e28bc6bc1147c12ef0994e7c0e inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the item from the set.  <a href="#a25ab99e28bc6bc1147c12ef0994e7c0e">More...</a><br /></td></tr>
<tr class="separator:a25ab99e28bc6bc1147c12ef0994e7c0e inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae72b3c31a3fe7f78fc7795c5744848b0 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#ae72b3c31a3fe7f78fc7795c5744848b0">erase</a> (Q const &amp;key, Func f)</td></tr>
<tr class="memdesc:ae72b3c31a3fe7f78fc7795c5744848b0 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the item from the set.  <a href="#ae72b3c31a3fe7f78fc7795c5744848b0">More...</a><br /></td></tr>
<tr class="separator:ae72b3c31a3fe7f78fc7795c5744848b0 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87a3128bc56d8278fcdfb1930d37fb98 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#a87a3128bc56d8278fcdfb1930d37fb98">erase_with</a> (const Q &amp;key, Less pred)</td></tr>
<tr class="memdesc:a87a3128bc56d8278fcdfb1930d37fb98 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the item from the set with comparing functor <code>pred</code>.  <a href="#a87a3128bc56d8278fcdfb1930d37fb98">More...</a><br /></td></tr>
<tr class="separator:a87a3128bc56d8278fcdfb1930d37fb98 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b525b1f5b240a9c6036057bc0003fd8 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#a6b525b1f5b240a9c6036057bc0003fd8">erase_with</a> (Q const &amp;key, Less pred, Func f)</td></tr>
<tr class="memdesc:a6b525b1f5b240a9c6036057bc0003fd8 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the item from the set with comparing functor <code>pred</code>.  <a href="#a6b525b1f5b240a9c6036057bc0003fd8">More...</a><br /></td></tr>
<tr class="separator:a6b525b1f5b240a9c6036057bc0003fd8 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fc11d5658a648a54098ec1455b70578 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#a0933c1b9d510566c2538779f1ad81e14">guarded_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#a4fc11d5658a648a54098ec1455b70578">extract</a> (Q const &amp;key)</td></tr>
<tr class="memdesc:a4fc11d5658a648a54098ec1455b70578 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the item with specified <code>key</code>.  <a href="#a4fc11d5658a648a54098ec1455b70578">More...</a><br /></td></tr>
<tr class="separator:a4fc11d5658a648a54098ec1455b70578 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2511f775b91f22e6372c361011eca3e inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#a0933c1b9d510566c2538779f1ad81e14">guarded_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#aa2511f775b91f22e6372c361011eca3e">extract_with</a> (Q const &amp;key, Less pred)</td></tr>
<tr class="memdesc:aa2511f775b91f22e6372c361011eca3e inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the item using compare functor <code>pred</code>.  <a href="#aa2511f775b91f22e6372c361011eca3e">More...</a><br /></td></tr>
<tr class="separator:aa2511f775b91f22e6372c361011eca3e inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14087851b392163b5c6317c4c7fcfc54 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#a14087851b392163b5c6317c4c7fcfc54">find</a> (Q &amp;key, Func f)</td></tr>
<tr class="memdesc:a14087851b392163b5c6317c4c7fcfc54 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the key <code>key</code>.  <a href="#a14087851b392163b5c6317c4c7fcfc54">More...</a><br /></td></tr>
<tr class="separator:a14087851b392163b5c6317c4c7fcfc54 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfcb668b144364e7c2bab2f4dc0cc9e6 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#acfcb668b144364e7c2bab2f4dc0cc9e6">find_with</a> (Q &amp;key, Less pred, Func f)</td></tr>
<tr class="memdesc:acfcb668b144364e7c2bab2f4dc0cc9e6 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the key <code>key</code> with <code>pred</code> predicate for comparing.  <a href="#acfcb668b144364e7c2bab2f4dc0cc9e6">More...</a><br /></td></tr>
<tr class="separator:acfcb668b144364e7c2bab2f4dc0cc9e6 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ce860bde9bcb5ef71f87a796387687e inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#a9ce860bde9bcb5ef71f87a796387687e">contains</a> (Q const &amp;key)</td></tr>
<tr class="memdesc:a9ce860bde9bcb5ef71f87a796387687e inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the set contains <code>key</code>.  <a href="#a9ce860bde9bcb5ef71f87a796387687e">More...</a><br /></td></tr>
<tr class="separator:a9ce860bde9bcb5ef71f87a796387687e inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adba7f5058868947b9b9ac189fd97e712 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#adba7f5058868947b9b9ac189fd97e712">contains</a> (Q const &amp;key, Less pred)</td></tr>
<tr class="memdesc:adba7f5058868947b9b9ac189fd97e712 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the set contains <code>key</code> using <code>pred</code> predicate for searching.  <a href="#adba7f5058868947b9b9ac189fd97e712">More...</a><br /></td></tr>
<tr class="separator:adba7f5058868947b9b9ac189fd97e712 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe6e8ba28a58586de9e556b1c82069a5 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#a0933c1b9d510566c2538779f1ad81e14">guarded_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#afe6e8ba28a58586de9e556b1c82069a5">get</a> (Q const &amp;key)</td></tr>
<tr class="memdesc:afe6e8ba28a58586de9e556b1c82069a5 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the key <code>key</code> and return the item found.  <a href="#afe6e8ba28a58586de9e556b1c82069a5">More...</a><br /></td></tr>
<tr class="separator:afe6e8ba28a58586de9e556b1c82069a5 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0217cf552409c17f9d49689224812fb5 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#a0933c1b9d510566c2538779f1ad81e14">guarded_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#a0217cf552409c17f9d49689224812fb5">get_with</a> (Q const &amp;key, Less pred)</td></tr>
<tr class="memdesc:a0217cf552409c17f9d49689224812fb5 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the key <code>key</code> and return the item found.  <a href="#a0217cf552409c17f9d49689224812fb5">More...</a><br /></td></tr>
<tr class="separator:a0217cf552409c17f9d49689224812fb5 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7aa1bf063e7d77c1bf66af27c9ace40a inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7aa1bf063e7d77c1bf66af27c9ace40a"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#a7aa1bf063e7d77c1bf66af27c9ace40a">size</a> () const</td></tr>
<tr class="memdesc:a7aa1bf063e7d77c1bf66af27c9ace40a inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns item count in the set. <br /></td></tr>
<tr class="separator:a7aa1bf063e7d77c1bf66af27c9ace40a inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d58c4927bf06251506a711cc04e1b25 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#a2d58c4927bf06251506a711cc04e1b25">empty</a> () const</td></tr>
<tr class="memdesc:a2d58c4927bf06251506a711cc04e1b25 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the set is empty.  <a href="#a2d58c4927bf06251506a711cc04e1b25">More...</a><br /></td></tr>
<tr class="separator:a2d58c4927bf06251506a711cc04e1b25 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f3fc77a7939fd3553a594fc5a315572 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#a0f3fc77a7939fd3553a594fc5a315572">clear</a> ()</td></tr>
<tr class="memdesc:a0f3fc77a7939fd3553a594fc5a315572 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the set (non-atomic)  <a href="#a0f3fc77a7939fd3553a594fc5a315572">More...</a><br /></td></tr>
<tr class="separator:a0f3fc77a7939fd3553a594fc5a315572 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a022eb764b7c6e044fb7323e9c1bc082e inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a022eb764b7c6e044fb7323e9c1bc082e"></a>
<a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#a6b3b57584e1fd7f743b1ab806c138a72">stat</a> const &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#a022eb764b7c6e044fb7323e9c1bc082e">statistics</a> () const</td></tr>
<tr class="memdesc:a022eb764b7c6e044fb7323e9c1bc082e inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns internal statistics. <br /></td></tr>
<tr class="separator:a022eb764b7c6e044fb7323e9c1bc082e inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9f775376add33a1d7d2b82463670a55 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#a2c70b5bacc4b3d7d69efbf122f4d2c0b">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#ae9f775376add33a1d7d2b82463670a55">begin</a> ()</td></tr>
<tr class="memdesc:ae9f775376add33a1d7d2b82463670a55 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a forward iterator addressing the first element in a split-list.  <a href="#ae9f775376add33a1d7d2b82463670a55">More...</a><br /></td></tr>
<tr class="separator:ae9f775376add33a1d7d2b82463670a55 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2d1674dacb1ce36c99bfcfc714fe721 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa2d1674dacb1ce36c99bfcfc714fe721"></a>
<a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#a1e6498e34acc524dd27767347acefbdb">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#aa2d1674dacb1ce36c99bfcfc714fe721">begin</a> () const</td></tr>
<tr class="memdesc:aa2d1674dacb1ce36c99bfcfc714fe721 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a forward const iterator addressing the first element in a split-list. <br /></td></tr>
<tr class="separator:aa2d1674dacb1ce36c99bfcfc714fe721 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f5c1a7fb52b15cea10bbaa04c926517 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#a2c70b5bacc4b3d7d69efbf122f4d2c0b">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#a4f5c1a7fb52b15cea10bbaa04c926517">end</a> ()</td></tr>
<tr class="memdesc:a4f5c1a7fb52b15cea10bbaa04c926517 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator that addresses the location succeeding the last element in a split-list.  <a href="#a4f5c1a7fb52b15cea10bbaa04c926517">More...</a><br /></td></tr>
<tr class="separator:a4f5c1a7fb52b15cea10bbaa04c926517 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9e4856422504f1a0c4350ed10c40532 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab9e4856422504f1a0c4350ed10c40532"></a>
<a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#a1e6498e34acc524dd27767347acefbdb">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#ab9e4856422504f1a0c4350ed10c40532">end</a> () const</td></tr>
<tr class="memdesc:ab9e4856422504f1a0c4350ed10c40532 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an const iterator that addresses the location succeeding the last element in a split-list. <br /></td></tr>
<tr class="separator:ab9e4856422504f1a0c4350ed10c40532 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a956647e1ec05740f6133bf542f0c44fa inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a956647e1ec05740f6133bf542f0c44fa"></a>
<a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#a1e6498e34acc524dd27767347acefbdb">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#a956647e1ec05740f6133bf542f0c44fa">cbegin</a> () const</td></tr>
<tr class="memdesc:a956647e1ec05740f6133bf542f0c44fa inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a forward const iterator addressing the first element in a split-list. <br /></td></tr>
<tr class="separator:a956647e1ec05740f6133bf542f0c44fa inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a068f29e62ebc9020b73e090b8d8e6ce5 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a068f29e62ebc9020b73e090b8d8e6ce5"></a>
<a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#a1e6498e34acc524dd27767347acefbdb">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#a068f29e62ebc9020b73e090b8d8e6ce5">cend</a> () const</td></tr>
<tr class="memdesc:a068f29e62ebc9020b73e090b8d8e6ce5 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an const iterator that addresses the location succeeding the last element in a split-list. <br /></td></tr>
<tr class="separator:a068f29e62ebc9020b73e090b8d8e6ce5 inherit pro_methods_classcds_1_1intrusive_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_classcds_1_1intrusive_1_1_split_list_set"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classcds_1_1intrusive_1_1_split_list_set')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html">cds::intrusive::SplitListSet&lt; cds::urcu::gc&lt; RCU &gt;, split_list::details::wrap_map_traits&lt; Key, Value, Traits &gt;::ordered_list, split_list::details::wrap_map_traits&lt; Key, Value, Traits &gt; &gt;</a></td></tr>
<tr class="memitem:a1272a037a5db273bf9752b1989c735aa inherit pro_attribs_classcds_1_1intrusive_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1272a037a5db273bf9752b1989c735aa"></a>
ordered_list_wrapper&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#a1272a037a5db273bf9752b1989c735aa">m_List</a></td></tr>
<tr class="memdesc:a1272a037a5db273bf9752b1989c735aa inherit pro_attribs_classcds_1_1intrusive_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ordered list containing split-list items. <br /></td></tr>
<tr class="separator:a1272a037a5db273bf9752b1989c735aa inherit pro_attribs_classcds_1_1intrusive_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afac63f0fd6f2da70ed92ab346b01c78e inherit pro_attribs_classcds_1_1intrusive_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afac63f0fd6f2da70ed92ab346b01c78e"></a>
bucket_table&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#afac63f0fd6f2da70ed92ab346b01c78e">m_Buckets</a></td></tr>
<tr class="memdesc:afac63f0fd6f2da70ed92ab346b01c78e inherit pro_attribs_classcds_1_1intrusive_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">bucket table <br /></td></tr>
<tr class="separator:afac63f0fd6f2da70ed92ab346b01c78e inherit pro_attribs_classcds_1_1intrusive_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4352400962bb1154995cf90b907a9c2e inherit pro_attribs_classcds_1_1intrusive_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4352400962bb1154995cf90b907a9c2e"></a>
atomics::atomic&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#a4352400962bb1154995cf90b907a9c2e">m_nBucketCountLog2</a></td></tr>
<tr class="memdesc:a4352400962bb1154995cf90b907a9c2e inherit pro_attribs_classcds_1_1intrusive_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">log2( current bucket count ) <br /></td></tr>
<tr class="separator:a4352400962bb1154995cf90b907a9c2e inherit pro_attribs_classcds_1_1intrusive_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ba29f4fad262a0bdd4be79f82d6a634 inherit pro_attribs_classcds_1_1intrusive_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9ba29f4fad262a0bdd4be79f82d6a634"></a>
atomics::atomic&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#a9ba29f4fad262a0bdd4be79f82d6a634">m_nMaxItemCount</a></td></tr>
<tr class="memdesc:a9ba29f4fad262a0bdd4be79f82d6a634 inherit pro_attribs_classcds_1_1intrusive_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">number of items container can hold, before we have to resize <br /></td></tr>
<tr class="separator:a9ba29f4fad262a0bdd4be79f82d6a634 inherit pro_attribs_classcds_1_1intrusive_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84fc6c8a69c0257f7981710f009cbc70 inherit pro_attribs_classcds_1_1intrusive_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a84fc6c8a69c0257f7981710f009cbc70"></a>
<a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#aa1562c4a7ce60945722157d589606eb0">item_counter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#a84fc6c8a69c0257f7981710f009cbc70">m_ItemCounter</a></td></tr>
<tr class="memdesc:a84fc6c8a69c0257f7981710f009cbc70 inherit pro_attribs_classcds_1_1intrusive_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Item counter. <br /></td></tr>
<tr class="separator:a84fc6c8a69c0257f7981710f009cbc70 inherit pro_attribs_classcds_1_1intrusive_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f973b4ba894e8638e913cec5c97b5cc inherit pro_attribs_classcds_1_1intrusive_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0f973b4ba894e8638e913cec5c97b5cc"></a>
<a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#af1255a3a554c960d60f7c07d8c0d71b9">hash</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#a0f973b4ba894e8638e913cec5c97b5cc">m_HashFunctor</a></td></tr>
<tr class="memdesc:a0f973b4ba894e8638e913cec5c97b5cc inherit pro_attribs_classcds_1_1intrusive_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hash functor. <br /></td></tr>
<tr class="separator:a0f973b4ba894e8638e913cec5c97b5cc inherit pro_attribs_classcds_1_1intrusive_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a924c6d6e02873c566db1ecd198b1807d inherit pro_attribs_classcds_1_1intrusive_1_1_split_list_set"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a924c6d6e02873c566db1ecd198b1807d"></a>
<a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#a6b3b57584e1fd7f743b1ab806c138a72">stat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html#a924c6d6e02873c566db1ecd198b1807d">m_Stat</a></td></tr>
<tr class="memdesc:a924c6d6e02873c566db1ecd198b1807d inherit pro_attribs_classcds_1_1intrusive_1_1_split_list_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal statistics. <br /></td></tr>
<tr class="separator:a924c6d6e02873c566db1ecd198b1807d inherit pro_attribs_classcds_1_1intrusive_1_1_split_list_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class RCU, typename Key, typename Value, class Traits = split_list::traits&gt;<br />
class cds::container::SplitListMap&lt; cds::urcu::gc&lt; RCU &gt;, Key, Value, Traits &gt;</h3>

<p>Split-ordered list map (template specialization for <a class="el" href="namespacecds_1_1urcu.html#cds_urcu_desc">RCU</a>) </p>
<p><a class="anchor" id="cds_nonintrusive_SplitListMap_rcu"></a> Hash table implementation based on split-ordered list algorithm discovered by Ori Shalev and Nir Shavit, see</p><ul>
<li>[2003] Ori Shalev, Nir Shavit "Split-Ordered Lists - Lock-free Resizable Hash Tables"</li>
<li>[2008] Nir Shavit "The Art of Multiprocessor Programming"</li>
</ul>
<p>See <a class="el" href="classcds_1_1intrusive_1_1_split_list_set.html" title="Split-ordered list. ">intrusive::SplitListSet</a> for a brief description of the split-list algorithm.</p>
<p>Template parameters:</p><ul>
<li><code>RCU</code> - one of <a class="el" href="namespacecds_1_1urcu.html#cds_urcu_gc">RCU type</a></li>
<li><code>Key</code> - key type to be stored in the map</li>
<li><code>Value</code> - value type to be stored in the map</li>
<li><code>Traits</code> - type traits, default is <code><a class="el" href="structcds_1_1container_1_1split__list_1_1traits.html" title="SplitListSet traits. ">split_list::traits</a></code>. Instead of declaring <code>split_list::traits</code> -based struct you may apply option-based notation with <code><a class="el" href="structcds_1_1container_1_1split__list_1_1make__traits.html" title="Metafunction converting option list to traits struct. ">split_list::make_traits</a></code> metafunction.</li>
</ul>
<p><b>Iterators</b></p>
<p>The class supports a forward unordered iterator (<a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#aa91b81aead03e9460711e566824a2713">iterator</a> and <a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#a9039192cd438d5b60e8583d510f79e9f">const_iterator</a>). You may iterate over split-list map items only under RCU lock. Only in this case the iterator is thread-safe since while RCU is locked any map's item cannot be reclaimed. The requirement of RCU lock during iterating means that deletion of the elements is not possible.</p>
<dl class="section warning"><dt>Warning</dt><dd>The iterator object cannot be passed between threads. Due to concurrent nature of split-list map it is not guarantee that you can iterate all elements in the map: any concurrent deletion can exclude the element pointed by the iterator from the map, and your iteration can be terminated before end of the map. Therefore, such iteration is more suitable for debugging purposes</dd></dl>
<p>The iterator class supports the following minimalistic interface: </p><div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#aa91b81aead03e9460711e566824a2713">iterator</a> {</div>
<div class="line">    <span class="comment">// Default ctor</span></div>
<div class="line">    <a class="code" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#aa91b81aead03e9460711e566824a2713">iterator</a>();</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Copy ctor</span></div>
<div class="line">    <a class="code" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#aa91b81aead03e9460711e566824a2713">iterator</a>( <a class="code" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#aa91b81aead03e9460711e566824a2713">iterator</a> <span class="keyword">const</span>&amp; s);</div>
<div class="line"></div>
<div class="line">    <a class="code" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#a682405bbab11f0cd0287f763ac14f5a5">value_type</a> * operator -&gt;() <span class="keyword">const</span>;</div>
<div class="line">    <a class="code" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#a682405bbab11f0cd0287f763ac14f5a5">value_type</a>&amp; operator *() <span class="keyword">const</span>;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Pre-increment</span></div>
<div class="line">    <a class="code" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#aa91b81aead03e9460711e566824a2713">iterator</a>&amp; operator ++();</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Copy assignment</span></div>
<div class="line">    <a class="code" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#aa91b81aead03e9460711e566824a2713">iterator</a>&amp; operator = (<span class="keyword">const</span> <a class="code" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#aa91b81aead03e9460711e566824a2713">iterator</a>&amp; src);</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">bool</span> operator ==(<a class="code" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#aa91b81aead03e9460711e566824a2713">iterator</a> <span class="keyword">const</span>&amp; i ) <span class="keyword">const</span>;</div>
<div class="line">    <span class="keywordtype">bool</span> operator !=(<a class="code" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#aa91b81aead03e9460711e566824a2713">iterator</a> <span class="keyword">const</span>&amp; i ) <span class="keyword">const</span>;</div>
<div class="line">};</div>
</div><!-- fragment --><p> Note, the iterator object returned by <a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#a9411b38419a5dc5ce92ba48f48339e52">end</a>, <code>cend</code> member functions points to <code>nullptr</code> and should not be dereferenced.</p>
<dl class="section user"><dt>Usage</dt><dd></dd></dl>
<p>You should decide what garbage collector you want, and what ordered list you want to use. Split-ordered list is original data structure based on an ordered list. Suppose, you want construct split-list map based on <code>cds::urcu::general_buffered&lt;&gt;</code> GC and <code><a class="el" href="classcds_1_1container_1_1_michael_list.html" title="Michael&#39;s ordered list. ">MichaelList</a></code> as ordered list implementation. Your map should map <code>int</code> key to <code>std::string</code> value. So, you beginning your program with following include: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;cds/urcu/general_buffered.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;cds/container/michael_list_rcu.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;cds/container/split_list_map_rcu.h&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">namespace </span>cc = <a class="code" href="namespacecds_1_1container.html">cds::container</a>;</div>
</div><!-- fragment --><p> The inclusion order is important:</p><ul>
<li>first, include one of <a class="el" href="namespacecds_1_1urcu.html#cds_urcu_gc">RCU implementation</a> (<code>cds/urcu/general_buffered.h</code> in our case)</li>
<li>second, include the header of ordered-list implementation (for this example, <code>cds/container/michael_list_rcu.h</code>),</li>
<li>then, the header for RCU-based split-list map <code>cds/container/split_list_map_rcu.h</code>.</li>
</ul>
<p>Now, you should declare traits for split-list map. The main parts of traits are a hash functor for the map key and a comparing functor for ordered list. We use <code>std::hash&lt;int&gt;</code> and <code>std::less&lt;int&gt;</code>.</p>
<p>The second attention: instead of using <code>MichaelList</code> in <code>SplitListMap</code> traits we use a tag <code>ds::contaner::michael_list_tag</code> for the Michael's list. The split-list requires significant support from underlying ordered list class and it is not good idea to dive you into deep implementation details of split-list and ordered list interrelations. The tag paradigm simplifies split-list interface.</p>
<div class="fragment"><div class="line"><span class="comment">// SplitListMap traits</span></div>
<div class="line"><span class="keyword">struct </span>foo_set_traits: <span class="keyword">public</span> cc::split_list::traits</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">typedef</span> cc::michael_list_tag   <a class="code" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#ad4e33ceb9acfeec3ae22f3e54075bf40">ordered_list</a>    ;   <span class="comment">// what type of ordered list we want to use</span></div>
<div class="line">    <span class="keyword">typedef</span> std::hash&lt;int&gt;         <a class="code" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#ad3f287833bda6211df83817d566d526d">hash</a>            ;   <span class="comment">// hash functor for the key stored in split-list map</span></div>
<div class="line"></div>
<div class="line">    <span class="comment">// Type traits for our MichaelList class</span></div>
<div class="line">    <span class="keyword">struct </span>ordered_list_traits: <span class="keyword">public</span> cc::michael_list::traits</div>
<div class="line">    {</div>
<div class="line">        <span class="keyword">typedef</span> std::less&lt;int&gt; less   ;   <span class="comment">// use our std::less predicate as comparator to order list nodes</span></div>
<div class="line">    };</div>
<div class="line">};</div>
</div><!-- fragment --><p>Now you are ready to declare our map class based on <code>SplitListMap</code>: </p><div class="fragment"><div class="line"><span class="keyword">typedef</span> cc::SplitListMap&lt; cds::urcu::gc&lt;cds::urcu::general_buffered&lt;&gt; &gt;, int, std::string, foo_set_traits &gt; int_string_map;</div>
</div><!-- fragment --><p>You may use the modern option-based declaration instead of classic traits-based one: </p><div class="fragment"><div class="line"><span class="keyword">typedef</span> cc::SplitListMap&lt;</div>
<div class="line">    cds::urcu::gc&lt;cds::urcu::general_buffered&lt;&gt; &gt;  <span class="comment">// RCU type</span></div>
<div class="line">    ,<span class="keywordtype">int</span>                    <span class="comment">// key type</span></div>
<div class="line">    ,std::string            <span class="comment">// value type</span></div>
<div class="line">    ,cc::split_list::make_traits&lt;      <span class="comment">// metafunction to build split-list traits</span></div>
<div class="line">        cc::split_list::ordered_list&lt;cc::michael_list_tag&gt;     <span class="comment">// tag for underlying ordered list implementation</span></div>
<div class="line">        ,cc::opt::hash&lt; std::hash&lt;int&gt; &gt;        <span class="comment">// hash functor</span></div>
<div class="line">        ,cc::split_list::ordered_list_traits&lt;    <span class="comment">// ordered list traits desired</span></div>
<div class="line">            cc::michael_list::make_traits&lt;    <span class="comment">// metafunction to build lazy list traits</span></div>
<div class="line">                cc::opt::less&lt; std::less&lt;int&gt; &gt;         <span class="comment">// less-based compare functor</span></div>
<div class="line">            &gt;::type</div>
<div class="line">        &gt;</div>
<div class="line">    &gt;::type</div>
<div class="line">&gt;  int_string_map;</div>
</div><!-- fragment --><p> In case of option-based declaration using <code><a class="el" href="structcds_1_1container_1_1split__list_1_1make__traits.html" title="Metafunction converting option list to traits struct. ">split_list::make_traits</a></code> metafunction the struct <code>foo_set_traits</code> is not required.</p>
<p>Now, the map of type <code>int_string_map</code> is ready to use in your program.</p>
<p>Note that in this example we show only mandatory <code>traits</code> parts, optional ones is the default and they are inherited from <a class="el" href="structcds_1_1container_1_1split__list_1_1traits.html" title="SplitListSet traits. ">cds::container::split_list::traits</a>. There are many other useful options for deep tuning the split-list and ordered-list containers. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="af2b237bfaeb025412114274e5ca57b14"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , typename Key , typename Value , class Traits  = split_list::traits&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef base_class::exempt_ptr <a class="el" href="classcds_1_1container_1_1_split_list_map.html">cds::container::SplitListMap</a>&lt; cds::urcu::gc&lt; RCU &gt;, Key, Value, Traits &gt;::<a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#af2b237bfaeb025412114274e5ca57b14">exempt_ptr</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>pointer to extracted node </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a0392614ddcd0ada7bb78136dc97bbc85"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , typename Key , typename Value , class Traits  = split_list::traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1container_1_1_split_list_map.html">cds::container::SplitListMap</a>&lt; cds::urcu::gc&lt; RCU &gt;, Key, Value, Traits &gt;::<a class="el" href="classcds_1_1container_1_1_split_list_map.html">SplitListMap</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes split-ordered map of default capacity. </p>
<p>The default capacity is defined in bucket table constructor. See <code><a class="el" href="classcds_1_1intrusive_1_1split__list_1_1expandable__bucket__table.html" title="Expandable bucket table. ">intrusive::split_list::expandable_bucket_table</a></code>, <code><a class="el" href="classcds_1_1intrusive_1_1split__list_1_1static__bucket__table.html" title="Static bucket table. ">intrusive::split_list::static_bucket_table</a></code> which selects by <code><a class="el" href="namespacecds_1_1container_1_1split__list.html#ad43684b671934bab89303c17d9af9981" title="Selector of bucket table implementation =- typedef for intrusive::split_list::dynamic_bucket_table. ">split_list::dynamic_bucket_table</a></code> option. </p>

</div>
</div>
<a class="anchor" id="a4bcf30da24623b50f97a1f5e49e2bc55"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , typename Key , typename Value , class Traits  = split_list::traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1container_1_1_split_list_map.html">cds::container::SplitListMap</a>&lt; cds::urcu::gc&lt; RCU &gt;, Key, Value, Traits &gt;::<a class="el" href="classcds_1_1container_1_1_split_list_map.html">SplitListMap</a> </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nItemCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nLoadFactor</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes split-ordered map. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nItemCount</td><td>estimated average item count </td></tr>
    <tr><td class="paramname">nLoadFactor</td><td>load factor - average item count per bucket. Small integer up to 10, default is 1. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a2e9a7ffed701fe108e98e27790782042"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , typename Key , typename Value , class Traits  = split_list::traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#aa91b81aead03e9460711e566824a2713">iterator</a> <a class="el" href="classcds_1_1container_1_1_split_list_map.html">cds::container::SplitListMap</a>&lt; cds::urcu::gc&lt; RCU &gt;, Key, Value, Traits &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a forward iterator addressing the first element in a map. </p>
<p>For empty map</p><div class="fragment"><div class="line"><a class="code" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#a2e9a7ffed701fe108e98e27790782042">begin</a>() == <a class="code" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#a9411b38419a5dc5ce92ba48f48339e52">end</a>() </div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a961195d3d1094db952437c69c7be9767"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , typename Key , typename Value , class Traits  = split_list::traits&gt; </div>
<div class="memtemplate">
template&lt;typename K &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_split_list_map.html">cds::container::SplitListMap</a>&lt; cds::urcu::gc&lt; RCU &gt;, Key, Value, Traits &gt;::contains </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether the map contains <code>key</code>. </p>
<p>The function searches the item with key equal to <code>key</code> and returns <code>true</code> if it is found, and <code>false</code> otherwise.</p>
<p>The function applies RCU lock internally. </p>

</div>
</div>
<a class="anchor" id="a6070cade4eb1619e92abf568b7d1659d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , typename Key , typename Value , class Traits  = split_list::traits&gt; </div>
<div class="memtemplate">
template&lt;typename K , typename Less &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_split_list_map.html">cds::container::SplitListMap</a>&lt; cds::urcu::gc&lt; RCU &gt;, Key, Value, Traits &gt;::contains </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Less&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether the map contains <code>key</code> using <code>pred</code> predicate for searching. </p>
<p>The function is an analog of <code>contains( key )</code> but <code>pred</code> is used for key comparing. <code>Less</code> functor has the interface like <code>std::less</code>. <code>Less</code> must imply the same element order as the comparator used for building the map. </p>

</div>
</div>
<a class="anchor" id="a9c7d84aee09c4327f325c43a43548600"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , typename Key , typename Value , class Traits  = split_list::traits&gt; </div>
<div class="memtemplate">
template&lt;typename K , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_split_list_map.html">cds::container::SplitListMap</a>&lt; cds::urcu::gc&lt; RCU &gt;, Key, Value, Traits &gt;::emplace </td>
          <td>(</td>
          <td class="paramtype">K &amp;&amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For key <code>key</code> inserts data of type <code>mapped_type</code> created in-place from <code>args</code>. </p>
<p><code>key_type</code> should be constructible from type <code>K</code> </p>
<p>The function applies RCU lock internally.</p>
<p>Returns <code>true</code> if inserting successful, <code>false</code> otherwise. </p>

</div>
</div>
<a class="anchor" id="a524158157038188845708bc6058b630f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , typename Key , typename Value , class Traits  = split_list::traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_split_list_map.html">cds::container::SplitListMap</a>&lt; cds::urcu::gc&lt; RCU &gt;, Key, Value, Traits &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the map is empty. </p>
<p>Emptiness is checked by item counting: if item count is zero then the map is empty. Thus, the correct item counting is an important part of the map implementation. </p>

</div>
</div>
<a class="anchor" id="a9411b38419a5dc5ce92ba48f48339e52"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , typename Key , typename Value , class Traits  = split_list::traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#aa91b81aead03e9460711e566824a2713">iterator</a> <a class="el" href="classcds_1_1container_1_1_split_list_map.html">cds::container::SplitListMap</a>&lt; cds::urcu::gc&lt; RCU &gt;, Key, Value, Traits &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator that addresses the location succeeding the last element in a map. </p>
<p>Do not use the value returned by <code>end</code> function to access any item. The returned value can be used only to control reaching the end of the map. For empty map</p><div class="fragment"><div class="line"><a class="code" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#a2e9a7ffed701fe108e98e27790782042">begin</a>() == <a class="code" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#a9411b38419a5dc5ce92ba48f48339e52">end</a>() </div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="aebb1f2b166d2b12f9f2a84344e264003"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , typename Key , typename Value , class Traits  = split_list::traits&gt; </div>
<div class="memtemplate">
template&lt;typename K &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_split_list_map.html">cds::container::SplitListMap</a>&lt; cds::urcu::gc&lt; RCU &gt;, Key, Value, Traits &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deletes <code>key</code> from the map. </p>
<p><a class="anchor" id="cds_nonintrusive_SplitListMap_rcu_erase_val"></a> RCU <code>synchronize</code> method can be called. RCU should not be locked.</p>
<p>Return <code>true</code> if <code>key</code> is found and deleted, <code>false</code> otherwise </p>

</div>
</div>
<a class="anchor" id="a4e0d10489ab3ad0da3fd7ed9aa32e994"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , typename Key , typename Value , class Traits  = split_list::traits&gt; </div>
<div class="memtemplate">
template&lt;typename K , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_split_list_map.html">cds::container::SplitListMap</a>&lt; cds::urcu::gc&lt; RCU &gt;, Key, Value, Traits &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deletes <code>key</code> from the map. </p>
<p><a class="anchor" id="cds_nonintrusive_SplitListMap_rcu_erase_func"></a> The function searches an item with key <code>key</code>, calls <code>f</code> functor and deletes the item. If <code>key</code> is not found, the functor is not called.</p>
<p>The functor <code>Func</code> interface is: </p><div class="fragment"><div class="line"><span class="keyword">struct </span>extractor {</div>
<div class="line">    <span class="keywordtype">void</span> operator()(<a class="code" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#a682405bbab11f0cd0287f763ac14f5a5">value_type</a>&amp; item) { ... }</div>
<div class="line">};</div>
</div><!-- fragment --><p>RCU <code>synchronize</code> method can be called. RCU should not be locked.</p>
<p>Return <code>true</code> if key is found and deleted, <code>false</code> otherwise </p>

</div>
</div>
<a class="anchor" id="a6e6674c5f0b6b4f0f523fcd4cba878c0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , typename Key , typename Value , class Traits  = split_list::traits&gt; </div>
<div class="memtemplate">
template&lt;typename K , typename Less &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_split_list_map.html">cds::container::SplitListMap</a>&lt; cds::urcu::gc&lt; RCU &gt;, Key, Value, Traits &gt;::erase_with </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Less&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deletes the item from the map using <code>pred</code> predicate for searching. </p>
<p>The function is an analog of <a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#cds_nonintrusive_SplitListMap_rcu_erase_val">erase(K const&amp;)</a> but <code>pred</code> is used for key comparing. <code>Less</code> functor has the interface like <code>std::less</code>. <code>Less</code> must imply the same element order as the comparator used for building the map. </p>

</div>
</div>
<a class="anchor" id="a93282b6aba0332c6fce60c3fedf23115"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , typename Key , typename Value , class Traits  = split_list::traits&gt; </div>
<div class="memtemplate">
template&lt;typename K , typename Less , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_split_list_map.html">cds::container::SplitListMap</a>&lt; cds::urcu::gc&lt; RCU &gt;, Key, Value, Traits &gt;::erase_with </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Less&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deletes the item from the map using <code>pred</code> predicate for searching. </p>
<p>The function is an analog of <a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#cds_nonintrusive_SplitListMap_rcu_erase_func">erase(K const&amp;, Func)</a> but <code>pred</code> is used for key comparing. <code>Less</code> functor has the interface like <code>std::less</code>. <code>Less</code> must imply the same element order as the comparator used for building the map. </p>

</div>
</div>
<a class="anchor" id="a42d26ad0509a27b9c8ce94e2ef84aab8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , typename Key , typename Value , class Traits  = split_list::traits&gt; </div>
<div class="memtemplate">
template&lt;typename K &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#af2b237bfaeb025412114274e5ca57b14">exempt_ptr</a> <a class="el" href="classcds_1_1container_1_1_split_list_map.html">cds::container::SplitListMap</a>&lt; cds::urcu::gc&lt; RCU &gt;, Key, Value, Traits &gt;::extract </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extracts an item from the map. </p>
<p><a class="anchor" id="cds_nonintrusive_SplitListMap_rcu_extract"></a>The function searches an item with key equal to <code>key</code> in the map, unlinks it from the map, and returns <a class="el" href="classcds_1_1urcu_1_1exempt__ptr.html">exempt_ptr</a> pointer to the item found. If the item with the key equal to <code>key</code> is not found the function returns an empty <code>exempt_ptr</code>.</p>
<p>Depends on ordered list you should or should not lock RCU before calling of this function:</p><ul>
<li>for the set based on <a class="el" href="classcds_1_1intrusive_1_1_michael_list_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#cds_intrusive_MichaelList_rcu">MichaelList</a> RCU should not be locked</li>
<li>for the set based on <a class="el" href="classcds_1_1intrusive_1_1_lazy_list_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_t_00_01_traits_01_4.html#cds_intrusive_LazyList_rcu">LazyList</a> RCU should be locked See ordered list implementation for details.</li>
</ul>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> cds::urcu::gc&lt; general_buffered&lt;&gt; &gt; rcu;</div>
<div class="line"></div>
<div class="line"><span class="comment">// Split-list set based on MichaelList by default</span></div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="classcds_1_1container_1_1_split_list_map.html">cds::container::SplitListMap&lt; rcu, int, Foo &gt;</a> splitlist_map;</div>
<div class="line"></div>
<div class="line">splitlist_map theMap;</div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">typename</span> splitlist_map::exempt_ptr p;</div>
<div class="line"></div>
<div class="line"><span class="comment">// For MichaelList we should not lock RCU</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Now, you can apply extract function</span></div>
<div class="line">p = theMap.<a class="code" href="classcds_1_1container_1_1_split_list_map.html#a73d89c9fd93e3fb5dd8b1e6ded4216d1">extract</a>( 10 )</div>
<div class="line"><span class="keywordflow">if</span> ( p ) {</div>
<div class="line">    <span class="comment">// do something with p</span></div>
<div class="line">    ...</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// We may safely release p here</span></div>
<div class="line"><span class="comment">// release() passes the pointer to RCU reclamation cycle</span></div>
<div class="line">p.release();</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a7d1f93f1f491242438c6ba9071fd0f69"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , typename Key , typename Value , class Traits  = split_list::traits&gt; </div>
<div class="memtemplate">
template&lt;typename K , typename Less &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#af2b237bfaeb025412114274e5ca57b14">exempt_ptr</a> <a class="el" href="classcds_1_1container_1_1_split_list_map.html">cds::container::SplitListMap</a>&lt; cds::urcu::gc&lt; RCU &gt;, Key, Value, Traits &gt;::extract_with </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Less&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extracts an item from the map using <code>pred</code> predicate for searching. </p>
<p>The function is an analog of <code><a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#a42d26ad0509a27b9c8ce94e2ef84aab8" title="Extracts an item from the map. ">extract(K const&amp;)</a></code> but <code>pred</code> is used for key comparing. <code>Less</code> functor has the interface like <code>std::less</code>. <code>pred</code> must imply the same element order as the comparator used for building the map. </p>

</div>
</div>
<a class="anchor" id="ab1b497490353d85557018c5b908f82f0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , typename Key , typename Value , class Traits  = split_list::traits&gt; </div>
<div class="memtemplate">
template&lt;typename K , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_split_list_map.html">cds::container::SplitListMap</a>&lt; cds::urcu::gc&lt; RCU &gt;, Key, Value, Traits &gt;::find </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the key <code>key</code>. </p>
<p><a class="anchor" id="cds_nonintrusive_SplitListMap_rcu_find_cfunc"></a> The function searches the item with key equal to <code>key</code> and calls the functor <code>f</code> for item found. The interface of <code>Func</code> functor is: </p><div class="fragment"><div class="line"><span class="keyword">struct </span>functor {</div>
<div class="line">    <span class="keywordtype">void</span> operator()( <a class="code" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#a682405bbab11f0cd0287f763ac14f5a5">value_type</a>&amp; item );</div>
<div class="line">};</div>
</div><!-- fragment --><p> where <code>item</code> is the item found.</p>
<p>The functor may change <code>item.second</code>. Note that the functor is only guarantee that <code>item</code> cannot be disposed during functor is executing. The functor does not serialize simultaneous access to the map's <code>item</code>. If such access is possible you must provide your own synchronization schema on item level to exclude unsafe item modifications.</p>
<p>The function applies RCU lock internally.</p>
<p>The function returns <code>true</code> if <code>key</code> is found, <code>false</code> otherwise. </p>

</div>
</div>
<a class="anchor" id="ad593abbddb349e7e7d5642269f70d0cd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , typename Key , typename Value , class Traits  = split_list::traits&gt; </div>
<div class="memtemplate">
template&lt;typename K , typename Less , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_split_list_map.html">cds::container::SplitListMap</a>&lt; cds::urcu::gc&lt; RCU &gt;, Key, Value, Traits &gt;::find_with </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Less&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the key <code>key</code> using <code>pred</code> predicate for searching. </p>
<p>The function is an analog of <a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#cds_nonintrusive_SplitListMap_rcu_find_cfunc">find(K const&amp;, Func)</a> but <code>pred</code> is used for key comparing. <code>Less</code> functor has the interface like <code>std::less</code>. <code>Less</code> must imply the same element order as the comparator used for building the map. </p>

</div>
</div>
<a class="anchor" id="aeee9a675a958ee274c2de200432a00ca"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , typename Key , typename Value , class Traits  = split_list::traits&gt; </div>
<div class="memtemplate">
template&lt;typename K &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#afa307bb5de70335cf963bb9195017f62">raw_ptr</a> <a class="el" href="classcds_1_1container_1_1_split_list_map.html">cds::container::SplitListMap</a>&lt; cds::urcu::gc&lt; RCU &gt;, Key, Value, Traits &gt;::get </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds <code>key</code> and return the item found. </p>
<p><a class="anchor" id="cds_intrusive_SplitListMap_rcu_get"></a>The function searches the item with key equal to <code>key</code> and returns the pointer to item found. If <code>key</code> is not found it returns empty <code>raw_ptr</code>.</p>
<p>Note the compare functor should accept a parameter of type <code>K</code> that can be not the same as <code>value_type</code>.</p>
<p>RCU should be locked before call of this function. Returned item is valid only while RCU is locked: </p><div class="fragment"><div class="line"><span class="keyword">typedef</span> cds::urcu::gc&lt; general_buffered&lt;&gt; &gt; rcu;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="classcds_1_1container_1_1_split_list_map.html">cds::container::SplitListMap&lt; rcu, int, Foo &gt;</a> splitlist_map;</div>
<div class="line">splitlist_map theMap;</div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Lock RCU</span></div>
<div class="line">    <span class="keyword">typename</span> splitlist_map::rcu_lock lock;</div>
<div class="line"></div>
<div class="line">    <span class="keyword">typename</span> splitlist_map::raw_ptr pVal = theMap.<a class="code" href="classcds_1_1container_1_1_split_list_map.html#a15d2b96d25ebd4bc4f622dafd4da87c9">get</a>( 5 );</div>
<div class="line">    <span class="keywordflow">if</span> ( pVal ) {</div>
<div class="line">        <span class="comment">// Deal with pVal</span></div>
<div class="line">        <span class="comment">//...</span></div>
<div class="line">    }</div>
<div class="line">    <span class="comment">// Unlock RCU by rcu_lock destructor</span></div>
<div class="line">    <span class="comment">// pVal can be retired by disposer at any time after RCU has been unlocked</span></div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a9bee6446a58cf200ac613d54c24c8b9a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , typename Key , typename Value , class Traits  = split_list::traits&gt; </div>
<div class="memtemplate">
template&lt;typename K , typename Less &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#afa307bb5de70335cf963bb9195017f62">raw_ptr</a> <a class="el" href="classcds_1_1container_1_1_split_list_map.html">cds::container::SplitListMap</a>&lt; cds::urcu::gc&lt; RCU &gt;, Key, Value, Traits &gt;::get_with </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Less&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds <code>key</code> with predicate specified and return the item found. </p>
<p>The function is an analog of <a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#cds_intrusive_SplitListMap_rcu_get">get(K const&amp;)</a> but <code>pred</code> is used for comparing the keys.</p>
<p><code>Less</code> functor has the semantics like <code>std::less</code> but should take arguments of type <a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#a682405bbab11f0cd0287f763ac14f5a5">value_type</a> and <code>K</code> in any order. <code>pred</code> must imply the same element order as the comparator used for building the map. </p>

</div>
</div>
<a class="anchor" id="a9732e42943b07d8e216d25c42def7f01"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , typename Key , typename Value , class Traits  = split_list::traits&gt; </div>
<div class="memtemplate">
template&lt;typename K &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_split_list_map.html">cds::container::SplitListMap</a>&lt; cds::urcu::gc&lt; RCU &gt;, Key, Value, Traits &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts new node with key and default value. </p>
<p>The function creates a node with <code>key</code> and the default value, and then inserts the node created into the map.</p>
<p>Preconditions:</p><ul>
<li>The <code>key_type</code> should be constructible from value of type <code>K</code>.</li>
<li>The <code>mapped_type</code> should be default-constructible.</li>
</ul>
<p>The function applies RCU lock internally.</p>
<p>Returns <code>true</code> if inserting successful, <code>false</code> otherwise. </p>

</div>
</div>
<a class="anchor" id="a37e1da831a875c8ef38964f7a63d68fb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , typename Key , typename Value , class Traits  = split_list::traits&gt; </div>
<div class="memtemplate">
template&lt;typename K , typename V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_split_list_map.html">cds::container::SplitListMap</a>&lt; cds::urcu::gc&lt; RCU &gt;, Key, Value, Traits &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">V const &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts new node. </p>
<p>The function creates a node with copy of <code>val</code> value and then inserts the node into the map.</p>
<p>Preconditions:</p><ul>
<li>The <code>key_type</code> should be constructible from <code>key</code> of type <code>K</code>.</li>
<li>The <code>mapped_type</code> should be constructible from <code>val</code> of type <code>V</code>.</li>
</ul>
<p>The function applies RCU lock internally.</p>
<p>Returns <code>true</code> if <code>val</code> is inserted into the map, <code>false</code> otherwise. </p>

</div>
</div>
<a class="anchor" id="a977a9f295cffc445355b5ac4c23bdf39"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , typename Key , typename Value , class Traits  = split_list::traits&gt; </div>
<div class="memtemplate">
template&lt;typename K , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_split_list_map.html">cds::container::SplitListMap</a>&lt; cds::urcu::gc&lt; RCU &gt;, Key, Value, Traits &gt;::insert_with </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts new node and initialize it by a functor. </p>
<p>This function inserts new node with key <code>key</code> and if inserting is successful then it calls <code>func</code> functor with signature </p><div class="fragment"><div class="line"><span class="keyword">struct </span>functor {</div>
<div class="line">    <span class="keywordtype">void</span> operator()( <a class="code" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#a682405bbab11f0cd0287f763ac14f5a5">value_type</a>&amp; item );</div>
<div class="line">};</div>
</div><!-- fragment --><p>The argument <code>item</code> of user-defined functor <code>func</code> is the reference to the map's item inserted:</p><ul>
<li><code>item.first</code> is a const reference to item's key that cannot be changed.</li>
<li><code>item.second</code> is a reference to item's value that may be changed.</li>
</ul>
<p>It should be keep in mind that concurrent modifications of <code><code>item.second</code></code> in <code>func</code> body should be careful. You shouldf guarantee that during changing item's value in <code>func</code> no any other changes could be made on this <code>item</code> by concurrent threads.</p>
<p><code>func</code> is called only if inserting is successful.</p>
<p>The function allows to split creating of new item into two part:</p><ul>
<li>create item from <code>key</code>;</li>
<li>insert new item into the map;</li>
<li>if inserting is successful, initialize the value of item by calling <code>func</code> functor</li>
</ul>
<p>This can be useful if complete initialization of object of <code>mapped_type</code> is heavyweight and it is preferable that the initialization should be completed only if inserting is successful.</p>
<p>The function applies RCU lock internally. </p>

</div>
</div>
<a class="anchor" id="a04090173571564ec3983bd37b19699bb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , typename Key , typename Value , class Traits  = split_list::traits&gt; </div>
<div class="memtemplate">
template&lt;typename K , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;bool, bool&gt; <a class="el" href="classcds_1_1container_1_1_split_list_map.html">cds::container::SplitListMap</a>&lt; cds::urcu::gc&lt; RCU &gt;, Key, Value, Traits &gt;::update </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bAllowInsert</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Updates data by <code>key</code>. </p>
<p>The operation performs inserting or replacing the element with lock-free manner.</p>
<p>If the <code>key</code> not found in the map, then the new item created from <code>key</code> will be inserted into the map iff <code>bAllowInsert</code> is <code>true</code>. (note that in this case the <a class="el" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#a9e25dd8f881eb1af7bf624a64330ab18">key_type</a> should be constructible from type <code>K</code>). Otherwise, if <code>key</code> is found, the functor <code>func</code> is called with item found.</p>
<p>The functor <code>Func</code> signature is: </p><div class="fragment"><div class="line"><span class="keyword">struct </span>my_functor {</div>
<div class="line">    <span class="keywordtype">void</span> operator()( <span class="keywordtype">bool</span> bNew, <a class="code" href="classcds_1_1container_1_1_split_list_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_value_00_01_traits_01_4.html#a682405bbab11f0cd0287f763ac14f5a5">value_type</a>&amp; item );</div>
<div class="line">};</div>
</div><!-- fragment --><p> with arguments:</p><ul>
<li><code>bNew</code> - <code>true</code> if the item has been inserted, <code>false</code> otherwise</li>
<li><code>item</code> - the item found or inserted</li>
</ul>
<p>The functor may change any fields of the <code>item.second</code> that is <code>mapped_type</code>.</p>
<p>The function applies RCU lock internally.</p>
<p>Returns <code> std::pair&lt;bool, bool&gt; </code> where <code>first</code> is true if operation is successfull, <code>second</code> is true if new item has been added or <code>false</code> if the item with <code>key</code> already exists.</p>
<dl class="section warning"><dt>Warning</dt><dd>For <a class="el" href="classcds_1_1container_1_1_michael_k_v_list.html#cds_nonintrusive_MichaelKVList_gc">MichaelKVList</a> as the ordered list see <a class="el" href="namespacecds_1_1intrusive.html#cds_intrusive_item_creating">insert item troubleshooting</a>. <a class="el" href="classcds_1_1container_1_1_lazy_k_v_list.html#cds_nonintrusive_LazyKVList_gc">LazyKVList</a> provides exclusive access to inserted item and does not require any node-level synchronization. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>cds/container/split_list_map_rcu.h</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<hr/>
<div align="right">
  <b>cds</b> <b>2.1.0</b> 
  Developed by <i>Maxim Khizhinsky aka khizmax</i> 2007 - 2015
  <br/>
  <i>Autogenerated Wed Jan 6 2016 16:00:41 by Doxygen 1.8.10</i>
</div>
</body>
</html>
