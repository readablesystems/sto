<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>cds: cds::container::BronsonAVLTreeMap&lt; cds::urcu::gc&lt; RCU &gt;, Key, T *, Traits &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">cds
   &#160;<span id="projectnumber">2.1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="classes.html"><span>Data&#160;Structure&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Data&#160;Fields</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a>  </div>
  <div class="headertitle">
<div class="title">cds::container::BronsonAVLTreeMap&lt; cds::urcu::gc&lt; RCU &gt;, Key, T *, Traits &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__cds__nonintrusive__containers.html">Non-intrusive containers</a> &raquo; <a class="el" href="group__cds__nonintrusive__map.html">Map</a><a class="el" href="group__cds__nonintrusive__containers.html">Non-intrusive containers</a> &raquo;  &#124; <a class="el" href="group__cds__nonintrusive__tree.html">Tree</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Bronson et al AVL-tree (RCU specialization for storing pointer to values)  
 <a href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4.html#details">More...</a></p>

<p><code>#include &lt;cds/container/bronson_avltree_map_rcu.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for cds::container::BronsonAVLTreeMap&lt; cds::urcu::gc&lt; RCU &gt;, Key, T *, Traits &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4.png" usemap="#cds::container::BronsonAVLTreeMap&lt; cds::urcu::gc&lt; RCU &gt;, Key, T *, Traits &gt;_map" alt=""/>
  <map id="cds::container::BronsonAVLTreeMap&lt; cds::urcu::gc&lt; RCU &gt;, Key, T *, Traits &gt;_map" name="cds::container::BronsonAVLTreeMap&lt; cds::urcu::gc&lt; RCU &gt;, Key, T *, Traits &gt;_map">
<area href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html" title="Bronson et al AVL-tree (RCU specialization) " alt="cds::container::BronsonAVLTreeMap&lt; cds::urcu::gc&lt; RCU &gt;, Key, T, Traits &gt;" shape="rect" coords="0,56,464,80"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:aaed9b1acee4c48f573a800a921289375"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaed9b1acee4c48f573a800a921289375"></a>
typedef cds::urcu::gc&lt; RCU &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4.html#aaed9b1acee4c48f573a800a921289375">gc</a></td></tr>
<tr class="memdesc:aaed9b1acee4c48f573a800a921289375"><td class="mdescLeft">&#160;</td><td class="mdescRight">RCU Garbage collector. <br /></td></tr>
<tr class="separator:aaed9b1acee4c48f573a800a921289375"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1241636918651c696267269ff61e682"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af1241636918651c696267269ff61e682"></a>
typedef Key&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4.html#af1241636918651c696267269ff61e682">key_type</a></td></tr>
<tr class="memdesc:af1241636918651c696267269ff61e682"><td class="mdescLeft">&#160;</td><td class="mdescRight">type of a key stored in the map <br /></td></tr>
<tr class="separator:af1241636918651c696267269ff61e682"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa955a3d4f22ee5ef4026606f9b7eb487"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa955a3d4f22ee5ef4026606f9b7eb487"></a>
typedef T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4.html#aa955a3d4f22ee5ef4026606f9b7eb487">mapped_type</a></td></tr>
<tr class="memdesc:aa955a3d4f22ee5ef4026606f9b7eb487"><td class="mdescLeft">&#160;</td><td class="mdescRight">type of value stored in the map <br /></td></tr>
<tr class="separator:aa955a3d4f22ee5ef4026606f9b7eb487"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14b954a25ba303fe21eddec2652e7fbc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a14b954a25ba303fe21eddec2652e7fbc"></a>
typedef Traits&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4.html#a14b954a25ba303fe21eddec2652e7fbc">traits</a></td></tr>
<tr class="memdesc:a14b954a25ba303fe21eddec2652e7fbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traits template parameter. <br /></td></tr>
<tr class="separator:a14b954a25ba303fe21eddec2652e7fbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10047d6018844bfb6d4d4577fd7d7c39"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a10047d6018844bfb6d4d4577fd7d7c39"></a>
typedef implementation_defined&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4.html#a10047d6018844bfb6d4d4577fd7d7c39">key_comparator</a></td></tr>
<tr class="memdesc:a10047d6018844bfb6d4d4577fd7d7c39"><td class="mdescLeft">&#160;</td><td class="mdescRight">key compare functor based on <code>Traits::compare</code> and <code>Traits::less</code> <br /></td></tr>
<tr class="separator:a10047d6018844bfb6d4d4577fd7d7c39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bbae578888bd3706652cdaf6b42d72c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8bbae578888bd3706652cdaf6b42d72c"></a>
typedef traits::item_counter&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4.html#a8bbae578888bd3706652cdaf6b42d72c">item_counter</a></td></tr>
<tr class="memdesc:a8bbae578888bd3706652cdaf6b42d72c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Item counting policy. <br /></td></tr>
<tr class="separator:a8bbae578888bd3706652cdaf6b42d72c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb4ea0faa83564f45c85dcd1f1ed02f4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acb4ea0faa83564f45c85dcd1f1ed02f4"></a>
typedef traits::memory_model&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4.html#acb4ea0faa83564f45c85dcd1f1ed02f4">memory_model</a></td></tr>
<tr class="memdesc:acb4ea0faa83564f45c85dcd1f1ed02f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Memory ordering, see <code><a class="el" href="structcds_1_1opt_1_1memory__model.html" title="[type-option] Option setter for C++ memory model ">cds::opt::memory_model</a></code> option. <br /></td></tr>
<tr class="separator:acb4ea0faa83564f45c85dcd1f1ed02f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7520161e80670a6720e79530ee6c985f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7520161e80670a6720e79530ee6c985f"></a>
typedef traits::node_allocator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4.html#a7520161e80670a6720e79530ee6c985f">node_allocator_type</a></td></tr>
<tr class="memdesc:a7520161e80670a6720e79530ee6c985f"><td class="mdescLeft">&#160;</td><td class="mdescRight">allocator for maintaining internal nodes <br /></td></tr>
<tr class="separator:a7520161e80670a6720e79530ee6c985f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab498349cd9695a96cdbc21e11a2f9941"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab498349cd9695a96cdbc21e11a2f9941"></a>
typedef traits::stat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4.html#ab498349cd9695a96cdbc21e11a2f9941">stat</a></td></tr>
<tr class="memdesc:ab498349cd9695a96cdbc21e11a2f9941"><td class="mdescLeft">&#160;</td><td class="mdescRight">internal statistics <br /></td></tr>
<tr class="separator:ab498349cd9695a96cdbc21e11a2f9941"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab18c3df8b3b2dc4a21db03d2153c6248"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab18c3df8b3b2dc4a21db03d2153c6248"></a>
typedef traits::rcu_check_deadlock&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4.html#ab18c3df8b3b2dc4a21db03d2153c6248">rcu_check_deadlock</a></td></tr>
<tr class="memdesc:ab18c3df8b3b2dc4a21db03d2153c6248"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deadlock checking policy. <br /></td></tr>
<tr class="separator:ab18c3df8b3b2dc4a21db03d2153c6248"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad91532ad46333ea0f3e5aadc67c9f03"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aad91532ad46333ea0f3e5aadc67c9f03"></a>
typedef traits::back_off&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4.html#aad91532ad46333ea0f3e5aadc67c9f03">back_off</a></td></tr>
<tr class="memdesc:aad91532ad46333ea0f3e5aadc67c9f03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Back-off strategy. <br /></td></tr>
<tr class="separator:aad91532ad46333ea0f3e5aadc67c9f03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa1d0f97e8cb375833a76cc1e7d1e8d3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaa1d0f97e8cb375833a76cc1e7d1e8d3"></a>
typedef traits::disposer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4.html#aaa1d0f97e8cb375833a76cc1e7d1e8d3">disposer</a></td></tr>
<tr class="memdesc:aaa1d0f97e8cb375833a76cc1e7d1e8d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Value disposer. <br /></td></tr>
<tr class="separator:aaa1d0f97e8cb375833a76cc1e7d1e8d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b081575c5536963822350e265a44ad6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6b081575c5536963822350e265a44ad6"></a>
typedef traits::sync_monitor&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4.html#a6b081575c5536963822350e265a44ad6">sync_monitor</a></td></tr>
<tr class="memdesc:a6b081575c5536963822350e265a44ad6"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="cds_sync_monitor.html">Synchronization monitor</a> type for node-level locking <br /></td></tr>
<tr class="separator:a6b081575c5536963822350e265a44ad6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad151e631864e27a386826e4f942861ae"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad151e631864e27a386826e4f942861ae"></a>
typedef <a class="el" href="classcds_1_1urcu_1_1exempt__ptr.html">cds::urcu::exempt_ptr</a>&lt; <a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4.html#aaed9b1acee4c48f573a800a921289375">gc</a>, T, T, <a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4.html#aaa1d0f97e8cb375833a76cc1e7d1e8d3">disposer</a>, void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4.html#ad151e631864e27a386826e4f942861ae">exempt_ptr</a></td></tr>
<tr class="memdesc:ad151e631864e27a386826e4f942861ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returned pointer to <code>mapped_type</code> of extracted node. <br /></td></tr>
<tr class="separator:ad151e631864e27a386826e4f942861ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf85b466c8c79656546ea8193c37ccfc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abf85b466c8c79656546ea8193c37ccfc"></a>
typedef gc::scoped_lock&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4.html#abf85b466c8c79656546ea8193c37ccfc">rcu_lock</a></td></tr>
<tr class="memdesc:abf85b466c8c79656546ea8193c37ccfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">RCU scoped lock. <br /></td></tr>
<tr class="separator:abf85b466c8c79656546ea8193c37ccfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a9311a5a3a29859a04f371b99ad70843c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9311a5a3a29859a04f371b99ad70843c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4.html#a9311a5a3a29859a04f371b99ad70843c">BronsonAVLTreeMap</a> ()</td></tr>
<tr class="memdesc:a9311a5a3a29859a04f371b99ad70843c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates empty map. <br /></td></tr>
<tr class="separator:a9311a5a3a29859a04f371b99ad70843c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3929dfff3cba5fa08766ea0ae43c241b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3929dfff3cba5fa08766ea0ae43c241b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4.html#a3929dfff3cba5fa08766ea0ae43c241b">~BronsonAVLTreeMap</a> ()</td></tr>
<tr class="memdesc:a3929dfff3cba5fa08766ea0ae43c241b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys the map. <br /></td></tr>
<tr class="separator:a3929dfff3cba5fa08766ea0ae43c241b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13226bcab1d76e8cf24b0038bb482e98"><td class="memTemplParams" colspan="2">template&lt;typename K &gt; </td></tr>
<tr class="memitem:a13226bcab1d76e8cf24b0038bb482e98"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4.html#a13226bcab1d76e8cf24b0038bb482e98">insert</a> (K const &amp;key, <a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4.html#aa955a3d4f22ee5ef4026606f9b7eb487">mapped_type</a> pVal)</td></tr>
<tr class="memdesc:a13226bcab1d76e8cf24b0038bb482e98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new node.  <a href="#a13226bcab1d76e8cf24b0038bb482e98">More...</a><br /></td></tr>
<tr class="separator:a13226bcab1d76e8cf24b0038bb482e98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c09bb36626732fc37ecf54981bd0a96"><td class="memTemplParams" colspan="2">template&lt;typename K &gt; </td></tr>
<tr class="memitem:a6c09bb36626732fc37ecf54981bd0a96"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; bool, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4.html#a6c09bb36626732fc37ecf54981bd0a96">update</a> (K const &amp;key, <a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4.html#aa955a3d4f22ee5ef4026606f9b7eb487">mapped_type</a> pVal, bool bInsert=true)</td></tr>
<tr class="memdesc:a6c09bb36626732fc37ecf54981bd0a96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the value for <code>key</code>.  <a href="#a6c09bb36626732fc37ecf54981bd0a96">More...</a><br /></td></tr>
<tr class="separator:a6c09bb36626732fc37ecf54981bd0a96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c94f4a0fb5127e5ff5443f5c3367119"><td class="memTemplParams" colspan="2">template&lt;typename K &gt; </td></tr>
<tr class="memitem:a0c94f4a0fb5127e5ff5443f5c3367119"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4.html#a0c94f4a0fb5127e5ff5443f5c3367119">erase</a> (K const &amp;key)</td></tr>
<tr class="memdesc:a0c94f4a0fb5127e5ff5443f5c3367119"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete <code>key</code> from the map.  <a href="#a0c94f4a0fb5127e5ff5443f5c3367119">More...</a><br /></td></tr>
<tr class="separator:a0c94f4a0fb5127e5ff5443f5c3367119"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0366890161a2a550abfc858eb85d1ccf"><td class="memTemplParams" colspan="2">template&lt;typename K , typename Less &gt; </td></tr>
<tr class="memitem:a0366890161a2a550abfc858eb85d1ccf"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4.html#a0366890161a2a550abfc858eb85d1ccf">erase_with</a> (K const &amp;key, Less pred)</td></tr>
<tr class="memdesc:a0366890161a2a550abfc858eb85d1ccf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the item from the map using <code>pred</code> predicate for searching.  <a href="#a0366890161a2a550abfc858eb85d1ccf">More...</a><br /></td></tr>
<tr class="separator:a0366890161a2a550abfc858eb85d1ccf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32fa503a18c8117edc55099ea6da871e"><td class="memTemplParams" colspan="2">template&lt;typename K , typename Func &gt; </td></tr>
<tr class="memitem:a32fa503a18c8117edc55099ea6da871e"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4.html#a32fa503a18c8117edc55099ea6da871e">erase</a> (K const &amp;key, Func f)</td></tr>
<tr class="memdesc:a32fa503a18c8117edc55099ea6da871e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete <code>key</code> from the map.  <a href="#a32fa503a18c8117edc55099ea6da871e">More...</a><br /></td></tr>
<tr class="separator:a32fa503a18c8117edc55099ea6da871e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7767e7ab2b47adf96ddd91b4215f0edd"><td class="memTemplParams" colspan="2">template&lt;typename K , typename Less , typename Func &gt; </td></tr>
<tr class="memitem:a7767e7ab2b47adf96ddd91b4215f0edd"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4.html#a7767e7ab2b47adf96ddd91b4215f0edd">erase_with</a> (K const &amp;key, Less pred, Func f)</td></tr>
<tr class="memdesc:a7767e7ab2b47adf96ddd91b4215f0edd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the item from the map using <code>pred</code> predicate for searching.  <a href="#a7767e7ab2b47adf96ddd91b4215f0edd">More...</a><br /></td></tr>
<tr class="separator:a7767e7ab2b47adf96ddd91b4215f0edd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad66eab7b97360e818168b13cb2665388"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4.html#ad151e631864e27a386826e4f942861ae">exempt_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4.html#ad66eab7b97360e818168b13cb2665388">extract_min</a> ()</td></tr>
<tr class="memdesc:ad66eab7b97360e818168b13cb2665388"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts a value with minimal key from the map.  <a href="#ad66eab7b97360e818168b13cb2665388">More...</a><br /></td></tr>
<tr class="separator:ad66eab7b97360e818168b13cb2665388"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9c3f0993ad9fa44530c9a2caccfeb60"><td class="memTemplParams" colspan="2">template&lt;typename Func &gt; </td></tr>
<tr class="memitem:ac9c3f0993ad9fa44530c9a2caccfeb60"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4.html#ad151e631864e27a386826e4f942861ae">exempt_ptr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4.html#ac9c3f0993ad9fa44530c9a2caccfeb60">extract_min</a> (Func f)</td></tr>
<tr class="memdesc:ac9c3f0993ad9fa44530c9a2caccfeb60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts minimal key key and corresponding value.  <a href="#ac9c3f0993ad9fa44530c9a2caccfeb60">More...</a><br /></td></tr>
<tr class="separator:ac9c3f0993ad9fa44530c9a2caccfeb60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b5e169c62720516c5c9d4c1f3b607b3"><td class="memTemplParams" colspan="2">template&lt;typename Func &gt; </td></tr>
<tr class="memitem:a3b5e169c62720516c5c9d4c1f3b607b3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4.html#ad151e631864e27a386826e4f942861ae">exempt_ptr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4.html#a3b5e169c62720516c5c9d4c1f3b607b3">extract_max</a> (Func f)</td></tr>
<tr class="memdesc:a3b5e169c62720516c5c9d4c1f3b607b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts minimal key key and corresponding value.  <a href="#a3b5e169c62720516c5c9d4c1f3b607b3">More...</a><br /></td></tr>
<tr class="separator:a3b5e169c62720516c5c9d4c1f3b607b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec008afbe0336c747abad6d61448f640"><td class="memTemplParams" colspan="2">template&lt;typename K , typename Func &gt; </td></tr>
<tr class="memitem:aec008afbe0336c747abad6d61448f640"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4.html#aec008afbe0336c747abad6d61448f640">find</a> (K const &amp;key, Func f)</td></tr>
<tr class="memdesc:aec008afbe0336c747abad6d61448f640"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the maximal key and corresponding value.  <a href="#aec008afbe0336c747abad6d61448f640">More...</a><br /></td></tr>
<tr class="separator:aec008afbe0336c747abad6d61448f640"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4f832d644c8cb32d2566b818887b689"><td class="memTemplParams" colspan="2">template&lt;typename K , typename Less , typename Func &gt; </td></tr>
<tr class="memitem:ac4f832d644c8cb32d2566b818887b689"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4.html#ac4f832d644c8cb32d2566b818887b689">find_with</a> (K const &amp;key, Less pred, Func f)</td></tr>
<tr class="memdesc:ac4f832d644c8cb32d2566b818887b689"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the key <code>val</code> using <code>pred</code> predicate for searching.  <a href="#ac4f832d644c8cb32d2566b818887b689">More...</a><br /></td></tr>
<tr class="separator:ac4f832d644c8cb32d2566b818887b689"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b5e850207b41f5dce6af6468fb5dbaf"><td class="memTemplParams" colspan="2">template&lt;typename K &gt; </td></tr>
<tr class="memitem:a0b5e850207b41f5dce6af6468fb5dbaf"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4.html#a0b5e850207b41f5dce6af6468fb5dbaf">contains</a> (K const &amp;key)</td></tr>
<tr class="memdesc:a0b5e850207b41f5dce6af6468fb5dbaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the map contains <code>key</code>.  <a href="#a0b5e850207b41f5dce6af6468fb5dbaf">More...</a><br /></td></tr>
<tr class="separator:a0b5e850207b41f5dce6af6468fb5dbaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c2287d7dbb737ba2911881e52a3aa32"><td class="memTemplParams" colspan="2">template&lt;typename K , typename Less &gt; </td></tr>
<tr class="memitem:a4c2287d7dbb737ba2911881e52a3aa32"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4.html#a4c2287d7dbb737ba2911881e52a3aa32">contains</a> (K const &amp;key, Less pred)</td></tr>
<tr class="memdesc:a4c2287d7dbb737ba2911881e52a3aa32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the map contains <code>key</code> using <code>pred</code> predicate for searching.  <a href="#a4c2287d7dbb737ba2911881e52a3aa32">More...</a><br /></td></tr>
<tr class="separator:a4c2287d7dbb737ba2911881e52a3aa32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a498154314d46257923293f1a580962d0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4.html#a498154314d46257923293f1a580962d0">clear</a> ()</td></tr>
<tr class="memdesc:a498154314d46257923293f1a580962d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the tree (thread safe, not atomic)  <a href="#a498154314d46257923293f1a580962d0">More...</a><br /></td></tr>
<tr class="separator:a498154314d46257923293f1a580962d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac08f24b55ec8cfecde4e9360caab8f75"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4.html#ac08f24b55ec8cfecde4e9360caab8f75">unsafe_clear</a> ()</td></tr>
<tr class="memdesc:ac08f24b55ec8cfecde4e9360caab8f75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the tree (not thread safe)  <a href="#ac08f24b55ec8cfecde4e9360caab8f75">More...</a><br /></td></tr>
<tr class="separator:ac08f24b55ec8cfecde4e9360caab8f75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cfe1823367ada09a1d67fae95766e48"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0cfe1823367ada09a1d67fae95766e48"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4.html#a0cfe1823367ada09a1d67fae95766e48">empty</a> () const </td></tr>
<tr class="memdesc:a0cfe1823367ada09a1d67fae95766e48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the map is empty. <br /></td></tr>
<tr class="separator:a0cfe1823367ada09a1d67fae95766e48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f61cb425b6f6b7fc34968010c04d2cd"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4.html#a5f61cb425b6f6b7fc34968010c04d2cd">size</a> () const </td></tr>
<tr class="memdesc:a5f61cb425b6f6b7fc34968010c04d2cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns item count in the map.  <a href="#a5f61cb425b6f6b7fc34968010c04d2cd">More...</a><br /></td></tr>
<tr class="separator:a5f61cb425b6f6b7fc34968010c04d2cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d6783a45b7735c174bf37e60d67dd55"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4d6783a45b7735c174bf37e60d67dd55"></a>
<a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4.html#ab498349cd9695a96cdbc21e11a2f9941">stat</a> const &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4.html#a4d6783a45b7735c174bf37e60d67dd55">statistics</a> () const </td></tr>
<tr class="memdesc:a4d6783a45b7735c174bf37e60d67dd55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns const reference to internal statistics. <br /></td></tr>
<tr class="separator:a4d6783a45b7735c174bf37e60d67dd55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7e4233fd89fa018b0b9419f490b8b71"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac7e4233fd89fa018b0b9419f490b8b71"></a>
<a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4.html#a6b081575c5536963822350e265a44ad6">sync_monitor</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4.html#ac7e4233fd89fa018b0b9419f490b8b71">monitor</a> ()</td></tr>
<tr class="memdesc:ac7e4233fd89fa018b0b9419f490b8b71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns reference to <code>sync_monitor</code> object. <br /></td></tr>
<tr class="separator:ac7e4233fd89fa018b0b9419f490b8b71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91b0aeeecf30f6faee707119472dad4d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4.html#a91b0aeeecf30f6faee707119472dad4d">check_consistency</a> () const </td></tr>
<tr class="memdesc:a91b0aeeecf30f6faee707119472dad4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks internal consistency (not atomic, not thread-safe)  <a href="#a91b0aeeecf30f6faee707119472dad4d">More...</a><br /></td></tr>
<tr class="separator:a91b0aeeecf30f6faee707119472dad4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07a3428f7ee2f0ddcb1c27f4d7492054"><td class="memTemplParams" colspan="2">template&lt;typename Func &gt; </td></tr>
<tr class="memitem:a07a3428f7ee2f0ddcb1c27f4d7492054"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4.html#a07a3428f7ee2f0ddcb1c27f4d7492054">check_consistency</a> (Func f) const </td></tr>
<tr class="memdesc:a07a3428f7ee2f0ddcb1c27f4d7492054"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks internal consistency (not atomic, not thread-safe)  <a href="#a07a3428f7ee2f0ddcb1c27f4d7492054">More...</a><br /></td></tr>
<tr class="separator:a07a3428f7ee2f0ddcb1c27f4d7492054"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:ae222095a858065553f04e842ebca3f91"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae222095a858065553f04e842ebca3f91"></a>
static constexpr bool const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4.html#ae222095a858065553f04e842ebca3f91">c_bRelaxedInsert</a> = traits::relaxed_insert</td></tr>
<tr class="memdesc:ae222095a858065553f04e842ebca3f91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enabled or disabled <a class="el" href="structcds_1_1container_1_1bronson__avltree_1_1relaxed__insert.html">relaxed insertion</a>. <br /></td></tr>
<tr class="separator:ae222095a858065553f04e842ebca3f91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6bb4e5ada7821e8140f694fbcad0375"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa6bb4e5ada7821e8140f694fbcad0375"></a>
static constexpr const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4.html#aa6bb4e5ada7821e8140f694fbcad0375">c_bExtractLockExternal</a> = false</td></tr>
<tr class="memdesc:aa6bb4e5ada7821e8140f694fbcad0375"><td class="mdescLeft">&#160;</td><td class="mdescRight">Group of <code>extract_xxx</code> functions does not require external locking. <br /></td></tr>
<tr class="separator:aa6bb4e5ada7821e8140f694fbcad0375"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename RCU, typename Key, typename T, typename Traits = bronson_avltree::traits&gt;<br />
class cds::container::BronsonAVLTreeMap&lt; cds::urcu::gc&lt; RCU &gt;, Key, T *, Traits &gt;</h3>

<p>Bronson et al AVL-tree (RCU specialization for storing pointer to values) </p>
<p><a class="anchor" id="cds_container_BronsonAVLTreeMap_rcu_ptr"></a> This is the specialization of <a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#cds_container_BronsonAVLTreeMap_rcu">RCU-based Bronson et al AVL-tree</a> for "key -&gt; value pointer" map. This specialization stores the pointer to user-allocated values instead of the copy of the value. When a tree node is removed, the algorithm does not free the value pointer directly, instead, it call the disposer functor provided by <code>Traits</code> template parameter.</p>
<p><b>Template arguments</b>:</p><ul>
<li><code>RCU</code> - one of <a class="el" href="namespacecds_1_1urcu.html#cds_urcu_gc">RCU type</a></li>
<li><code>Key</code> - key type</li>
<li><code>T</code> - value type to be stored in tree's nodes. Note, the specialization stores the pointer to user-allocated value, not the copy.</li>
<li><code>Traits</code> - tree traits, default is <code><a class="el" href="structcds_1_1container_1_1bronson__avltree_1_1traits.html" title="BronsonAVLTreeMap traits ">bronson_avltree::traits</a></code> It is possible to declare option-based tree with <code><a class="el" href="structcds_1_1container_1_1bronson__avltree_1_1make__traits.html" title="Metafunction converting option list to BronsonAVLTreeMap traits. ">bronson_avltree::make_traits</a></code> metafunction instead of <code>Traits</code> template argument.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>Before including <code>&lt;cds/container/bronson_avltree_map_rcu.h&gt;</code> you should include appropriate RCU header file, see <a class="el" href="namespacecds_1_1urcu.html#cds_urcu_gc">RCU type</a> for list of existing RCU class and corresponding header files. </dd></dl>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a91b0aeeecf30f6faee707119472dad4d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RCU , typename Key , typename T , typename Traits  = bronson_avltree::traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map.html">cds::container::BronsonAVLTreeMap</a>&lt; cds::urcu::gc&lt; RCU &gt;, Key, T *, Traits &gt;::check_consistency </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks internal consistency (not atomic, not thread-safe) </p>
<p>The debugging function to check internal consistency of the tree. </p>

</div>
</div>
<a class="anchor" id="a07a3428f7ee2f0ddcb1c27f4d7492054"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RCU , typename Key , typename T , typename Traits  = bronson_avltree::traits&gt; </div>
<div class="memtemplate">
template&lt;typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map.html">cds::container::BronsonAVLTreeMap</a>&lt; cds::urcu::gc&lt; RCU &gt;, Key, T *, Traits &gt;::check_consistency </td>
          <td>(</td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks internal consistency (not atomic, not thread-safe) </p>
<p>The debugging function to check internal consistency of the tree. The functor <code>Func</code> is called if a violation of internal tree structure is found: </p><div class="fragment"><div class="line"><span class="keyword">struct </span>functor {</div>
<div class="line">    <span class="keywordtype">void</span> operator()( <span class="keywordtype">size_t</span> nLevel, <span class="keywordtype">size_t</span> hLeft, <span class="keywordtype">size_t</span> hRight );</div>
<div class="line">};</div>
</div><!-- fragment --><p> where</p><ul>
<li><code>nLevel</code> - the level where the violation is found</li>
<li><code>hLeft</code> - the height of left subtree</li>
<li><code>hRight</code> - the height of right subtree</li>
</ul>
<p>The functor is called for each violation found. </p>

</div>
</div>
<a class="anchor" id="a498154314d46257923293f1a580962d0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RCU , typename Key , typename T , typename Traits  = bronson_avltree::traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map.html">cds::container::BronsonAVLTreeMap</a>&lt; cds::urcu::gc&lt; RCU &gt;, Key, T *, Traits &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clears the tree (thread safe, not atomic) </p>
<p>The function unlink all items from the tree. The function is thread safe but not atomic: in multi-threaded environment with parallel insertions this sequence </p><div class="fragment"><div class="line">set.clear();</div>
<div class="line">assert( set.empty() );</div>
</div><!-- fragment --><p> the assertion could be raised.</p>
<p>For each node the <a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4.html#aaa1d0f97e8cb375833a76cc1e7d1e8d3">disposer</a> will be called after unlinking.</p>
<p>RCU <code>synchronize</code> method can be called. RCU should not be locked. </p>

</div>
</div>
<a class="anchor" id="a0b5e850207b41f5dce6af6468fb5dbaf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RCU , typename Key , typename T , typename Traits  = bronson_avltree::traits&gt; </div>
<div class="memtemplate">
template&lt;typename K &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map.html">cds::container::BronsonAVLTreeMap</a>&lt; cds::urcu::gc&lt; RCU &gt;, Key, T *, Traits &gt;::contains </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether the map contains <code>key</code>. </p>
<p>The function searches the item with key equal to <code>key</code> and returns <code>true</code> if it is found, and <code>false</code> otherwise.</p>
<p>The function applies RCU lock internally. </p>

</div>
</div>
<a class="anchor" id="a4c2287d7dbb737ba2911881e52a3aa32"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RCU , typename Key , typename T , typename Traits  = bronson_avltree::traits&gt; </div>
<div class="memtemplate">
template&lt;typename K , typename Less &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map.html">cds::container::BronsonAVLTreeMap</a>&lt; cds::urcu::gc&lt; RCU &gt;, Key, T *, Traits &gt;::contains </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Less&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether the map contains <code>key</code> using <code>pred</code> predicate for searching. </p>
<p>The function is similar to <code>contains( key )</code> but <code>pred</code> is used for key comparing. <code>Less</code> functor has the interface like <code>std::less</code>. <code>Less</code> must imply the same element order as the comparator used for building the set. </p>

</div>
</div>
<a class="anchor" id="a0c94f4a0fb5127e5ff5443f5c3367119"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RCU , typename Key , typename T , typename Traits  = bronson_avltree::traits&gt; </div>
<div class="memtemplate">
template&lt;typename K &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map.html">cds::container::BronsonAVLTreeMap</a>&lt; cds::urcu::gc&lt; RCU &gt;, Key, T *, Traits &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Delete <code>key</code> from the map. </p>
<p>RCU <code>synchronize()</code> method can be called. RCU should not be locked.</p>
<p>Return <code>true</code> if <code>key</code> is found and deleted, <code>false</code> otherwise </p>

</div>
</div>
<a class="anchor" id="a32fa503a18c8117edc55099ea6da871e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RCU , typename Key , typename T , typename Traits  = bronson_avltree::traits&gt; </div>
<div class="memtemplate">
template&lt;typename K , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map.html">cds::container::BronsonAVLTreeMap</a>&lt; cds::urcu::gc&lt; RCU &gt;, Key, T *, Traits &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Delete <code>key</code> from the map. </p>
<p>The function searches an item with key <code>key</code>, calls <code>f</code> functor and deletes the item. If <code>key</code> is not found, the functor is not called.</p>
<p>The functor <code>Func</code> interface: </p><div class="fragment"><div class="line"><span class="keyword">struct </span>extractor {</div>
<div class="line">    <span class="keywordtype">void</span> operator()( <a class="code" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4.html#af1241636918651c696267269ff61e682">key_type</a> <span class="keyword">const</span>&amp; key, std::remove_pointer&lt;mapped_type&gt;::type&amp; val) { ... }</div>
<div class="line">};</div>
</div><!-- fragment --><p>RCU <code>synchronize</code> method can be called. RCU should not be locked.</p>
<p>Return <code>true</code> if key is found and deleted, <code>false</code> otherwise </p>

</div>
</div>
<a class="anchor" id="a0366890161a2a550abfc858eb85d1ccf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RCU , typename Key , typename T , typename Traits  = bronson_avltree::traits&gt; </div>
<div class="memtemplate">
template&lt;typename K , typename Less &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map.html">cds::container::BronsonAVLTreeMap</a>&lt; cds::urcu::gc&lt; RCU &gt;, Key, T *, Traits &gt;::erase_with </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Less&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deletes the item from the map using <code>pred</code> predicate for searching. </p>
<p>The function is an analog of <code><a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4.html#a0c94f4a0fb5127e5ff5443f5c3367119" title="Delete key from the map. ">erase(K const&amp;)</a></code> but <code>pred</code> is used for key comparing. <code>Less</code> functor has the interface like <code>std::less</code>. <code>Less</code> must imply the same element order as the comparator used for building the map. </p>

</div>
</div>
<a class="anchor" id="a7767e7ab2b47adf96ddd91b4215f0edd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RCU , typename Key , typename T , typename Traits  = bronson_avltree::traits&gt; </div>
<div class="memtemplate">
template&lt;typename K , typename Less , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map.html">cds::container::BronsonAVLTreeMap</a>&lt; cds::urcu::gc&lt; RCU &gt;, Key, T *, Traits &gt;::erase_with </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Less&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deletes the item from the map using <code>pred</code> predicate for searching. </p>
<p>The function is an analog of <code><a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4.html#a32fa503a18c8117edc55099ea6da871e" title="Delete key from the map. ">erase(K const&amp;, Func)</a></code> but <code>pred</code> is used for key comparing. <code>Less</code> functor has the interface like <code>std::less</code>. <code>Less</code> must imply the same element order as the comparator used for building the map. </p>

</div>
</div>
<a class="anchor" id="a3b5e169c62720516c5c9d4c1f3b607b3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RCU , typename Key , typename T , typename Traits  = bronson_avltree::traits&gt; </div>
<div class="memtemplate">
template&lt;typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4.html#ad151e631864e27a386826e4f942861ae">exempt_ptr</a> <a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map.html">cds::container::BronsonAVLTreeMap</a>&lt; cds::urcu::gc&lt; RCU &gt;, Key, T *, Traits &gt;::extract_max </td>
          <td>(</td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extracts minimal key key and corresponding value. </p>
<p>This function is a shortcut for the following call: </p><div class="fragment"><div class="line">    <a class="code" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4.html#af1241636918651c696267269ff61e682">key_type</a> key;</div>
<div class="line">    <a class="code" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4.html#ad151e631864e27a386826e4f942861ae">exempt_ptr</a> xp = theTree.extract_min( [&amp;key]( <a class="code" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4.html#af1241636918651c696267269ff61e682">key_type</a> <span class="keyword">const</span>&amp; k ) { key = k; } );</div>
<div class="line">    \endode</div>
<div class="line">    \p <a class="code" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4.html#af1241636918651c696267269ff61e682">key_type</a> should be copy-assignable. The copy of minimal key</div>
<div class="line">    is returned in \p min_key argument.</div>
<div class="line"> /</div>
<div class="line"><span class="keyword">typename</span> std::enable_if&lt; std::is_copy_assignable&lt;key_type&gt;::value, <a class="code" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4.html#ad151e631864e27a386826e4f942861ae">exempt_ptr</a> &gt;::type</div>
<div class="line">extract_min_key( <a class="code" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4.html#af1241636918651c696267269ff61e682">key_type</a>&amp; min_key )</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> <a class="code" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4.html#ad151e631864e27a386826e4f942861ae">exempt_ptr</a>(do_extract_min( [&amp;min_key]( <a class="code" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4.html#af1241636918651c696267269ff61e682">key_type</a> <span class="keyword">const</span>&amp; key ) { min_key = key; }));</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><a class="code" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4.html#ad151e631864e27a386826e4f942861ae">exempt_ptr</a> <a class="code" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4.html#a3b5e169c62720516c5c9d4c1f3b607b3">extract_max</a>()</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> <a class="code" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4.html#ad151e631864e27a386826e4f942861ae">exempt_ptr</a>(do_extract_max( []( <a class="code" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4.html#af1241636918651c696267269ff61e682">key_type</a> <span class="keyword">const</span>&amp; ) {}));</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
</div><!-- fragment --><p> If the tree is empty, <code>f</code> is not called. Otherwise, is it called with maximal key, the pointer to corresponding value is returned as <code>exempt_ptr</code>.</p>
<dl class="section note"><dt>Note</dt><dd>Due the concurrent nature of the map, the function extracts <em>nearly</em> maximal key. It means that the function gets rightmost leaf of the tree and tries to unlink it. During unlinking, a concurrent thread may insert an item with key great than leftmost item's key. So, the function returns the item with maximum key at the moment of tree traversing.</dd></dl>
<p>RCU <code>synchronize</code> method can be called. RCU should NOT be locked. The function does not free the item. The deallocator will be implicitly invoked when the returned object is destroyed or when its <code>release()</code> is called. </p>

</div>
</div>
<a class="anchor" id="ad66eab7b97360e818168b13cb2665388"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RCU , typename Key , typename T , typename Traits  = bronson_avltree::traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4.html#ad151e631864e27a386826e4f942861ae">exempt_ptr</a> <a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map.html">cds::container::BronsonAVLTreeMap</a>&lt; cds::urcu::gc&lt; RCU &gt;, Key, T *, Traits &gt;::extract_min </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extracts a value with minimal key from the map. </p>
<p>Returns <code>exempt_ptr</code> to the leftmost item. If the tree is empty, returns empty <code>exempt_ptr</code>.</p>
<p>Note that the function returns only the value for minimal key. To retrieve its key use <code><a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4.html#ac9c3f0993ad9fa44530c9a2caccfeb60" title="Extracts minimal key key and corresponding value. ">extract_min( Func )</a></code> member function.</p>
<dl class="section note"><dt>Note</dt><dd>Due the concurrent nature of the map, the function extracts <em>nearly</em> minimum key. It means that the function gets leftmost leaf of the tree and tries to unlink it. During unlinking, a concurrent thread may insert an item with key less than leftmost item's key. So, the function returns the item with minimum key at the moment of tree traversing.</dd></dl>
<p>RCU <code>synchronize</code> method can be called. RCU should NOT be locked. The function does not free the item. The deallocator will be implicitly invoked when the returned object is destroyed or when its <code>release()</code> member function is called. </p>

</div>
</div>
<a class="anchor" id="ac9c3f0993ad9fa44530c9a2caccfeb60"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RCU , typename Key , typename T , typename Traits  = bronson_avltree::traits&gt; </div>
<div class="memtemplate">
template&lt;typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4.html#ad151e631864e27a386826e4f942861ae">exempt_ptr</a> <a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map.html">cds::container::BronsonAVLTreeMap</a>&lt; cds::urcu::gc&lt; RCU &gt;, Key, T *, Traits &gt;::extract_min </td>
          <td>(</td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extracts minimal key key and corresponding value. </p>
<p>Returns <code>exempt_ptr</code> to the leftmost item. If the tree is empty, returns empty <code>exempt_ptr</code>.</p>
<p><code>Func</code> functor is used to store minimal key. <code>Func</code> has the following signature: </p><div class="fragment"><div class="line"><span class="keyword">struct </span>functor {</div>
<div class="line">    <span class="keywordtype">void</span> operator()( <a class="code" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4.html#af1241636918651c696267269ff61e682">key_type</a> <span class="keyword">const</span>&amp; key );</div>
<div class="line">};</div>
</div><!-- fragment --><p> If the tree is empty, <code>f</code> is not called. Otherwise, is it called with minimal key, the pointer to corresponding value is returned as <code>exempt_ptr</code>.</p>
<dl class="section note"><dt>Note</dt><dd>Due the concurrent nature of the map, the function extracts <em>nearly</em> minimum key. It means that the function gets leftmost leaf of the tree and tries to unlink it. During unlinking, a concurrent thread may insert an item with key less than leftmost item's key. So, the function returns the item with minimum key at the moment of tree traversing.</dd></dl>
<p>RCU <code>synchronize</code> method can be called. RCU should NOT be locked. The function does not free the item. The deallocator will be implicitly invoked when the returned object is destroyed or when its <code>release()</code> member function is called. </p>

</div>
</div>
<a class="anchor" id="aec008afbe0336c747abad6d61448f640"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RCU , typename Key , typename T , typename Traits  = bronson_avltree::traits&gt; </div>
<div class="memtemplate">
template&lt;typename K , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map.html">cds::container::BronsonAVLTreeMap</a>&lt; cds::urcu::gc&lt; RCU &gt;, Key, T *, Traits &gt;::find </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extracts the maximal key and corresponding value. </p>
<p>This function is a shortcut for the following call: </p><div class="fragment"><div class="line">        <a class="code" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4.html#af1241636918651c696267269ff61e682">key_type</a> key;</div>
<div class="line">        <a class="code" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4.html#ad151e631864e27a386826e4f942861ae">exempt_ptr</a> xp = theTree.extract_max( [&amp;key]( <a class="code" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4.html#af1241636918651c696267269ff61e682">key_type</a> <span class="keyword">const</span>&amp; k ) { key = k; } );</div>
<div class="line">    \endode</div>
<div class="line">    \p <a class="code" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4.html#af1241636918651c696267269ff61e682">key_type</a> should be copy-assignable. The copy of maximal key</div>
<div class="line">    is returned in \p max_key argument.</div>
<div class="line"> /</div>
<div class="line"><span class="keyword">typename</span> std::enable_if&lt; std::is_copy_assignable&lt;key_type&gt;::value, <a class="code" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4.html#ad151e631864e27a386826e4f942861ae">exempt_ptr</a> &gt;::type</div>
<div class="line">extract_max_key( <a class="code" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4.html#af1241636918651c696267269ff61e682">key_type</a>&amp; max_key )</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> <a class="code" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4.html#ad151e631864e27a386826e4f942861ae">exempt_ptr</a>(do_extract_max( [&amp;max_key]( <a class="code" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4.html#af1241636918651c696267269ff61e682">key_type</a> <span class="keyword">const</span>&amp; key ) { max_key = key; }));</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Q&gt;</div>
<div class="line"><a class="code" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4.html#ad151e631864e27a386826e4f942861ae">exempt_ptr</a> extract( Q <span class="keyword">const</span>&amp; key )</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> <a class="code" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4.html#ad151e631864e27a386826e4f942861ae">exempt_ptr</a>(do_extract( key ));</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Q, <span class="keyword">typename</span> Less&gt;</div>
<div class="line"><a class="code" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4.html#ad151e631864e27a386826e4f942861ae">exempt_ptr</a> extract_with( Q <span class="keyword">const</span>&amp; key, Less pred )</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> <a class="code" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4.html#ad151e631864e27a386826e4f942861ae">exempt_ptr</a>(do_extract_with( key, pred ));</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
</div><!-- fragment --><p> where <code>item</code> is the item found. The functor is called under node-level lock.</p>
<p>The function applies RCU lock internally.</p>
<p>The function returns <code>true</code> if <code>key</code> is found, <code>false</code> otherwise. </p>

</div>
</div>
<a class="anchor" id="ac4f832d644c8cb32d2566b818887b689"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RCU , typename Key , typename T , typename Traits  = bronson_avltree::traits&gt; </div>
<div class="memtemplate">
template&lt;typename K , typename Less , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map.html">cds::container::BronsonAVLTreeMap</a>&lt; cds::urcu::gc&lt; RCU &gt;, Key, T *, Traits &gt;::find_with </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Less&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the key <code>val</code> using <code>pred</code> predicate for searching. </p>
<p>The function is an analog of <code><a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4.html#aec008afbe0336c747abad6d61448f640" title="Extracts the maximal key and corresponding value. ">find(K const&amp;, Func)</a></code> but <code>pred</code> is used for key comparing. <code>Less</code> functor has the interface like <code>std::less</code>. <code>Less</code> must imply the same element order as the comparator used for building the map. </p>

</div>
</div>
<a class="anchor" id="a13226bcab1d76e8cf24b0038bb482e98"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RCU , typename Key , typename T , typename Traits  = bronson_avltree::traits&gt; </div>
<div class="memtemplate">
template&lt;typename K &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map.html">cds::container::BronsonAVLTreeMap</a>&lt; cds::urcu::gc&lt; RCU &gt;, Key, T *, Traits &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4.html#aa955a3d4f22ee5ef4026606f9b7eb487">mapped_type</a>&#160;</td>
          <td class="paramname"><em>pVal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts new node. </p>
<p>The <code>key_type</code> should be constructible from a value of type <code>K</code>.</p>
<p>RCU <code>synchronize()</code> can be called. RCU should not be locked.</p>
<p>Returns <code>true</code> if inserting successful, <code>false</code> otherwise. </p>

</div>
</div>
<a class="anchor" id="a5f61cb425b6f6b7fc34968010c04d2cd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RCU , typename Key , typename T , typename Traits  = bronson_avltree::traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map.html">cds::container::BronsonAVLTreeMap</a>&lt; cds::urcu::gc&lt; RCU &gt;, Key, T *, Traits &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns item count in the map. </p>
<p>Only leaf nodes containing user data are counted.</p>
<p>The value returned depends on item counter type provided by <code>Traits</code> template parameter. If it is <code><a class="el" href="classcds_1_1atomicity_1_1empty__item__counter.html" title="Empty item counter. ">atomicity::empty_item_counter</a></code> this function always returns 0.</p>
<p>The function is not suitable for checking the tree emptiness, use <code><a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4.html#a0cfe1823367ada09a1d67fae95766e48" title="Checks if the map is empty. ">empty()</a></code> member function for this purpose. </p>

</div>
</div>
<a class="anchor" id="ac08f24b55ec8cfecde4e9360caab8f75"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RCU , typename Key , typename T , typename Traits  = bronson_avltree::traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map.html">cds::container::BronsonAVLTreeMap</a>&lt; cds::urcu::gc&lt; RCU &gt;, Key, T *, Traits &gt;::unsafe_clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clears the tree (not thread safe) </p>
<p>This function is not thread safe and may be called only when no other thread deals with the tree. The function is used in the tree destructor. </p>

</div>
</div>
<a class="anchor" id="a6c09bb36626732fc37ecf54981bd0a96"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RCU , typename Key , typename T , typename Traits  = bronson_avltree::traits&gt; </div>
<div class="memtemplate">
template&lt;typename K &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;bool, bool&gt; <a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map.html">cds::container::BronsonAVLTreeMap</a>&lt; cds::urcu::gc&lt; RCU &gt;, Key, T *, Traits &gt;::update </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4.html#aa955a3d4f22ee5ef4026606f9b7eb487">mapped_type</a>&#160;</td>
          <td class="paramname"><em>pVal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bInsert</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Updates the value for <code>key</code>. </p>
<p>The operation performs inserting or updating the value for <code>key</code> with lock-free manner. If <code>bInsert</code> is <code>false</code>, only updating of existing node is possible.</p>
<p>If <code>key</code> is not found and inserting is allowed (i.e. <code>bInsert</code> is <code>true</code>), then the new node created from <code>key</code> will be inserted into the map; note that in this case the <a class="el" href="classcds_1_1container_1_1_bronson_a_v_l_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_01_5_00_01_traits_01_4.html#af1241636918651c696267269ff61e682">key_type</a> should be constructible from type <code>K</code>. Otherwise, the value for <code>key</code> will be changed to <code>pVal</code>.</p>
<p>RCU <code>synchronize()</code> method can be called. RCU should not be locked.</p>
<p>Returns <code> std::pair&lt;bool, bool&gt; </code> where <code>first</code> is <code>true</code> if operation is successfull, <code>second</code> is <code>true</code> if new node has been added or <code>false</code> if the node with <code>key</code> already exists. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>cds/container/impl/bronson_avltree_map_rcu.h</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<hr/>
<div align="right">
  <b>cds</b> <b>2.1.0</b> 
  Developed by <i>Maxim Khizhinsky aka khizmax</i> 2007 - 2015
  <br/>
  <i>Autogenerated Wed Jan 6 2016 16:00:36 by Doxygen 1.8.10</i>
</div>
</body>
</html>
