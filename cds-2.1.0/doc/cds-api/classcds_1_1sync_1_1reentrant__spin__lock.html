<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>cds: cds::sync::reentrant_spin_lock&lt; Integral, Backoff &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">cds
   &#160;<span id="projectnumber">2.1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="classes.html"><span>Data&#160;Structure&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Data&#160;Fields</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classcds_1_1sync_1_1reentrant__spin__lock.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-types">Private Types</a> &#124;
<a href="#pri-attribs">Private Attributes</a>  </div>
  <div class="headertitle">
<div class="title">cds::sync::reentrant_spin_lock&lt; Integral, Backoff &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Recursive spin lock.  
 <a href="classcds_1_1sync_1_1reentrant__spin__lock.html#details">More...</a></p>

<p><code>#include &lt;cds/sync/spinlock.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:abb6bfd61462a701b4bc48733d027e628"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abb6bfd61462a701b4bc48733d027e628"></a>
typedef Integral&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1sync_1_1reentrant__spin__lock.html#abb6bfd61462a701b4bc48733d027e628">integral_type</a></td></tr>
<tr class="memdesc:abb6bfd61462a701b4bc48733d027e628"><td class="mdescLeft">&#160;</td><td class="mdescRight">The integral type. <br /></td></tr>
<tr class="separator:abb6bfd61462a701b4bc48733d027e628"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae79ad2e76b0f3c24abba506d92fa9cdc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae79ad2e76b0f3c24abba506d92fa9cdc"></a>
typedef Backoff&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1sync_1_1reentrant__spin__lock.html#ae79ad2e76b0f3c24abba506d92fa9cdc">backoff_strategy</a></td></tr>
<tr class="memdesc:ae79ad2e76b0f3c24abba506d92fa9cdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">The backoff type. <br /></td></tr>
<tr class="separator:ae79ad2e76b0f3c24abba506d92fa9cdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a5fa58700c4d090c514d09fbf36428cfd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5fa58700c4d090c514d09fbf36428cfd"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1sync_1_1reentrant__spin__lock.html#a5fa58700c4d090c514d09fbf36428cfd">reentrant_spin_lock</a> () noexcept()</td></tr>
<tr class="memdesc:a5fa58700c4d090c514d09fbf36428cfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor initializes spin to free (unlocked) state. <br /></td></tr>
<tr class="separator:a5fa58700c4d090c514d09fbf36428cfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6253436f9b6bd1188cc58639132b1e63"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1sync_1_1reentrant__spin__lock.html#a6253436f9b6bd1188cc58639132b1e63">reentrant_spin_lock</a> (const <a class="el" href="classcds_1_1sync_1_1reentrant__spin__lock.html">reentrant_spin_lock</a>&lt; Integral, Backoff &gt; &amp;) noexcept()</td></tr>
<tr class="memdesc:a6253436f9b6bd1188cc58639132b1e63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dummy copy constructor.  <a href="#a6253436f9b6bd1188cc58639132b1e63">More...</a><br /></td></tr>
<tr class="separator:a6253436f9b6bd1188cc58639132b1e63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e46e5cc3048986b00a479ad9bb91368"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7e46e5cc3048986b00a479ad9bb91368"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1sync_1_1reentrant__spin__lock.html#a7e46e5cc3048986b00a479ad9bb91368">reentrant_spin_lock</a> (bool bLocked)</td></tr>
<tr class="memdesc:a7e46e5cc3048986b00a479ad9bb91368"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct object for specified state. <br /></td></tr>
<tr class="separator:a7e46e5cc3048986b00a479ad9bb91368"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8316feef06be4aeb077c17b4d703306"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1sync_1_1reentrant__spin__lock.html#ae8316feef06be4aeb077c17b4d703306">is_locked</a> () const  noexcept()</td></tr>
<tr class="memdesc:ae8316feef06be4aeb077c17b4d703306"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the spin is locked.  <a href="#ae8316feef06be4aeb077c17b4d703306">More...</a><br /></td></tr>
<tr class="separator:ae8316feef06be4aeb077c17b4d703306"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9a61b770831c507549182d1c294bc37"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab9a61b770831c507549182d1c294bc37"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1sync_1_1reentrant__spin__lock.html#ab9a61b770831c507549182d1c294bc37">try_lock</a> () noexcept()</td></tr>
<tr class="memdesc:ab9a61b770831c507549182d1c294bc37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to lock the spin-lock (synonym for <a class="el" href="classcds_1_1sync_1_1reentrant__spin__lock.html#ab9a61b770831c507549182d1c294bc37">try_lock</a>) <br /></td></tr>
<tr class="separator:ab9a61b770831c507549182d1c294bc37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbccc2c0d3c262ae4c6a39ba4e2bbf22"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adbccc2c0d3c262ae4c6a39ba4e2bbf22"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1sync_1_1reentrant__spin__lock.html#adbccc2c0d3c262ae4c6a39ba4e2bbf22">try_lock</a> (unsigned int nTryCount) CDS_NOEXCEPT_(noexcept(std::declval&lt; <a class="el" href="classcds_1_1sync_1_1reentrant__spin__lock.html">reentrant_spin_lock</a> &gt;().try_acquire(nTryCount)))</td></tr>
<tr class="memdesc:adbccc2c0d3c262ae4c6a39ba4e2bbf22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to lock the object. <br /></td></tr>
<tr class="separator:adbccc2c0d3c262ae4c6a39ba4e2bbf22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4dbcac5fc277e26659ca38eda27b92a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac4dbcac5fc277e26659ca38eda27b92a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1sync_1_1reentrant__spin__lock.html#ac4dbcac5fc277e26659ca38eda27b92a">lock</a> () CDS_NOEXCEPT_(noexcept(std::declval&lt; <a class="el" href="classcds_1_1sync_1_1reentrant__spin__lock.html">reentrant_spin_lock</a> &gt;().acquire()))</td></tr>
<tr class="memdesc:ac4dbcac5fc277e26659ca38eda27b92a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lock the object waits if it is busy. <br /></td></tr>
<tr class="separator:ac4dbcac5fc277e26659ca38eda27b92a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c5498a00d3834b2e770a85dfea499be"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1c5498a00d3834b2e770a85dfea499be"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1sync_1_1reentrant__spin__lock.html#a1c5498a00d3834b2e770a85dfea499be">unlock</a> () noexcept()</td></tr>
<tr class="memdesc:a1c5498a00d3834b2e770a85dfea499be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlock the spin-lock. Return <code>true</code> if the current thread is owner of spin-lock <code>false</code> otherwise. <br /></td></tr>
<tr class="separator:a1c5498a00d3834b2e770a85dfea499be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a599ad7d637648390e481b34787a1bb77"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a599ad7d637648390e481b34787a1bb77"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1sync_1_1reentrant__spin__lock.html#a599ad7d637648390e481b34787a1bb77">change_owner</a> (OS::ThreadId newOwnerId) noexcept()</td></tr>
<tr class="memdesc:a599ad7d637648390e481b34787a1bb77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the owner of locked spin-lock. May be called by thread that is owner of the spin-lock. <br /></td></tr>
<tr class="separator:a599ad7d637648390e481b34787a1bb77"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-types"></a>
Private Types</h2></td></tr>
<tr class="memitem:ab4355f98c06a161db177d0eb416956bf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab4355f98c06a161db177d0eb416956bf"></a>
typedef OS::ThreadId&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1sync_1_1reentrant__spin__lock.html#ab4355f98c06a161db177d0eb416956bf">thread_id</a></td></tr>
<tr class="memdesc:ab4355f98c06a161db177d0eb416956bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of thread id. <br /></td></tr>
<tr class="separator:ab4355f98c06a161db177d0eb416956bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a4c80ea887f97a1063f56d3a5d47453c1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4c80ea887f97a1063f56d3a5d47453c1"></a>
atomics::atomic&lt; <a class="el" href="classcds_1_1sync_1_1reentrant__spin__lock.html#abb6bfd61462a701b4bc48733d027e628">integral_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1sync_1_1reentrant__spin__lock.html#a4c80ea887f97a1063f56d3a5d47453c1">m_spin</a></td></tr>
<tr class="memdesc:a4c80ea887f97a1063f56d3a5d47453c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">spin-lock atomic <br /></td></tr>
<tr class="separator:a4c80ea887f97a1063f56d3a5d47453c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aace71c5cf8f7953221f055d044c08ab9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aace71c5cf8f7953221f055d044c08ab9"></a>
<a class="el" href="classcds_1_1sync_1_1reentrant__spin__lock.html#ab4355f98c06a161db177d0eb416956bf">thread_id</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1sync_1_1reentrant__spin__lock.html#aace71c5cf8f7953221f055d044c08ab9">m_OwnerId</a></td></tr>
<tr class="memdesc:aace71c5cf8f7953221f055d044c08ab9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Owner thread id. If spin-lock is not locked it usually equals to OS::c_NullThreadId. <br /></td></tr>
<tr class="separator:aace71c5cf8f7953221f055d044c08ab9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename Integral, class Backoff&gt;<br />
class cds::sync::reentrant_spin_lock&lt; Integral, Backoff &gt;</h3>

<p>Recursive spin lock. </p>
<p>Allows recursive calls: the owner thread may recursive enter to critical section guarded by the spin-lock.</p>
<p>Template parameters:</p><ul>
<li><code>Integral</code> one of integral atomic type: <code>unsigned int</code>, <code>int</code>, and others</li>
<li><code>Backoff</code> backoff strategy. Used when spin lock is locked </li>
</ul>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a6253436f9b6bd1188cc58639132b1e63"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Integral , class Backoff &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1sync_1_1reentrant__spin__lock.html">cds::sync::reentrant_spin_lock</a>&lt; Integral, Backoff &gt;::<a class="el" href="classcds_1_1sync_1_1reentrant__spin__lock.html">reentrant_spin_lock</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcds_1_1sync_1_1reentrant__spin__lock.html">reentrant_spin_lock</a>&lt; Integral, Backoff &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dummy copy constructor. </p>
<p>In theory, spin-lock cannot be copied. However, it is not practical. Therefore, we provide dummy copy constructor that do no copy in fact. The ctor initializes the spin to free (unlocked) state like default ctor. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="ae8316feef06be4aeb077c17b4d703306"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Integral , class Backoff &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1sync_1_1reentrant__spin__lock.html">cds::sync::reentrant_spin_lock</a>&lt; Integral, Backoff &gt;::is_locked </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the spin is locked. </p>
<p>The spin is locked if lock count &gt; 0 and the current thread is not an owner of the lock. Otherwise (i.e. lock count == 0 or the curren thread owns the spin) the spin is unlocked. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>cds/sync/spinlock.h</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<hr/>
<div align="right">
  <b>cds</b> <b>2.1.0</b> 
  Developed by <i>Maxim Khizhinsky aka khizmax</i> 2007 - 2015
  <br/>
  <i>Autogenerated Wed Jan 6 2016 16:00:48 by Doxygen 1.8.10</i>
</div>
</body>
</html>
