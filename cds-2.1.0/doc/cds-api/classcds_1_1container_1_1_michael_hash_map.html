<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>cds: cds::container::MichaelHashMap&lt; GC, OrderedList, Traits &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">cds
   &#160;<span id="projectnumber">2.1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="classes.html"><span>Data&#160;Structure&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Data&#160;Fields</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classcds_1_1container_1_1_michael_hash_map.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a>  </div>
  <div class="headertitle">
<div class="title">cds::container::MichaelHashMap&lt; GC, OrderedList, Traits &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__cds__nonintrusive__containers.html">Non-intrusive containers</a> &raquo; <a class="el" href="group__cds__nonintrusive__map.html">Map</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Michael's hash map.  
 <a href="classcds_1_1container_1_1_michael_hash_map.html#details">More...</a></p>

<p><code>#include &lt;cds/container/michael_map.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:aa372ab7a6e082dd3bb697a126402dc3b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa372ab7a6e082dd3bb697a126402dc3b"></a>
typedef GC&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#aa372ab7a6e082dd3bb697a126402dc3b">gc</a></td></tr>
<tr class="memdesc:aa372ab7a6e082dd3bb697a126402dc3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Garbage collector. <br /></td></tr>
<tr class="separator:aa372ab7a6e082dd3bb697a126402dc3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b215ae40c6d0b676f98a7b3a03dc84d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4b215ae40c6d0b676f98a7b3a03dc84d"></a>
typedef OrderedList&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#a4b215ae40c6d0b676f98a7b3a03dc84d">bucket_type</a></td></tr>
<tr class="memdesc:a4b215ae40c6d0b676f98a7b3a03dc84d"><td class="mdescLeft">&#160;</td><td class="mdescRight">type of ordered list to be used as a bucket <br /></td></tr>
<tr class="separator:a4b215ae40c6d0b676f98a7b3a03dc84d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ad49a20467f0e216bc0bcc20113e490"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9ad49a20467f0e216bc0bcc20113e490"></a>
typedef Traits&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#a9ad49a20467f0e216bc0bcc20113e490">traits</a></td></tr>
<tr class="memdesc:a9ad49a20467f0e216bc0bcc20113e490"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map traits. <br /></td></tr>
<tr class="separator:a9ad49a20467f0e216bc0bcc20113e490"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17107223d19776ad3d0cdf29591cc545"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a17107223d19776ad3d0cdf29591cc545"></a>
typedef bucket_type::key_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#a17107223d19776ad3d0cdf29591cc545">key_type</a></td></tr>
<tr class="memdesc:a17107223d19776ad3d0cdf29591cc545"><td class="mdescLeft">&#160;</td><td class="mdescRight">key type <br /></td></tr>
<tr class="separator:a17107223d19776ad3d0cdf29591cc545"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bda51f0e406218af58dba7fe30edccb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6bda51f0e406218af58dba7fe30edccb"></a>
typedef bucket_type::mapped_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#a6bda51f0e406218af58dba7fe30edccb">mapped_type</a></td></tr>
<tr class="memdesc:a6bda51f0e406218af58dba7fe30edccb"><td class="mdescLeft">&#160;</td><td class="mdescRight">value type <br /></td></tr>
<tr class="separator:a6bda51f0e406218af58dba7fe30edccb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4518129d579bbd5bc4612264d6cff2a6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4518129d579bbd5bc4612264d6cff2a6"></a>
typedef bucket_type::value_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#a4518129d579bbd5bc4612264d6cff2a6">value_type</a></td></tr>
<tr class="memdesc:a4518129d579bbd5bc4612264d6cff2a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">key/value pair stored in the map <br /></td></tr>
<tr class="separator:a4518129d579bbd5bc4612264d6cff2a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9c6632d046a7b05abd0a8a652675d3f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af9c6632d046a7b05abd0a8a652675d3f"></a>
typedef bucket_type::key_comparator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#af9c6632d046a7b05abd0a8a652675d3f">key_comparator</a></td></tr>
<tr class="memdesc:af9c6632d046a7b05abd0a8a652675d3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">key compare functor <br /></td></tr>
<tr class="separator:af9c6632d046a7b05abd0a8a652675d3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e514d02a3a23e4fd7844795f908d3bb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2e514d02a3a23e4fd7844795f908d3bb"></a>
typedef cds::opt::v::hash_selector&lt; typename traits::hash &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#a2e514d02a3a23e4fd7844795f908d3bb">hash</a></td></tr>
<tr class="memdesc:a2e514d02a3a23e4fd7844795f908d3bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hash functor for <a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#a17107223d19776ad3d0cdf29591cc545">key_type</a> and all its derivatives that you use. <br /></td></tr>
<tr class="separator:a2e514d02a3a23e4fd7844795f908d3bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a300fcfbf6fedec1eaf803d0a314f6ad6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a300fcfbf6fedec1eaf803d0a314f6ad6"></a>
typedef traits::item_counter&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#a300fcfbf6fedec1eaf803d0a314f6ad6">item_counter</a></td></tr>
<tr class="memdesc:a300fcfbf6fedec1eaf803d0a314f6ad6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Item counter type. <br /></td></tr>
<tr class="separator:a300fcfbf6fedec1eaf803d0a314f6ad6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41458e399361f7773e4784eaaa854ba1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a41458e399361f7773e4784eaaa854ba1"></a>
typedef <a class="el" href="classcds_1_1details_1_1_allocator.html">cds::details::Allocator</a>&lt; <a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#a4b215ae40c6d0b676f98a7b3a03dc84d">bucket_type</a>, typename traits::allocator &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#a41458e399361f7773e4784eaaa854ba1">bucket_table_allocator</a></td></tr>
<tr class="memdesc:a41458e399361f7773e4784eaaa854ba1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bucket table allocator. <br /></td></tr>
<tr class="separator:a41458e399361f7773e4784eaaa854ba1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94920ec4604b846e396acf80f2f7baf8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a94920ec4604b846e396acf80f2f7baf8"></a>
typedef bucket_type::guarded_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#a94920ec4604b846e396acf80f2f7baf8">guarded_ptr</a></td></tr>
<tr class="memdesc:a94920ec4604b846e396acf80f2f7baf8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Guarded pointer. <br /></td></tr>
<tr class="separator:a94920ec4604b846e396acf80f2f7baf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcebb900b3a0a09eadb916a458e9b6a3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afcebb900b3a0a09eadb916a458e9b6a3"></a>
typedef iterator_type&lt; false &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#afcebb900b3a0a09eadb916a458e9b6a3">iterator</a></td></tr>
<tr class="memdesc:afcebb900b3a0a09eadb916a458e9b6a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forward iterator. <br /></td></tr>
<tr class="separator:afcebb900b3a0a09eadb916a458e9b6a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf5b04694f85fd34390928dd1744bdbb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adf5b04694f85fd34390928dd1744bdbb"></a>
typedef iterator_type&lt; true &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#adf5b04694f85fd34390928dd1744bdbb">const_iterator</a></td></tr>
<tr class="memdesc:adf5b04694f85fd34390928dd1744bdbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const forward iterator. <br /></td></tr>
<tr class="separator:adf5b04694f85fd34390928dd1744bdbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ae837465b5c985e4856f4c368f638a097"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#afcebb900b3a0a09eadb916a458e9b6a3">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#ae837465b5c985e4856f4c368f638a097">begin</a> ()</td></tr>
<tr class="memdesc:ae837465b5c985e4856f4c368f638a097"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a forward iterator addressing the first element in a map.  <a href="#ae837465b5c985e4856f4c368f638a097">More...</a><br /></td></tr>
<tr class="separator:ae837465b5c985e4856f4c368f638a097"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d2ff57ccf188ead667fdf511f89adf5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#afcebb900b3a0a09eadb916a458e9b6a3">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#a6d2ff57ccf188ead667fdf511f89adf5">end</a> ()</td></tr>
<tr class="memdesc:a6d2ff57ccf188ead667fdf511f89adf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator that addresses the location succeeding the last element in a map.  <a href="#a6d2ff57ccf188ead667fdf511f89adf5">More...</a><br /></td></tr>
<tr class="separator:a6d2ff57ccf188ead667fdf511f89adf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b4756d55e75b439fe75adb6aebc5b19"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#a5b4756d55e75b439fe75adb6aebc5b19">MichaelHashMap</a> (size_t nMaxItemCount, size_t nLoadFactor)</td></tr>
<tr class="memdesc:a5b4756d55e75b439fe75adb6aebc5b19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the map.  <a href="#a5b4756d55e75b439fe75adb6aebc5b19">More...</a><br /></td></tr>
<tr class="separator:a5b4756d55e75b439fe75adb6aebc5b19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e452259d93feef1e414ad2a997fc504"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6e452259d93feef1e414ad2a997fc504"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#a6e452259d93feef1e414ad2a997fc504">~MichaelHashMap</a> ()</td></tr>
<tr class="memdesc:a6e452259d93feef1e414ad2a997fc504"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears hash map and destroys it. <br /></td></tr>
<tr class="separator:a6e452259d93feef1e414ad2a997fc504"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6811eed99b256e4b43d236c70f76f89d"><td class="memTemplParams" colspan="2">template&lt;typename K &gt; </td></tr>
<tr class="memitem:a6811eed99b256e4b43d236c70f76f89d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#a6811eed99b256e4b43d236c70f76f89d">insert</a> (const K &amp;key)</td></tr>
<tr class="memdesc:a6811eed99b256e4b43d236c70f76f89d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new node with key and default value.  <a href="#a6811eed99b256e4b43d236c70f76f89d">More...</a><br /></td></tr>
<tr class="separator:a6811eed99b256e4b43d236c70f76f89d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addbf87015ecd7d552832e0e57d498149"><td class="memTemplParams" colspan="2">template&lt;typename K , typename V &gt; </td></tr>
<tr class="memitem:addbf87015ecd7d552832e0e57d498149"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#addbf87015ecd7d552832e0e57d498149">insert</a> (K const &amp;key, V const &amp;val)</td></tr>
<tr class="memdesc:addbf87015ecd7d552832e0e57d498149"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new node.  <a href="#addbf87015ecd7d552832e0e57d498149">More...</a><br /></td></tr>
<tr class="separator:addbf87015ecd7d552832e0e57d498149"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa315efe0dd22cba34ce70810b43ebf33"><td class="memTemplParams" colspan="2">template&lt;typename K , typename Func &gt; </td></tr>
<tr class="memitem:aa315efe0dd22cba34ce70810b43ebf33"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#aa315efe0dd22cba34ce70810b43ebf33">insert_with</a> (const K &amp;key, Func func)</td></tr>
<tr class="memdesc:aa315efe0dd22cba34ce70810b43ebf33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new node and initialize it by a functor.  <a href="#aa315efe0dd22cba34ce70810b43ebf33">More...</a><br /></td></tr>
<tr class="separator:aa315efe0dd22cba34ce70810b43ebf33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf597d4571369d6c83c442963abce4f2"><td class="memTemplParams" colspan="2">template&lt;typename K , typename Func &gt; </td></tr>
<tr class="memitem:abf597d4571369d6c83c442963abce4f2"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; bool, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#abf597d4571369d6c83c442963abce4f2">update</a> (K const &amp;key, Func func, bool bAllowInsert=true)</td></tr>
<tr class="memdesc:abf597d4571369d6c83c442963abce4f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates data by <code>key</code>.  <a href="#abf597d4571369d6c83c442963abce4f2">More...</a><br /></td></tr>
<tr class="separator:abf597d4571369d6c83c442963abce4f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f1536210a794b018de5943db1ff6e80"><td class="memTemplParams" colspan="2">template&lt;typename K , typename... Args&gt; </td></tr>
<tr class="memitem:a3f1536210a794b018de5943db1ff6e80"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#a3f1536210a794b018de5943db1ff6e80">emplace</a> (K &amp;&amp;key, Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:a3f1536210a794b018de5943db1ff6e80"><td class="mdescLeft">&#160;</td><td class="mdescRight">For key <code>key</code> inserts data of type <code>mapped_type</code> created from <code>args</code>.  <a href="#a3f1536210a794b018de5943db1ff6e80">More...</a><br /></td></tr>
<tr class="separator:a3f1536210a794b018de5943db1ff6e80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3e87d786b614fe694467bbd91daecbc"><td class="memTemplParams" colspan="2">template&lt;typename K &gt; </td></tr>
<tr class="memitem:ab3e87d786b614fe694467bbd91daecbc"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#ab3e87d786b614fe694467bbd91daecbc">erase</a> (K const &amp;key)</td></tr>
<tr class="memdesc:ab3e87d786b614fe694467bbd91daecbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes <code>key</code> from the map.  <a href="#ab3e87d786b614fe694467bbd91daecbc">More...</a><br /></td></tr>
<tr class="separator:ab3e87d786b614fe694467bbd91daecbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e9dbb7e4991a31b78237f2ef3671307"><td class="memTemplParams" colspan="2">template&lt;typename K , typename Less &gt; </td></tr>
<tr class="memitem:a5e9dbb7e4991a31b78237f2ef3671307"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#a5e9dbb7e4991a31b78237f2ef3671307">erase_with</a> (K const &amp;key, Less pred)</td></tr>
<tr class="memdesc:a5e9dbb7e4991a31b78237f2ef3671307"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the item from the map using <code>pred</code> predicate for searching.  <a href="#a5e9dbb7e4991a31b78237f2ef3671307">More...</a><br /></td></tr>
<tr class="separator:a5e9dbb7e4991a31b78237f2ef3671307"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab078ecdb8dde43dd992e9f63fc96c7a3"><td class="memTemplParams" colspan="2">template&lt;typename K , typename Func &gt; </td></tr>
<tr class="memitem:ab078ecdb8dde43dd992e9f63fc96c7a3"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#ab078ecdb8dde43dd992e9f63fc96c7a3">erase</a> (K const &amp;key, Func f)</td></tr>
<tr class="memdesc:ab078ecdb8dde43dd992e9f63fc96c7a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes <code>key</code> from the map.  <a href="#ab078ecdb8dde43dd992e9f63fc96c7a3">More...</a><br /></td></tr>
<tr class="separator:ab078ecdb8dde43dd992e9f63fc96c7a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a382ac299a8ccda2272ec27296361da8c"><td class="memTemplParams" colspan="2">template&lt;typename K , typename Less , typename Func &gt; </td></tr>
<tr class="memitem:a382ac299a8ccda2272ec27296361da8c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#a382ac299a8ccda2272ec27296361da8c">erase_with</a> (K const &amp;key, Less pred, Func f)</td></tr>
<tr class="memdesc:a382ac299a8ccda2272ec27296361da8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the item from the map using <code>pred</code> predicate for searching.  <a href="#a382ac299a8ccda2272ec27296361da8c">More...</a><br /></td></tr>
<tr class="separator:a382ac299a8ccda2272ec27296361da8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a294aef3736ea5e317175e0696a1e0b00"><td class="memTemplParams" colspan="2">template&lt;typename K &gt; </td></tr>
<tr class="memitem:a294aef3736ea5e317175e0696a1e0b00"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#a94920ec4604b846e396acf80f2f7baf8">guarded_ptr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#a294aef3736ea5e317175e0696a1e0b00">extract</a> (K const &amp;key)</td></tr>
<tr class="memdesc:a294aef3736ea5e317175e0696a1e0b00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the item with specified <code>key</code>.  <a href="#a294aef3736ea5e317175e0696a1e0b00">More...</a><br /></td></tr>
<tr class="separator:a294aef3736ea5e317175e0696a1e0b00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35f075a257e000fff5c0b8aa7cc38500"><td class="memTemplParams" colspan="2">template&lt;typename K , typename Less &gt; </td></tr>
<tr class="memitem:a35f075a257e000fff5c0b8aa7cc38500"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#a94920ec4604b846e396acf80f2f7baf8">guarded_ptr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#a35f075a257e000fff5c0b8aa7cc38500">extract_with</a> (K const &amp;key, Less pred)</td></tr>
<tr class="memdesc:a35f075a257e000fff5c0b8aa7cc38500"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the item using compare functor <code>pred</code>.  <a href="#a35f075a257e000fff5c0b8aa7cc38500">More...</a><br /></td></tr>
<tr class="separator:a35f075a257e000fff5c0b8aa7cc38500"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a463d8d7851dedae6fcc0d9b0d82c2e6d"><td class="memTemplParams" colspan="2">template&lt;typename K , typename Func &gt; </td></tr>
<tr class="memitem:a463d8d7851dedae6fcc0d9b0d82c2e6d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#a463d8d7851dedae6fcc0d9b0d82c2e6d">find</a> (K const &amp;key, Func f)</td></tr>
<tr class="memdesc:a463d8d7851dedae6fcc0d9b0d82c2e6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the key <code>key</code>.  <a href="#a463d8d7851dedae6fcc0d9b0d82c2e6d">More...</a><br /></td></tr>
<tr class="separator:a463d8d7851dedae6fcc0d9b0d82c2e6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfcdb0d94caf721d23c8d867f9e26336"><td class="memTemplParams" colspan="2">template&lt;typename K , typename Less , typename Func &gt; </td></tr>
<tr class="memitem:acfcdb0d94caf721d23c8d867f9e26336"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#acfcdb0d94caf721d23c8d867f9e26336">find_with</a> (K const &amp;key, Less pred, Func f)</td></tr>
<tr class="memdesc:acfcdb0d94caf721d23c8d867f9e26336"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the key <code>val</code> using <code>pred</code> predicate for searching.  <a href="#acfcdb0d94caf721d23c8d867f9e26336">More...</a><br /></td></tr>
<tr class="separator:acfcdb0d94caf721d23c8d867f9e26336"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f0c8b93a02e4e3524fabc22ef51984f"><td class="memTemplParams" colspan="2">template&lt;typename K &gt; </td></tr>
<tr class="memitem:a1f0c8b93a02e4e3524fabc22ef51984f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#a1f0c8b93a02e4e3524fabc22ef51984f">contains</a> (K const &amp;key)</td></tr>
<tr class="memdesc:a1f0c8b93a02e4e3524fabc22ef51984f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the map contains <code>key</code>.  <a href="#a1f0c8b93a02e4e3524fabc22ef51984f">More...</a><br /></td></tr>
<tr class="separator:a1f0c8b93a02e4e3524fabc22ef51984f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a738b53a472a211ecc94e5207cfdc3df0"><td class="memTemplParams" colspan="2">template&lt;typename K , typename Less &gt; </td></tr>
<tr class="memitem:a738b53a472a211ecc94e5207cfdc3df0"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#a738b53a472a211ecc94e5207cfdc3df0">contains</a> (K const &amp;key, Less pred)</td></tr>
<tr class="memdesc:a738b53a472a211ecc94e5207cfdc3df0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the map contains <code>key</code> using <code>pred</code> predicate for searching.  <a href="#a738b53a472a211ecc94e5207cfdc3df0">More...</a><br /></td></tr>
<tr class="separator:a738b53a472a211ecc94e5207cfdc3df0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae88464eafb958bd8df621ecf783e73c5"><td class="memTemplParams" colspan="2">template&lt;typename K &gt; </td></tr>
<tr class="memitem:ae88464eafb958bd8df621ecf783e73c5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#a94920ec4604b846e396acf80f2f7baf8">guarded_ptr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#ae88464eafb958bd8df621ecf783e73c5">get</a> (K const &amp;key)</td></tr>
<tr class="memdesc:ae88464eafb958bd8df621ecf783e73c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds <code>key</code> and return the item found.  <a href="#ae88464eafb958bd8df621ecf783e73c5">More...</a><br /></td></tr>
<tr class="separator:ae88464eafb958bd8df621ecf783e73c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41e2ae292ef69778acbf191c38b5c34c"><td class="memTemplParams" colspan="2">template&lt;typename K , typename Less &gt; </td></tr>
<tr class="memitem:a41e2ae292ef69778acbf191c38b5c34c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#a94920ec4604b846e396acf80f2f7baf8">guarded_ptr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#a41e2ae292ef69778acbf191c38b5c34c">get_with</a> (K const &amp;key, Less pred)</td></tr>
<tr class="memdesc:a41e2ae292ef69778acbf191c38b5c34c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds <code>key</code> and return the item found.  <a href="#a41e2ae292ef69778acbf191c38b5c34c">More...</a><br /></td></tr>
<tr class="separator:a41e2ae292ef69778acbf191c38b5c34c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a929894210bf7b045d646f82ab175aa6b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a929894210bf7b045d646f82ab175aa6b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#a929894210bf7b045d646f82ab175aa6b">clear</a> ()</td></tr>
<tr class="memdesc:a929894210bf7b045d646f82ab175aa6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the map (not atomic) <br /></td></tr>
<tr class="separator:a929894210bf7b045d646f82ab175aa6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8010a7896995c83154ecfe1ae3ddd521"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#a8010a7896995c83154ecfe1ae3ddd521">empty</a> () const </td></tr>
<tr class="memdesc:a8010a7896995c83154ecfe1ae3ddd521"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the map is empty.  <a href="#a8010a7896995c83154ecfe1ae3ddd521">More...</a><br /></td></tr>
<tr class="separator:a8010a7896995c83154ecfe1ae3ddd521"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95c5fcc6a6e136013a8e2c488a5dca9a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a95c5fcc6a6e136013a8e2c488a5dca9a"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#a95c5fcc6a6e136013a8e2c488a5dca9a">size</a> () const </td></tr>
<tr class="memdesc:a95c5fcc6a6e136013a8e2c488a5dca9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns item count in the map. <br /></td></tr>
<tr class="separator:a95c5fcc6a6e136013a8e2c488a5dca9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a373126e1df3c7c05000ccc9959302174"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#a373126e1df3c7c05000ccc9959302174">bucket_count</a> () const </td></tr>
<tr class="memdesc:a373126e1df3c7c05000ccc9959302174"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of hash table.  <a href="#a373126e1df3c7c05000ccc9959302174">More...</a><br /></td></tr>
<tr class="separator:a373126e1df3c7c05000ccc9959302174"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ad22645b6267987a11ce7b5fe8324a98e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad22645b6267987a11ce7b5fe8324a98e"></a>
<a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#adf5b04694f85fd34390928dd1744bdbb">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#ad22645b6267987a11ce7b5fe8324a98e">begin</a> () const </td></tr>
<tr class="memdesc:ad22645b6267987a11ce7b5fe8324a98e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a forward const iterator addressing the first element in a map. <br /></td></tr>
<tr class="separator:ad22645b6267987a11ce7b5fe8324a98e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2f97df8d55b911122e1446cb79a5bfd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac2f97df8d55b911122e1446cb79a5bfd"></a>
<a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#adf5b04694f85fd34390928dd1744bdbb">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cbegin</b> () const </td></tr>
<tr class="separator:ac2f97df8d55b911122e1446cb79a5bfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a257f2a8fde1a33078c2385a3e900460f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a257f2a8fde1a33078c2385a3e900460f"></a>
<a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#adf5b04694f85fd34390928dd1744bdbb">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#a257f2a8fde1a33078c2385a3e900460f">end</a> () const </td></tr>
<tr class="memdesc:a257f2a8fde1a33078c2385a3e900460f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an const iterator that addresses the location succeeding the last element in a map. <br /></td></tr>
<tr class="separator:a257f2a8fde1a33078c2385a3e900460f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8069cdb165ae89f10acb7817164decec"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8069cdb165ae89f10acb7817164decec"></a>
<a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#adf5b04694f85fd34390928dd1744bdbb">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cend</b> () const </td></tr>
<tr class="separator:a8069cdb165ae89f10acb7817164decec"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:af0ccd023a75e47e4b13ad541dac8210b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af0ccd023a75e47e4b13ad541dac8210b"></a>
<a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#a300fcfbf6fedec1eaf803d0a314f6ad6">item_counter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#af0ccd023a75e47e4b13ad541dac8210b">m_ItemCounter</a></td></tr>
<tr class="memdesc:af0ccd023a75e47e4b13ad541dac8210b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Item counter. <br /></td></tr>
<tr class="separator:af0ccd023a75e47e4b13ad541dac8210b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac93bb22d6f07a3c620954b39ad4fdca2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac93bb22d6f07a3c620954b39ad4fdca2"></a>
<a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#a2e514d02a3a23e4fd7844795f908d3bb">hash</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#ac93bb22d6f07a3c620954b39ad4fdca2">m_HashFunctor</a></td></tr>
<tr class="memdesc:ac93bb22d6f07a3c620954b39ad4fdca2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hash functor. <br /></td></tr>
<tr class="separator:ac93bb22d6f07a3c620954b39ad4fdca2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0e882033a5b6bd969b43b5a4d617c87"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae0e882033a5b6bd969b43b5a4d617c87"></a>
<a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#a4b215ae40c6d0b676f98a7b3a03dc84d">bucket_type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#ae0e882033a5b6bd969b43b5a4d617c87">m_Buckets</a></td></tr>
<tr class="memdesc:ae0e882033a5b6bd969b43b5a4d617c87"><td class="mdescLeft">&#160;</td><td class="mdescRight">bucket table <br /></td></tr>
<tr class="separator:ae0e882033a5b6bd969b43b5a4d617c87"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class GC, class OrderedList, class Traits = michael_map::traits&gt;<br />
class cds::container::MichaelHashMap&lt; GC, OrderedList, Traits &gt;</h3>

<p>Michael's hash map. </p>
<p><a class="anchor" id="cds_nonintrusive_MichaelHashMap_hp"></a> Source:</p><ul>
<li>[2002] Maged Michael "High performance dynamic lock-free hash tables and list-based sets"</li>
</ul>
<p>Michael's hash table algorithm is based on lock-free ordered list and it is very simple. The main structure is an array <code>T</code> of size <code>M</code>. Each element in <code>T</code> is basically a pointer to a hash bucket, implemented as a singly linked list. The array of buckets cannot be dynamically expanded. However, each bucket may contain unbounded number of items.</p>
<p>Template parameters are:</p><ul>
<li><code>GC</code> - Garbage collector used. You may use any <a class="el" href="group__cds__garbage__collector.html">Garbage collector</a> from the <code>libcds</code> library. Note the <code>GC</code> must be the same as the GC used for <code>OrderedList</code> </li>
<li><code>OrderedList</code> - ordered key-value list implementation used as bucket for hash map, for example, <code><a class="el" href="classcds_1_1container_1_1_michael_k_v_list.html" title="Michael&#39;s ordered list fo key-value pair. ">MichaelKVList</a></code> or <code><a class="el" href="classcds_1_1container_1_1_lazy_k_v_list.html" title="Lazy ordered list (key-value pair) ">LazyKVList</a></code>. The ordered list implementation specifies the <code>Key</code> and <code>Value</code> types stored in the hash-map, the reclamation schema <code>GC</code> used by hash-map, the comparison functor for the type <code>Key</code> and other features specific for the ordered list.</li>
<li><code>Traits</code> - map traits, default is <code><a class="el" href="namespacecds_1_1container_1_1michael__map.html#ab5f19c5329fdd2d525e9c82b5c741539" title="MichaelHashMap traits ">michael_map::traits</a></code>. Instead of defining <code>Traits</code> struct you may use option-based syntax with <code><a class="el" href="namespacecds_1_1container_1_1michael__map.html#ac488b413199f6b36468ab61f5e4637cf" title="Metafunction converting option list to michael_map::traits. ">michael_map::make_traits</a></code> metafunction.</li>
</ul>
<p>Many of the class function take a key argument of type <code>K</code> that in general is not <code>key_type</code>. <code>key_type</code> and an argument of template type <code>K</code> must meet the following requirements:</p><ul>
<li><code>key_type</code> should be constructible from value of type <code>K</code>;</li>
<li>the hash functor should be able to calculate correct hash value from argument <code>key</code> of type <code>K:</code> <code> hash( key_type(key) ) == hash( key ) </code></li>
<li>values of type <code>key_type</code> and <code>K</code> should be comparable</li>
</ul>
<p>There are the specializations:</p><ul>
<li>for <a class="el" href="namespacecds_1_1urcu.html#cds_urcu_desc">RCU</a> - declared in <code>cds/container/michael_map_rcu.h</code>, see <a class="el" href="classcds_1_1container_1_1_michael_hash_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_ordered_list_00_01_traits_01_4.html#cds_nonintrusive_MichaelHashMap_rcu">MichaelHashMap&lt;RCU&gt;</a>.</li>
<li>for <code><a class="el" href="classcds_1_1gc_1_1nogc.html" title="No garbage collecting. ">cds::gc::nogc</a></code> declared in <code>cds/container/michael_map_nogc.h</code>, see <a class="el" href="classcds_1_1container_1_1_michael_hash_map_3_01cds_1_1gc_1_1nogc_00_01_ordered_list_00_01_traits_01_4.html#cds_nonintrusive_MichaelHashMap_nogc">MichaelHashMap&lt;gc::nogc&gt;</a>.</li>
</ul>
<p><b>Iterators</b></p>
<p>The class supports a forward iterator (<a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#afcebb900b3a0a09eadb916a458e9b6a3">iterator</a> and <a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#adf5b04694f85fd34390928dd1744bdbb">const_iterator</a>). The iteration is unordered. The iterator object is thread-safe: the element pointed by the iterator object is guarded, so, the element cannot be reclaimed while the iterator object is alive. However, passing an iterator object between threads is dangerous.</p>
<dl class="section warning"><dt>Warning</dt><dd>Due to concurrent nature of Michael's set it is not guarantee that you can iterate all elements in the set: any concurrent deletion can exclude the element pointed by the iterator from the set, and your iteration can be terminated before end of the set. Therefore, such iteration is more suitable for debugging purpose only</dd></dl>
<p>Remember, each iterator object requires an additional hazard pointer, that may be a limited resource for <code>GC</code> like <code><a class="el" href="classcds_1_1gc_1_1_h_p.html" title="Hazard Pointer garbage collector. ">gc::HP</a></code> (for <code><a class="el" href="classcds_1_1gc_1_1_d_h_p.html" title="Dynamic Hazard Pointer garbage collector. ">gc::DHP</a></code> the count of guards is unlimited).</p>
<p>The iterator class supports the following minimalistic interface: </p><div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code" href="classcds_1_1container_1_1_michael_hash_map.html#afcebb900b3a0a09eadb916a458e9b6a3">iterator</a> {</div>
<div class="line"><span class="comment">// Default ctor</span></div>
<div class="line"><a class="code" href="classcds_1_1container_1_1_michael_hash_map.html#afcebb900b3a0a09eadb916a458e9b6a3">iterator</a>();</div>
<div class="line"></div>
<div class="line"><span class="comment">// Copy ctor</span></div>
<div class="line"><a class="code" href="classcds_1_1container_1_1_michael_hash_map.html#afcebb900b3a0a09eadb916a458e9b6a3">iterator</a>( <a class="code" href="classcds_1_1container_1_1_michael_hash_map.html#afcebb900b3a0a09eadb916a458e9b6a3">iterator</a> <span class="keyword">const</span>&amp; s);</div>
<div class="line"></div>
<div class="line"><a class="code" href="classcds_1_1container_1_1_michael_hash_map.html#a4518129d579bbd5bc4612264d6cff2a6">value_type</a> * operator -&gt;() <span class="keyword">const</span>;</div>
<div class="line"><a class="code" href="classcds_1_1container_1_1_michael_hash_map.html#a4518129d579bbd5bc4612264d6cff2a6">value_type</a>&amp; operator *() <span class="keyword">const</span>;</div>
<div class="line"></div>
<div class="line"><span class="comment">// Pre-increment</span></div>
<div class="line"><a class="code" href="classcds_1_1container_1_1_michael_hash_map.html#afcebb900b3a0a09eadb916a458e9b6a3">iterator</a>&amp; operator ++();</div>
<div class="line"></div>
<div class="line"><span class="comment">// Copy assignment</span></div>
<div class="line"><a class="code" href="classcds_1_1container_1_1_michael_hash_map.html#afcebb900b3a0a09eadb916a458e9b6a3">iterator</a>&amp; operator = (<span class="keyword">const</span> <a class="code" href="classcds_1_1container_1_1_michael_hash_map.html#afcebb900b3a0a09eadb916a458e9b6a3">iterator</a>&amp; src);</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">bool</span> operator ==(<a class="code" href="classcds_1_1container_1_1_michael_hash_map.html#afcebb900b3a0a09eadb916a458e9b6a3">iterator</a> <span class="keyword">const</span>&amp; i ) <span class="keyword">const</span>;</div>
<div class="line"><span class="keywordtype">bool</span> operator !=(<a class="code" href="classcds_1_1container_1_1_michael_hash_map.html#afcebb900b3a0a09eadb916a458e9b6a3">iterator</a> <span class="keyword">const</span>&amp; i ) <span class="keyword">const</span>;</div>
<div class="line">};</div>
</div><!-- fragment --><p> Note, the iterator object returned by <a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#a6d2ff57ccf188ead667fdf511f89adf5">end</a>, <code>cend</code> member functions points to <code>nullptr</code> and should not be dereferenced.</p>
<p><a class="anchor" id="cds_nonintrusive_MichaelHashMap_how_touse"></a><b>How to use</b></p>
<p>Suppose, you want to make <code>int</code> to <code>int</code> map for Hazard Pointer garbage collector. You should choose suitable ordered list class that will be used as a bucket for the map; it may be <code><a class="el" href="classcds_1_1container_1_1_michael_k_v_list.html" title="Michael&#39;s ordered list fo key-value pair. ">MichaelKVList</a></code>. </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;cds/container/michael_kvlist_hp.h&gt;</span>    <span class="comment">// MichaelKVList for gc::HP</span></div>
<div class="line"><span class="preprocessor">#include &lt;cds/container/michael_map.h&gt;</span>          <span class="comment">// MichaelHashMap</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// List traits based on std::less predicate</span></div>
<div class="line"><span class="keyword">struct </span>list_traits: <span class="keyword">public</span> <a class="code" href="structcds_1_1container_1_1michael__list_1_1traits.html">cds::container::michael_list::traits</a></div>
<div class="line">{</div>
<div class="line">    <span class="keyword">typedef</span> std::less&lt;int&gt;      less;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="comment">// Ordered list</span></div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="classcds_1_1container_1_1_michael_k_v_list.html">cds::container::MichaelKVList&lt; cds::gc::HP, int, int, list_traits&gt;</a> int2int_list;</div>
<div class="line"></div>
<div class="line"><span class="comment">// Map traits</span></div>
<div class="line"><span class="keyword">struct </span>map_traits: <span class="keyword">public</span> <a class="code" href="structcds_1_1intrusive_1_1michael__set_1_1traits.html">cds::container::michael_map::traits</a></div>
<div class="line">{</div>
<div class="line">    <span class="keyword">struct </span><a class="code" href="classcds_1_1container_1_1_michael_hash_map.html#a2e514d02a3a23e4fd7844795f908d3bb">hash</a> {</div>
<div class="line">        <span class="keywordtype">size_t</span> operator()( <span class="keywordtype">int</span> i )<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">        </span>{</div>
<div class="line">            <span class="keywordflow">return</span> cds::opt::v::hash&lt;int&gt;()( i );</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="comment">// Your map</span></div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="classcds_1_1container_1_1_michael_hash_map.html">cds::container::MichaelHashMap&lt; cds::gc::HP, int2int_list, map_traits &gt;</a> int2int_map;</div>
<div class="line"></div>
<div class="line"><span class="comment">// Now you can use int2int_map class</span></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">    int2int_map theMap;</div>
<div class="line"></div>
<div class="line">    theMap.<a class="code" href="classcds_1_1container_1_1_michael_hash_map.html#a6811eed99b256e4b43d236c70f76f89d">insert</a>( 100 );</div>
<div class="line">    ...</div>
<div class="line">}</div>
</div><!-- fragment --><p>You may use option-based declaration: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;cds/container/michael_kvlist_hp.h&gt;</span>    <span class="comment">// MichaelKVList for gc::HP</span></div>
<div class="line"><span class="preprocessor">#include &lt;cds/container/michael_map.h&gt;</span>          <span class="comment">// MichaelHashMap</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Ordered list</span></div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="classcds_1_1container_1_1_michael_k_v_list.html">cds::container::MichaelKVList</a>&lt; cds::gc::HP, int, int,</div>
<div class="line">    <span class="keyword">typename</span> <a class="code" href="structcds_1_1container_1_1michael__list_1_1make__traits.html">cds::container::michael_list::make_traits</a>&lt;</div>
<div class="line">        <a class="code" href="structcds_1_1opt_1_1less.html">cds::container::opt::less&lt; std::less&lt;int&gt;</a> &gt;     <span class="comment">// item comparator option</span></div>
<div class="line">    &gt;::type</div>
<div class="line">&gt;  int2int_list;</div>
<div class="line"></div>
<div class="line"><span class="comment">// Map</span></div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="classcds_1_1container_1_1_michael_hash_map.html">cds::container::MichaelHashMap</a>&lt; cds::gc::HP, int2int_list,</div>
<div class="line">    <a class="code" href="structcds_1_1intrusive_1_1michael__set_1_1make__traits.html">cds::container::michael_map::make_traits</a>&lt;</div>
<div class="line">        cc::opt::hash&lt; cds::opt::v::hash&lt;int&gt; &gt;</div>
<div class="line">    &gt;</div>
<div class="line">&gt; int2int_map;</div>
</div><!-- fragment --> </div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a5b4756d55e75b439fe75adb6aebc5b19"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GC , class OrderedList , class Traits  = michael_map::traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1container_1_1_michael_hash_map.html">cds::container::MichaelHashMap</a>&lt; GC, OrderedList, Traits &gt;::<a class="el" href="classcds_1_1container_1_1_michael_hash_map.html">MichaelHashMap</a> </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nMaxItemCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nLoadFactor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes the map. </p>
<p><a class="anchor" id="cds_nonintrusive_MichaelHashMap_hp_ctor"></a>The Michael's hash map is non-expandable container. You should point the average count of items <code>nMaxItemCount</code> when you create an object. <code>nLoadFactor</code> parameter defines average count of items per bucket and it should be small number between 1 and 10. Remember, since the bucket implementation is an ordered list, searching in the bucket is linear [<code>O(nLoadFactor)</code>]. Note, that many popular STL hash map implementation uses load factor 1.</p>
<p>The ctor defines hash table size as rounding <code>nMacItemCount / nLoadFactor</code> up to nearest power of two. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nMaxItemCount</td><td>estimation of max item count in the hash map </td></tr>
    <tr><td class="paramname">nLoadFactor</td><td>load factor: estimation of max number of items in the bucket </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="ae837465b5c985e4856f4c368f638a097"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GC , class OrderedList , class Traits  = michael_map::traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#afcebb900b3a0a09eadb916a458e9b6a3">iterator</a> <a class="el" href="classcds_1_1container_1_1_michael_hash_map.html">cds::container::MichaelHashMap</a>&lt; GC, OrderedList, Traits &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a forward iterator addressing the first element in a map. </p>
<p>For empty map</p><div class="fragment"><div class="line"><a class="code" href="classcds_1_1container_1_1_michael_hash_map.html#ae837465b5c985e4856f4c368f638a097">begin</a>() == <a class="code" href="classcds_1_1container_1_1_michael_hash_map.html#a6d2ff57ccf188ead667fdf511f89adf5">end</a>() </div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a373126e1df3c7c05000ccc9959302174"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GC , class OrderedList , class Traits  = michael_map::traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classcds_1_1container_1_1_michael_hash_map.html">cds::container::MichaelHashMap</a>&lt; GC, OrderedList, Traits &gt;::bucket_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the size of hash table. </p>
<p>Since <code>MichaelHashMap</code> cannot dynamically extend the hash table size, the value returned is an constant depending on object initialization parameters; see <code><a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#a5b4756d55e75b439fe75adb6aebc5b19" title="Initializes the map. ">MichaelHashMap::MichaelHashMap</a></code> for explanation. </p>

</div>
</div>
<a class="anchor" id="a1f0c8b93a02e4e3524fabc22ef51984f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GC , class OrderedList , class Traits  = michael_map::traits&gt; </div>
<div class="memtemplate">
template&lt;typename K &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_michael_hash_map.html">cds::container::MichaelHashMap</a>&lt; GC, OrderedList, Traits &gt;::contains </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether the map contains <code>key</code>. </p>
<p>The function searches the item with key equal to <code>key</code> and returns <code>true</code> if it is found, and <code>false</code> otherwise. </p>

</div>
</div>
<a class="anchor" id="a738b53a472a211ecc94e5207cfdc3df0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GC , class OrderedList , class Traits  = michael_map::traits&gt; </div>
<div class="memtemplate">
template&lt;typename K , typename Less &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_michael_hash_map.html">cds::container::MichaelHashMap</a>&lt; GC, OrderedList, Traits &gt;::contains </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Less&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether the map contains <code>key</code> using <code>pred</code> predicate for searching. </p>
<p>The function is an analog of <code>contains( key )</code> but <code>pred</code> is used for key comparing. <code>Less</code> functor has the interface like <code>std::less</code>. <code>Less</code> must imply the same element order as the comparator used for building the map. </p>

</div>
</div>
<a class="anchor" id="a3f1536210a794b018de5943db1ff6e80"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GC , class OrderedList , class Traits  = michael_map::traits&gt; </div>
<div class="memtemplate">
template&lt;typename K , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_michael_hash_map.html">cds::container::MichaelHashMap</a>&lt; GC, OrderedList, Traits &gt;::emplace </td>
          <td>(</td>
          <td class="paramtype">K &amp;&amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For key <code>key</code> inserts data of type <code>mapped_type</code> created from <code>args</code>. </p>
<p><code>key_type</code> should be constructible from type <code>K</code> </p>
<p>Returns <code>true</code> if inserting successful, <code>false</code> otherwise. </p>

</div>
</div>
<a class="anchor" id="a8010a7896995c83154ecfe1ae3ddd521"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GC , class OrderedList , class Traits  = michael_map::traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_michael_hash_map.html">cds::container::MichaelHashMap</a>&lt; GC, OrderedList, Traits &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the map is empty. </p>
<p>Emptiness is checked by item counting: if item count is zero then the map is empty. Thus, the correct item counting is an important part of the map implementation. </p>

</div>
</div>
<a class="anchor" id="a6d2ff57ccf188ead667fdf511f89adf5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GC , class OrderedList , class Traits  = michael_map::traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#afcebb900b3a0a09eadb916a458e9b6a3">iterator</a> <a class="el" href="classcds_1_1container_1_1_michael_hash_map.html">cds::container::MichaelHashMap</a>&lt; GC, OrderedList, Traits &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator that addresses the location succeeding the last element in a map. </p>
<p>Do not use the value returned by <code>end</code> function to access any item. The returned value can be used only to control reaching the end of the map. For empty map</p><div class="fragment"><div class="line"><a class="code" href="classcds_1_1container_1_1_michael_hash_map.html#ae837465b5c985e4856f4c368f638a097">begin</a>() == <a class="code" href="classcds_1_1container_1_1_michael_hash_map.html#a6d2ff57ccf188ead667fdf511f89adf5">end</a>() </div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ab3e87d786b614fe694467bbd91daecbc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GC , class OrderedList , class Traits  = michael_map::traits&gt; </div>
<div class="memtemplate">
template&lt;typename K &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_michael_hash_map.html">cds::container::MichaelHashMap</a>&lt; GC, OrderedList, Traits &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deletes <code>key</code> from the map. </p>
<p><a class="anchor" id="cds_nonintrusive_MichaelMap_erase_val"></a> Return <code>true</code> if <code>key</code> is found and deleted, <code>false</code> otherwise </p>

</div>
</div>
<a class="anchor" id="ab078ecdb8dde43dd992e9f63fc96c7a3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GC , class OrderedList , class Traits  = michael_map::traits&gt; </div>
<div class="memtemplate">
template&lt;typename K , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_michael_hash_map.html">cds::container::MichaelHashMap</a>&lt; GC, OrderedList, Traits &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deletes <code>key</code> from the map. </p>
<p><a class="anchor" id="cds_nonintrusive_MichaelMap_erase_func"></a> The function searches an item with key <code>key</code>, calls <code>f</code> functor and deletes the item. If <code>key</code> is not found, the functor is not called.</p>
<p>The functor <code>Func</code> interface: </p><div class="fragment"><div class="line"><span class="keyword">struct </span>extractor {</div>
<div class="line">    <span class="keywordtype">void</span> operator()(<a class="code" href="classcds_1_1container_1_1_michael_hash_map.html#a4518129d579bbd5bc4612264d6cff2a6">value_type</a>&amp; item) { ... }</div>
<div class="line">};</div>
</div><!-- fragment --><p>Return <code>true</code> if key is found and deleted, <code>false</code> otherwise </p>

</div>
</div>
<a class="anchor" id="a5e9dbb7e4991a31b78237f2ef3671307"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GC , class OrderedList , class Traits  = michael_map::traits&gt; </div>
<div class="memtemplate">
template&lt;typename K , typename Less &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_michael_hash_map.html">cds::container::MichaelHashMap</a>&lt; GC, OrderedList, Traits &gt;::erase_with </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Less&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deletes the item from the map using <code>pred</code> predicate for searching. </p>
<p>The function is an analog of <a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#cds_nonintrusive_MichaelMap_erase_val">erase(K const&amp;)</a> but <code>pred</code> is used for key comparing. <code>Less</code> functor has the interface like <code>std::less</code>. <code>Less</code> must imply the same element order as the comparator used for building the map. </p>

</div>
</div>
<a class="anchor" id="a382ac299a8ccda2272ec27296361da8c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GC , class OrderedList , class Traits  = michael_map::traits&gt; </div>
<div class="memtemplate">
template&lt;typename K , typename Less , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_michael_hash_map.html">cds::container::MichaelHashMap</a>&lt; GC, OrderedList, Traits &gt;::erase_with </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Less&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deletes the item from the map using <code>pred</code> predicate for searching. </p>
<p>The function is an analog of <a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#cds_nonintrusive_MichaelMap_erase_func">erase(K const&amp;, Func)</a> but <code>pred</code> is used for key comparing. <code>Less</code> functor has the interface like <code>std::less</code>. <code>Less</code> must imply the same element order as the comparator used for building the map. </p>

</div>
</div>
<a class="anchor" id="a294aef3736ea5e317175e0696a1e0b00"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GC , class OrderedList , class Traits  = michael_map::traits&gt; </div>
<div class="memtemplate">
template&lt;typename K &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#a94920ec4604b846e396acf80f2f7baf8">guarded_ptr</a> <a class="el" href="classcds_1_1container_1_1_michael_hash_map.html">cds::container::MichaelHashMap</a>&lt; GC, OrderedList, Traits &gt;::extract </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extracts the item with specified <code>key</code>. </p>
<p><a class="anchor" id="cds_nonintrusive_MichaelHashMap_hp_extract"></a>The function searches an item with key equal to <code>key</code>, unlinks it from the set, and returns it as <code>guarded_ptr</code>. If <code>key</code> is not found the function returns an empty guarded pointer.</p>
<p>Note the compare functor should accept a parameter of type <code>K</code> that may be not the same as <code>key_type</code>.</p>
<p>The extracted item is freed automatically when returned <code>guarded_ptr</code> object will be destroyed or released. </p><dl class="section note"><dt>Note</dt><dd>Each <code>guarded_ptr</code> object uses the GC's guard that can be limited resource.</dd></dl>
<p>Usage: </p><div class="fragment"><div class="line"><span class="keyword">typedef</span> <a class="code" href="classcds_1_1container_1_1_michael_hash_map.html">cds::container::MichaelHashMap&lt; your_template_args &gt;</a> michael_map;</div>
<div class="line">michael_map theMap;</div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line">{</div>
<div class="line">    michael_map::guarded_ptr gp( theMap.extract( 5 ));</div>
<div class="line">    <span class="keywordflow">if</span> ( gp ) {</div>
<div class="line">        <span class="comment">// Deal with gp</span></div>
<div class="line">        <span class="comment">// ...</span></div>
<div class="line">    }</div>
<div class="line">    <span class="comment">// Destructor of gp releases internal HP guard</span></div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a35f075a257e000fff5c0b8aa7cc38500"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GC , class OrderedList , class Traits  = michael_map::traits&gt; </div>
<div class="memtemplate">
template&lt;typename K , typename Less &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#a94920ec4604b846e396acf80f2f7baf8">guarded_ptr</a> <a class="el" href="classcds_1_1container_1_1_michael_hash_map.html">cds::container::MichaelHashMap</a>&lt; GC, OrderedList, Traits &gt;::extract_with </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Less&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extracts the item using compare functor <code>pred</code>. </p>
<p>The function is an analog of <a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#cds_nonintrusive_MichaelHashMap_hp_extract">extract(K const&amp;)</a> but <code>pred</code> predicate is used for key comparing.</p>
<p><code>Less</code> functor has the semantics like <code>std::less</code> but should take arguments of type <code>key_type</code> and <code>K</code> in any order. <code>pred</code> must imply the same element order as the comparator used for building the map. </p>

</div>
</div>
<a class="anchor" id="a463d8d7851dedae6fcc0d9b0d82c2e6d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GC , class OrderedList , class Traits  = michael_map::traits&gt; </div>
<div class="memtemplate">
template&lt;typename K , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_michael_hash_map.html">cds::container::MichaelHashMap</a>&lt; GC, OrderedList, Traits &gt;::find </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the key <code>key</code>. </p>
<p><a class="anchor" id="cds_nonintrusive_MichaelMap_find_cfunc"></a> The function searches the item with key equal to <code>key</code> and calls the functor <code>f</code> for item found. The interface of <code>Func</code> functor is: </p><div class="fragment"><div class="line"><span class="keyword">struct </span>functor {</div>
<div class="line">    <span class="keywordtype">void</span> operator()( <a class="code" href="classcds_1_1container_1_1_michael_hash_map.html#a4518129d579bbd5bc4612264d6cff2a6">value_type</a>&amp; item );</div>
<div class="line">};</div>
</div><!-- fragment --><p> where <code>item</code> is the item found.</p>
<p>The functor may change <code>item.second</code>. Note that the functor is only guarantee that <code>item</code> cannot be disposed during functor is executing. The functor does not serialize simultaneous access to the map's <code>item</code>. If such access is possible you must provide your own synchronization schema on item level to exclude unsafe item modifications.</p>
<p>The function returns <code>true</code> if <code>key</code> is found, <code>false</code> otherwise. </p>

</div>
</div>
<a class="anchor" id="acfcdb0d94caf721d23c8d867f9e26336"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GC , class OrderedList , class Traits  = michael_map::traits&gt; </div>
<div class="memtemplate">
template&lt;typename K , typename Less , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_michael_hash_map.html">cds::container::MichaelHashMap</a>&lt; GC, OrderedList, Traits &gt;::find_with </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Less&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the key <code>val</code> using <code>pred</code> predicate for searching. </p>
<p>The function is an analog of <a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#cds_nonintrusive_MichaelMap_find_cfunc">find(K const&amp;, Func)</a> but <code>pred</code> is used for key comparing. <code>Less</code> functor has the interface like <code>std::less</code>. <code>Less</code> must imply the same element order as the comparator used for building the map. </p>

</div>
</div>
<a class="anchor" id="ae88464eafb958bd8df621ecf783e73c5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GC , class OrderedList , class Traits  = michael_map::traits&gt; </div>
<div class="memtemplate">
template&lt;typename K &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#a94920ec4604b846e396acf80f2f7baf8">guarded_ptr</a> <a class="el" href="classcds_1_1container_1_1_michael_hash_map.html">cds::container::MichaelHashMap</a>&lt; GC, OrderedList, Traits &gt;::get </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds <code>key</code> and return the item found. </p>
<p><a class="anchor" id="cds_nonintrusive_MichaelHashMap_hp_get"></a>The function searches the item with key equal to <code>key</code> and returns the guarded pointer to the item found. If <code>key</code> is not found the function returns an empty guarded pointer,</p>
<dl class="section note"><dt>Note</dt><dd>Each <code>guarded_ptr</code> object uses one GC's guard which can be limited resource.</dd></dl>
<p>Usage: </p><div class="fragment"><div class="line"><span class="keyword">typedef</span> cds::container::MichaeHashMap&lt; your_template_params &gt;  michael_map;</div>
<div class="line">michael_map theMap;</div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line">{</div>
<div class="line">    michael_map::guarded_ptr gp( theMap.get( 5 ));</div>
<div class="line">    <span class="keywordflow">if</span> ( gp ) {</div>
<div class="line">        <span class="comment">// Deal with gp</span></div>
<div class="line">        <span class="comment">//...</span></div>
<div class="line">    }</div>
<div class="line">    <span class="comment">// Destructor of guarded_ptr releases internal HP guard</span></div>
<div class="line">}</div>
</div><!-- fragment --><p>Note the compare functor specified for <code>OrderedList</code> template parameter should accept a parameter of type <code>K</code> that can be not the same as <code>key_type</code>. </p>

</div>
</div>
<a class="anchor" id="a41e2ae292ef69778acbf191c38b5c34c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GC , class OrderedList , class Traits  = michael_map::traits&gt; </div>
<div class="memtemplate">
template&lt;typename K , typename Less &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#a94920ec4604b846e396acf80f2f7baf8">guarded_ptr</a> <a class="el" href="classcds_1_1container_1_1_michael_hash_map.html">cds::container::MichaelHashMap</a>&lt; GC, OrderedList, Traits &gt;::get_with </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Less&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds <code>key</code> and return the item found. </p>
<p>The function is an analog of <a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#cds_nonintrusive_MichaelHashMap_hp_get">get( K const&amp;)</a> but <code>pred</code> is used for comparing the keys.</p>
<p><code>Less</code> functor has the semantics like <code>std::less</code> but should take arguments of type <code>key_type</code> and <code>K</code> in any order. <code>pred</code> must imply the same element order as the comparator used for building the map. </p>

</div>
</div>
<a class="anchor" id="a6811eed99b256e4b43d236c70f76f89d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GC , class OrderedList , class Traits  = michael_map::traits&gt; </div>
<div class="memtemplate">
template&lt;typename K &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_michael_hash_map.html">cds::container::MichaelHashMap</a>&lt; GC, OrderedList, Traits &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts new node with key and default value. </p>
<p>The function creates a node with <code>key</code> and default value, and then inserts the node created into the map.</p>
<p>Preconditions:</p><ul>
<li>The <code>key_type</code> should be constructible from value of type <code>K</code>. In trivial case, <code>K</code> is equal to <code>key_type</code>.</li>
<li>The <code>mapped_type</code> should be default-constructible.</li>
</ul>
<p>Returns <code>true</code> if inserting successful, <code>false</code> otherwise. </p>

</div>
</div>
<a class="anchor" id="addbf87015ecd7d552832e0e57d498149"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GC , class OrderedList , class Traits  = michael_map::traits&gt; </div>
<div class="memtemplate">
template&lt;typename K , typename V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_michael_hash_map.html">cds::container::MichaelHashMap</a>&lt; GC, OrderedList, Traits &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">V const &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts new node. </p>
<p>The function creates a node with copy of <code>val</code> value and then inserts the node created into the map.</p>
<p>Preconditions:</p><ul>
<li>The <code>key_type</code> should be constructible from <code>key</code> of type <code>K</code>.</li>
<li>The <code>mapped_type</code> should be constructible from <code>val</code> of type <code>V</code>.</li>
</ul>
<p>Returns <code>true</code> if <code>val</code> is inserted into the map, <code>false</code> otherwise. </p>

</div>
</div>
<a class="anchor" id="aa315efe0dd22cba34ce70810b43ebf33"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GC , class OrderedList , class Traits  = michael_map::traits&gt; </div>
<div class="memtemplate">
template&lt;typename K , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_michael_hash_map.html">cds::container::MichaelHashMap</a>&lt; GC, OrderedList, Traits &gt;::insert_with </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts new node and initialize it by a functor. </p>
<p>This function inserts new node with key <code>key</code> and if inserting is successful then it calls <code>func</code> functor with signature </p><div class="fragment"><div class="line"><span class="keyword">struct </span>functor {</div>
<div class="line">    <span class="keywordtype">void</span> operator()( <a class="code" href="classcds_1_1container_1_1_michael_hash_map.html#a4518129d579bbd5bc4612264d6cff2a6">value_type</a>&amp; item );</div>
<div class="line">};</div>
</div><!-- fragment --><p>The argument <code>item</code> of user-defined functor <code>func</code> is the reference to the map's item inserted:</p><ul>
<li><code>item.first</code> is a const reference to item's key that cannot be changed.</li>
<li><code>item.second</code> is a reference to item's value that may be changed.</li>
</ul>
<p>The user-defined functor is called only if inserting is successful.</p>
<p>The <code>key_type</code> should be constructible from value of type <code>K</code>.</p>
<p>The function allows to split creating of new item into two part:</p><ul>
<li>create item from <code>key</code>;</li>
<li>insert new item into the map;</li>
<li>if inserting is successful, initialize the value of item by calling <code>func</code> functor</li>
</ul>
<p>This can be useful if complete initialization of object of <code>mapped_type</code> is heavyweight and it is preferable that the initialization should be completed only if inserting is successful.</p>
<dl class="section warning"><dt>Warning</dt><dd>For <a class="el" href="classcds_1_1container_1_1_michael_k_v_list.html#cds_nonintrusive_MichaelKVList_gc">MichaelKVList</a> as the bucket see <a class="el" href="namespacecds_1_1intrusive.html#cds_intrusive_item_creating">insert item troubleshooting</a>. <a class="el" href="classcds_1_1container_1_1_lazy_k_v_list.html#cds_nonintrusive_LazyKVList_gc">LazyKVList</a> provides exclusive access to inserted item and does not require any node-level synchronization. </dd></dl>

</div>
</div>
<a class="anchor" id="abf597d4571369d6c83c442963abce4f2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GC , class OrderedList , class Traits  = michael_map::traits&gt; </div>
<div class="memtemplate">
template&lt;typename K , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;bool, bool&gt; <a class="el" href="classcds_1_1container_1_1_michael_hash_map.html">cds::container::MichaelHashMap</a>&lt; GC, OrderedList, Traits &gt;::update </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bAllowInsert</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Updates data by <code>key</code>. </p>
<p>The operation performs inserting or replacing the element with lock-free manner.</p>
<p>If the <code>key</code> not found in the map, then the new item created from <code>key</code> will be inserted into the map iff <code>bAllowInsert</code> is <code>true</code>. (note that in this case the <a class="el" href="classcds_1_1container_1_1_michael_hash_map.html#a17107223d19776ad3d0cdf29591cc545">key_type</a> should be constructible from type <code>K</code>). Otherwise, if <code>key</code> is found, the functor <code>func</code> is called with item found.</p>
<p>The functor <code>Func</code> signature is: </p><div class="fragment"><div class="line"><span class="keyword">struct </span>my_functor {</div>
<div class="line">    <span class="keywordtype">void</span> operator()( <span class="keywordtype">bool</span> bNew, <a class="code" href="classcds_1_1container_1_1_michael_hash_map.html#a4518129d579bbd5bc4612264d6cff2a6">value_type</a>&amp; item );</div>
<div class="line">};</div>
</div><!-- fragment --><p> with arguments:</p><ul>
<li><code>bNew</code> - <code>true</code> if the item has been inserted, <code>false</code> otherwise</li>
<li><code>item</code> - the item found or inserted</li>
</ul>
<p>The functor may change any fields of the <code>item.second</code> that is <code>mapped_type</code>.</p>
<p>Returns <code> std::pair&lt;bool, bool&gt; </code> where <code>first</code> is true if operation is successfull, <code>second</code> is true if new item has been added or <code>false</code> if the item with <code>key</code> already exists.</p>
<dl class="section warning"><dt>Warning</dt><dd>For <a class="el" href="classcds_1_1container_1_1_michael_k_v_list.html#cds_nonintrusive_MichaelKVList_gc">MichaelKVList</a> as the bucket see <a class="el" href="namespacecds_1_1intrusive.html#cds_intrusive_item_creating">insert item troubleshooting</a>. <a class="el" href="classcds_1_1container_1_1_lazy_k_v_list.html#cds_nonintrusive_LazyKVList_gc">LazyKVList</a> provides exclusive access to inserted item and does not require any node-level synchronization. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>cds/container/michael_map.h</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<hr/>
<div align="right">
  <b>cds</b> <b>2.1.0</b> 
  Developed by <i>Maxim Khizhinsky aka khizmax</i> 2007 - 2015
  <br/>
  <i>Autogenerated Wed Jan 6 2016 16:00:38 by Doxygen 1.8.10</i>
</div>
</body>
</html>
