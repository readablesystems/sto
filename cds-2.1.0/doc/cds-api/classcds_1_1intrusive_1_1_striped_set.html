<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>cds: cds::intrusive::StripedSet&lt; Container, Options &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">cds
   &#160;<span id="projectnumber">2.1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="classes.html"><span>Data&#160;Structure&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Data&#160;Fields</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classcds_1_1intrusive_1_1_striped_set.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pro-static-attribs">Static Protected Attributes</a>  </div>
  <div class="headertitle">
<div class="title">cds::intrusive::StripedSet&lt; Container, Options &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__cds__intrusive__containers.html">Intrusive containers</a> &raquo; <a class="el" href="group__cds__intrusive__map.html">Set</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Striped hash set.  
 <a href="classcds_1_1intrusive_1_1_striped_set.html#details">More...</a></p>

<p><code>#include &lt;cds/intrusive/striped_set.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a30062f90ac31fe161c7cd4539fcaaf13"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a30062f90ac31fe161c7cd4539fcaaf13"></a>
typedef Container&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#a30062f90ac31fe161c7cd4539fcaaf13">underlying_container_type</a></td></tr>
<tr class="memdesc:a30062f90ac31fe161c7cd4539fcaaf13"><td class="mdescLeft">&#160;</td><td class="mdescRight">original intrusive container type for the bucket <br /></td></tr>
<tr class="separator:a30062f90ac31fe161c7cd4539fcaaf13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0f7511b1b3c53680be6608678020bb5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac0f7511b1b3c53680be6608678020bb5"></a>
typedef <a class="el" href="classcds_1_1intrusive_1_1striped__set_1_1adapt.html">cds::intrusive::striped_set::adapt</a>&lt; <a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#a30062f90ac31fe161c7cd4539fcaaf13">underlying_container_type</a>, Options... &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#ac0f7511b1b3c53680be6608678020bb5">bucket_type</a></td></tr>
<tr class="memdesc:ac0f7511b1b3c53680be6608678020bb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">container type adapted for hash set <br /></td></tr>
<tr class="separator:ac0f7511b1b3c53680be6608678020bb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a999c16c7efc7a140c386cf8089d43f7b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a999c16c7efc7a140c386cf8089d43f7b"></a>
typedef bucket_type::value_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#a999c16c7efc7a140c386cf8089d43f7b">value_type</a></td></tr>
<tr class="memdesc:a999c16c7efc7a140c386cf8089d43f7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">value type stored in the set <br /></td></tr>
<tr class="separator:a999c16c7efc7a140c386cf8089d43f7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b11af7149d2edcdcf89875dd82f29c3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3b11af7149d2edcdcf89875dd82f29c3"></a>
typedef options::hash&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#a3b11af7149d2edcdcf89875dd82f29c3">hash</a></td></tr>
<tr class="memdesc:a3b11af7149d2edcdcf89875dd82f29c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hash functor. <br /></td></tr>
<tr class="separator:a3b11af7149d2edcdcf89875dd82f29c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc27916ad8566742257adde4f5b0d36c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abc27916ad8566742257adde4f5b0d36c"></a>
typedef options::item_counter&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#abc27916ad8566742257adde4f5b0d36c">item_counter</a></td></tr>
<tr class="memdesc:abc27916ad8566742257adde4f5b0d36c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Item counter. <br /></td></tr>
<tr class="separator:abc27916ad8566742257adde4f5b0d36c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73e9218d8f7724ddc07c1b41c8d91e7f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a73e9218d8f7724ddc07c1b41c8d91e7f"></a>
typedef <a class="el" href="structcds_1_1opt_1_1select__default.html">cds::opt::select_default</a>&lt; typename options::resizing_policy, typename bucket_type::default_resizing_policy &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#a73e9218d8f7724ddc07c1b41c8d91e7f">resizing_policy</a></td></tr>
<tr class="memdesc:a73e9218d8f7724ddc07c1b41c8d91e7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resizing policy. <br /></td></tr>
<tr class="separator:a73e9218d8f7724ddc07c1b41c8d91e7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47cdc2d40853a651780c1a2afe7309ed"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a47cdc2d40853a651780c1a2afe7309ed"></a>
typedef options::allocator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#a47cdc2d40853a651780c1a2afe7309ed">allocator_type</a></td></tr>
<tr class="memdesc:a47cdc2d40853a651780c1a2afe7309ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">allocator type specified in options. <br /></td></tr>
<tr class="separator:a47cdc2d40853a651780c1a2afe7309ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af672d590a91e09833aa27621f7e35c26"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af672d590a91e09833aa27621f7e35c26"></a>
typedef options::mutex_policy&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#af672d590a91e09833aa27621f7e35c26">mutex_policy</a></td></tr>
<tr class="memdesc:af672d590a91e09833aa27621f7e35c26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mutex policy. <br /></td></tr>
<tr class="separator:af672d590a91e09833aa27621f7e35c26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7217f5fc38b03f908957969c227dc28"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad7217f5fc38b03f908957969c227dc28"></a>
typedef <a class="el" href="classcds_1_1details_1_1_allocator.html">cds::details::Allocator</a>&lt; <a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#ac0f7511b1b3c53680be6608678020bb5">bucket_type</a>, <a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#a47cdc2d40853a651780c1a2afe7309ed">allocator_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#ad7217f5fc38b03f908957969c227dc28">bucket_allocator</a></td></tr>
<tr class="memdesc:ad7217f5fc38b03f908957969c227dc28"><td class="mdescLeft">&#160;</td><td class="mdescRight">bucket allocator type based on allocator_type <br /></td></tr>
<tr class="separator:ad7217f5fc38b03f908957969c227dc28"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a8c4b97b427950b0b119e6314337611a6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8c4b97b427950b0b119e6314337611a6"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#a8c4b97b427950b0b119e6314337611a6">StripedSet</a> ()</td></tr>
<tr class="memdesc:a8c4b97b427950b0b119e6314337611a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default ctor. The initial capacity is 16. <br /></td></tr>
<tr class="separator:a8c4b97b427950b0b119e6314337611a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a8ca33aa2ce383440759a0cf0a177e1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#a1a8ca33aa2ce383440759a0cf0a177e1">StripedSet</a> (size_t nCapacity)</td></tr>
<tr class="memdesc:a1a8ca33aa2ce383440759a0cf0a177e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ctor with initial capacity specified.  <a href="#a1a8ca33aa2ce383440759a0cf0a177e1">More...</a><br /></td></tr>
<tr class="separator:a1a8ca33aa2ce383440759a0cf0a177e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab742138d7bfcfb5ad100bff319baac1a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#ab742138d7bfcfb5ad100bff319baac1a">StripedSet</a> (size_t nCapacity,<a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#a73e9218d8f7724ddc07c1b41c8d91e7f">resizing_policy</a> const &amp;resizingPolicy)</td></tr>
<tr class="memdesc:ab742138d7bfcfb5ad100bff319baac1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ctor with resizing policy (copy semantics)  <a href="#ab742138d7bfcfb5ad100bff319baac1a">More...</a><br /></td></tr>
<tr class="separator:ab742138d7bfcfb5ad100bff319baac1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f6cceace08ecb8ccae4c1c0c7841f88"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#a9f6cceace08ecb8ccae4c1c0c7841f88">StripedSet</a> (size_t nCapacity,<a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#a73e9218d8f7724ddc07c1b41c8d91e7f">resizing_policy</a> &amp;&amp;resizingPolicy)</td></tr>
<tr class="memdesc:a9f6cceace08ecb8ccae4c1c0c7841f88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ctor with resizing policy (move semantics)  <a href="#a9f6cceace08ecb8ccae4c1c0c7841f88">More...</a><br /></td></tr>
<tr class="separator:a9f6cceace08ecb8ccae4c1c0c7841f88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a723409ba0e656ba3bbd54d41356ec710"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a723409ba0e656ba3bbd54d41356ec710"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#a723409ba0e656ba3bbd54d41356ec710">~StripedSet</a> ()</td></tr>
<tr class="memdesc:a723409ba0e656ba3bbd54d41356ec710"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor destroys internal data. <br /></td></tr>
<tr class="separator:a723409ba0e656ba3bbd54d41356ec710"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9596e3aea5464a77437d6d8cdfc288f5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#a9596e3aea5464a77437d6d8cdfc288f5">insert</a> (<a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#a999c16c7efc7a140c386cf8089d43f7b">value_type</a> &amp;val)</td></tr>
<tr class="memdesc:a9596e3aea5464a77437d6d8cdfc288f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new node.  <a href="#a9596e3aea5464a77437d6d8cdfc288f5">More...</a><br /></td></tr>
<tr class="separator:a9596e3aea5464a77437d6d8cdfc288f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e8e96d52afa3d2c265c269af1a1ba3c"><td class="memTemplParams" colspan="2">template&lt;typename Func &gt; </td></tr>
<tr class="memitem:a4e8e96d52afa3d2c265c269af1a1ba3c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#a4e8e96d52afa3d2c265c269af1a1ba3c">insert</a> (<a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#a999c16c7efc7a140c386cf8089d43f7b">value_type</a> &amp;val, Func f)</td></tr>
<tr class="memdesc:a4e8e96d52afa3d2c265c269af1a1ba3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new node.  <a href="#a4e8e96d52afa3d2c265c269af1a1ba3c">More...</a><br /></td></tr>
<tr class="separator:a4e8e96d52afa3d2c265c269af1a1ba3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a432eb9fc2f0cf92fcf3a3b22ef6d8510"><td class="memTemplParams" colspan="2">template&lt;typename Func &gt; </td></tr>
<tr class="memitem:a432eb9fc2f0cf92fcf3a3b22ef6d8510"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; bool, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#a432eb9fc2f0cf92fcf3a3b22ef6d8510">update</a> (<a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#a999c16c7efc7a140c386cf8089d43f7b">value_type</a> &amp;val, Func func, bool bAllowInsert=true)</td></tr>
<tr class="memdesc:a432eb9fc2f0cf92fcf3a3b22ef6d8510"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the node.  <a href="#a432eb9fc2f0cf92fcf3a3b22ef6d8510">More...</a><br /></td></tr>
<tr class="separator:a432eb9fc2f0cf92fcf3a3b22ef6d8510"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbc4dd64160d03646b1f7c163f95369e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#adbc4dd64160d03646b1f7c163f95369e">unlink</a> (<a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#a999c16c7efc7a140c386cf8089d43f7b">value_type</a> &amp;val)</td></tr>
<tr class="memdesc:adbc4dd64160d03646b1f7c163f95369e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlink the item <code>val</code> from the set.  <a href="#adbc4dd64160d03646b1f7c163f95369e">More...</a><br /></td></tr>
<tr class="separator:adbc4dd64160d03646b1f7c163f95369e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93f0b317f12dd1db7b57ac7f9c4c68b2"><td class="memTemplParams" colspan="2">template&lt;typename Q &gt; </td></tr>
<tr class="memitem:a93f0b317f12dd1db7b57ac7f9c4c68b2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#a999c16c7efc7a140c386cf8089d43f7b">value_type</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#a93f0b317f12dd1db7b57ac7f9c4c68b2">erase</a> (Q const &amp;val)</td></tr>
<tr class="memdesc:a93f0b317f12dd1db7b57ac7f9c4c68b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the item from the set.  <a href="#a93f0b317f12dd1db7b57ac7f9c4c68b2">More...</a><br /></td></tr>
<tr class="separator:a93f0b317f12dd1db7b57ac7f9c4c68b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f556ecd285484def76ab232f515e2af"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Less &gt; </td></tr>
<tr class="memitem:a2f556ecd285484def76ab232f515e2af"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#a999c16c7efc7a140c386cf8089d43f7b">value_type</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#a2f556ecd285484def76ab232f515e2af">erase_with</a> (Q const &amp;val, Less pred)</td></tr>
<tr class="memdesc:a2f556ecd285484def76ab232f515e2af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the item from the set using <code>pred</code> predicate for searching.  <a href="#a2f556ecd285484def76ab232f515e2af">More...</a><br /></td></tr>
<tr class="separator:a2f556ecd285484def76ab232f515e2af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d0800c569994d8548264435b032b1e6"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Func &gt; </td></tr>
<tr class="memitem:a4d0800c569994d8548264435b032b1e6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#a999c16c7efc7a140c386cf8089d43f7b">value_type</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#a4d0800c569994d8548264435b032b1e6">erase</a> (Q const &amp;val, Func f)</td></tr>
<tr class="memdesc:a4d0800c569994d8548264435b032b1e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the item from the set.  <a href="#a4d0800c569994d8548264435b032b1e6">More...</a><br /></td></tr>
<tr class="separator:a4d0800c569994d8548264435b032b1e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae449671e2a1b7bfda93312d17b2a85cd"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Less , typename Func &gt; </td></tr>
<tr class="memitem:ae449671e2a1b7bfda93312d17b2a85cd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#a999c16c7efc7a140c386cf8089d43f7b">value_type</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#ae449671e2a1b7bfda93312d17b2a85cd">erase_with</a> (Q const &amp;val, Less pred, Func f)</td></tr>
<tr class="memdesc:ae449671e2a1b7bfda93312d17b2a85cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the item from the set using <code>pred</code> predicate for searching.  <a href="#ae449671e2a1b7bfda93312d17b2a85cd">More...</a><br /></td></tr>
<tr class="separator:ae449671e2a1b7bfda93312d17b2a85cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af54fb6ea73d499f07611f75973244685"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Func &gt; </td></tr>
<tr class="memitem:af54fb6ea73d499f07611f75973244685"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#af54fb6ea73d499f07611f75973244685">find</a> (Q &amp;val, Func f)</td></tr>
<tr class="memdesc:af54fb6ea73d499f07611f75973244685"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the key <code>val</code>.  <a href="#af54fb6ea73d499f07611f75973244685">More...</a><br /></td></tr>
<tr class="separator:af54fb6ea73d499f07611f75973244685"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af47d38de7746c0701b794c02d7cc79bd"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Less , typename Func &gt; </td></tr>
<tr class="memitem:af47d38de7746c0701b794c02d7cc79bd"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#af47d38de7746c0701b794c02d7cc79bd">find_with</a> (Q &amp;val, Less pred, Func f)</td></tr>
<tr class="memdesc:af47d38de7746c0701b794c02d7cc79bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the key <code>val</code> using <code>pred</code> predicate.  <a href="#af47d38de7746c0701b794c02d7cc79bd">More...</a><br /></td></tr>
<tr class="separator:af47d38de7746c0701b794c02d7cc79bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d1c82507b338a1f5e835117652f48d2"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Func &gt; </td></tr>
<tr class="memitem:a1d1c82507b338a1f5e835117652f48d2"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#a1d1c82507b338a1f5e835117652f48d2">find</a> (Q const &amp;val, Func f)</td></tr>
<tr class="memdesc:a1d1c82507b338a1f5e835117652f48d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the key <code>val</code>.  <a href="#a1d1c82507b338a1f5e835117652f48d2">More...</a><br /></td></tr>
<tr class="separator:a1d1c82507b338a1f5e835117652f48d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4947957c41d99bd6d75ce5b04a975bf5"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Less , typename Func &gt; </td></tr>
<tr class="memitem:a4947957c41d99bd6d75ce5b04a975bf5"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#a4947957c41d99bd6d75ce5b04a975bf5">find_with</a> (Q const &amp;val, Less pred, Func f)</td></tr>
<tr class="memdesc:a4947957c41d99bd6d75ce5b04a975bf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the key <code>val</code> using <code>pred</code> predicate.  <a href="#a4947957c41d99bd6d75ce5b04a975bf5">More...</a><br /></td></tr>
<tr class="separator:a4947957c41d99bd6d75ce5b04a975bf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e681eacb6163d341cacf39607e1471c"><td class="memTemplParams" colspan="2">template&lt;typename Q &gt; </td></tr>
<tr class="memitem:a5e681eacb6163d341cacf39607e1471c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#a5e681eacb6163d341cacf39607e1471c">contains</a> (Q const &amp;key)</td></tr>
<tr class="memdesc:a5e681eacb6163d341cacf39607e1471c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the set contains <code>key</code>.  <a href="#a5e681eacb6163d341cacf39607e1471c">More...</a><br /></td></tr>
<tr class="separator:a5e681eacb6163d341cacf39607e1471c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeec51f0495dce5375e33dbdad5129488"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Less &gt; </td></tr>
<tr class="memitem:aeec51f0495dce5375e33dbdad5129488"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#aeec51f0495dce5375e33dbdad5129488">contains</a> (Q const &amp;key, Less pred)</td></tr>
<tr class="memdesc:aeec51f0495dce5375e33dbdad5129488"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the set contains <code>key</code> using <code>pred</code> predicate for searching.  <a href="#aeec51f0495dce5375e33dbdad5129488">More...</a><br /></td></tr>
<tr class="separator:aeec51f0495dce5375e33dbdad5129488"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c5b7ec995eb6c9ab0de511b4848c356"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#a8c5b7ec995eb6c9ab0de511b4848c356">clear</a> ()</td></tr>
<tr class="memdesc:a8c5b7ec995eb6c9ab0de511b4848c356"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the set.  <a href="#a8c5b7ec995eb6c9ab0de511b4848c356">More...</a><br /></td></tr>
<tr class="separator:a8c5b7ec995eb6c9ab0de511b4848c356"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a922615dc212b034f6946253747c92567"><td class="memTemplParams" colspan="2">template&lt;typename Disposer &gt; </td></tr>
<tr class="memitem:a922615dc212b034f6946253747c92567"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#a922615dc212b034f6946253747c92567">clear_and_dispose</a> (Disposer disposer)</td></tr>
<tr class="memdesc:a922615dc212b034f6946253747c92567"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the set and calls <code>disposer</code> for each item.  <a href="#a922615dc212b034f6946253747c92567">More...</a><br /></td></tr>
<tr class="separator:a922615dc212b034f6946253747c92567"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb5f9adf6fbe7822d3e00454b0ed44af"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#abb5f9adf6fbe7822d3e00454b0ed44af">empty</a> () const </td></tr>
<tr class="memdesc:abb5f9adf6fbe7822d3e00454b0ed44af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the set is empty.  <a href="#abb5f9adf6fbe7822d3e00454b0ed44af">More...</a><br /></td></tr>
<tr class="separator:abb5f9adf6fbe7822d3e00454b0ed44af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a354fc053c00d03040f9390f5cb472cdb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a354fc053c00d03040f9390f5cb472cdb"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#a354fc053c00d03040f9390f5cb472cdb">size</a> () const </td></tr>
<tr class="memdesc:a354fc053c00d03040f9390f5cb472cdb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns item count in the set. <br /></td></tr>
<tr class="separator:a354fc053c00d03040f9390f5cb472cdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3eb93bedca5734685f3564c15b8d5a57"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#a3eb93bedca5734685f3564c15b8d5a57">bucket_count</a> () const </td></tr>
<tr class="memdesc:a3eb93bedca5734685f3564c15b8d5a57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of hash table.  <a href="#a3eb93bedca5734685f3564c15b8d5a57">More...</a><br /></td></tr>
<tr class="separator:a3eb93bedca5734685f3564c15b8d5a57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a440c7cfed101aedb28eb89d37e760cf7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a440c7cfed101aedb28eb89d37e760cf7"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#a440c7cfed101aedb28eb89d37e760cf7">lock_count</a> () const </td></tr>
<tr class="memdesc:a440c7cfed101aedb28eb89d37e760cf7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns lock array size. <br /></td></tr>
<tr class="separator:a440c7cfed101aedb28eb89d37e760cf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeecf47c14957c54d2286e1780ac05191"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aeecf47c14957c54d2286e1780ac05191"></a>
<a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#a73e9218d8f7724ddc07c1b41c8d91e7f">resizing_policy</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#aeecf47c14957c54d2286e1780ac05191">get_resizing_policy</a> ()</td></tr>
<tr class="memdesc:aeecf47c14957c54d2286e1780ac05191"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns resizing policy object. <br /></td></tr>
<tr class="separator:aeecf47c14957c54d2286e1780ac05191"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf9a811bafc54d916c11dea45a0332ea"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acf9a811bafc54d916c11dea45a0332ea"></a>
<a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#a73e9218d8f7724ddc07c1b41c8d91e7f">resizing_policy</a> const &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#acf9a811bafc54d916c11dea45a0332ea">get_resizing_policy</a> () const </td></tr>
<tr class="memdesc:acf9a811bafc54d916c11dea45a0332ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns resizing policy (const version) <br /></td></tr>
<tr class="separator:acf9a811bafc54d916c11dea45a0332ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:aa37baad9eed29bf24f0ddf890e0d01e8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa37baad9eed29bf24f0ddf890e0d01e8"></a>
<a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#ac0f7511b1b3c53680be6608678020bb5">bucket_type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#aa37baad9eed29bf24f0ddf890e0d01e8">m_Buckets</a></td></tr>
<tr class="memdesc:aa37baad9eed29bf24f0ddf890e0d01e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bucket table. <br /></td></tr>
<tr class="separator:aa37baad9eed29bf24f0ddf890e0d01e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ce4bd75c1b37fc12b1d5ea2ae0da65e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1ce4bd75c1b37fc12b1d5ea2ae0da65e"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#a1ce4bd75c1b37fc12b1d5ea2ae0da65e">m_nBucketMask</a></td></tr>
<tr class="memdesc:a1ce4bd75c1b37fc12b1d5ea2ae0da65e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bucket table size - 1. m_nBucketMask + 1 should be power of two. <br /></td></tr>
<tr class="separator:a1ce4bd75c1b37fc12b1d5ea2ae0da65e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1657b63e8f07fd22c313304f2d3ca0c5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1657b63e8f07fd22c313304f2d3ca0c5"></a>
<a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#abc27916ad8566742257adde4f5b0d36c">item_counter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#a1657b63e8f07fd22c313304f2d3ca0c5">m_ItemCounter</a></td></tr>
<tr class="memdesc:a1657b63e8f07fd22c313304f2d3ca0c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Item counter. <br /></td></tr>
<tr class="separator:a1657b63e8f07fd22c313304f2d3ca0c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13b44bfb69b63d39d2a966b416736716"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a13b44bfb69b63d39d2a966b416736716"></a>
<a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#a3b11af7149d2edcdcf89875dd82f29c3">hash</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#a13b44bfb69b63d39d2a966b416736716">m_Hash</a></td></tr>
<tr class="memdesc:a13b44bfb69b63d39d2a966b416736716"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hash functor. <br /></td></tr>
<tr class="separator:a13b44bfb69b63d39d2a966b416736716"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a104ff1225ca65268f90dd235698e6f36"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a104ff1225ca65268f90dd235698e6f36"></a>
<a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#af672d590a91e09833aa27621f7e35c26">mutex_policy</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#a104ff1225ca65268f90dd235698e6f36">m_MutexPolicy</a></td></tr>
<tr class="memdesc:a104ff1225ca65268f90dd235698e6f36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mutex policy. <br /></td></tr>
<tr class="separator:a104ff1225ca65268f90dd235698e6f36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6a40adaba75040b3646fab1ad4bc133"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab6a40adaba75040b3646fab1ad4bc133"></a>
<a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#a73e9218d8f7724ddc07c1b41c8d91e7f">resizing_policy</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#ab6a40adaba75040b3646fab1ad4bc133">m_ResizingPolicy</a></td></tr>
<tr class="memdesc:ab6a40adaba75040b3646fab1ad4bc133"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resizing policy. <br /></td></tr>
<tr class="separator:ab6a40adaba75040b3646fab1ad4bc133"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-static-attribs"></a>
Static Protected Attributes</h2></td></tr>
<tr class="memitem:acd3aab8a3065331de1f6ad410fa94d7f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acd3aab8a3065331de1f6ad410fa94d7f"></a>
static const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#acd3aab8a3065331de1f6ad410fa94d7f">c_nMinimalCapacity</a> = 16</td></tr>
<tr class="memdesc:acd3aab8a3065331de1f6ad410fa94d7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimal capacity. <br /></td></tr>
<tr class="separator:acd3aab8a3065331de1f6ad410fa94d7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class Container, typename... Options&gt;<br />
class cds::intrusive::StripedSet&lt; Container, Options &gt;</h3>

<p>Striped hash set. </p>
<p>Source</p><ul>
<li>[2008] Maurice Herlihy, Nir Shavit "The Art of Multiprocessor Programming"</li>
</ul>
<p>Lock striping is very simple technique. The set consists of the bucket table and the array of locks. Initially, the capacity of lock array and bucket table is the same. When set is resized, bucket table capacity will be doubled but lock array will not. The lock <code>i</code> protects each bucket <code>j</code>, where <code> j = i mod L </code>, where <code>L</code> - the size of lock array.</p>
<p>Template arguments:</p><ul>
<li><code>Container</code> - the container class that is used as bucket table entry. The <code>Container</code> class should support an uniform interface described below.</li>
<li><code>Options</code> - options</li>
</ul>
<p>The <code>StripedSet</code> class does not exactly dictate the type of container that should be used as a <code>Container</code> bucket. Instead, the class supports different intrusive container type for the bucket, for exampe, <code>boost::intrusive::list</code>, <code>boost::intrusive::set</code> and others.</p>
<p>Remember that <code>StripedSet</code> class algorithm ensures sequential blocking access to its bucket through the mutex type you specify among <code>Options</code> template arguments.</p>
<p>The <code>Options</code> are:</p><ul>
<li><code><a class="el" href="structcds_1_1opt_1_1mutex__policy.html" title="[type-option] Concurrent access policy ">opt::mutex_policy</a></code> - concurrent access policy. Available policies: <code><a class="el" href="classcds_1_1intrusive_1_1striped__set_1_1striping.html" title="Lock striping concurrent access policy. ">striped_set::striping</a></code>, <code><a class="el" href="classcds_1_1intrusive_1_1striped__set_1_1refinable.html" title="Refinable concurrent access policy. ">striped_set::refinable</a></code>. Default is <code>striped_set::striping</code>.</li>
<li><code><a class="el" href="structcds_1_1opt_1_1hash.html" title="[type-option] Option setter for a hash function ">cds::opt::hash</a></code> - hash functor. Default option value see <code>opt::v::hash_selector &lt;<a class="el" href="structcds_1_1opt_1_1none.html" title="Type indicates that an option is not specified and the default one should be used. ">opt::none</a>&gt;</code> which selects default hash functor for your compiler.</li>
<li><code><a class="el" href="structcds_1_1opt_1_1compare.html" title="[type-option] Option setter for key comparing ">cds::opt::compare</a></code> - key comparison functor. No default functor is provided. If the option is not specified, the <code><a class="el" href="structcds_1_1opt_1_1less.html" title="[type-option] Option setter for less predicate ">opt::less</a></code> is used.</li>
<li><code><a class="el" href="structcds_1_1opt_1_1less.html" title="[type-option] Option setter for less predicate ">cds::opt::less</a></code> - specifies binary predicate used for key comparison. Default is <code>std::less&lt;T&gt;</code>.</li>
<li><code><a class="el" href="structcds_1_1opt_1_1item__counter.html" title="[type-option] Option setter for item counting ">cds::opt::item_counter</a></code> - item counter type. Default is <code><a class="el" href="classcds_1_1atomicity_1_1item__counter.html" title="Atomic item counter. ">atomicity::item_counter</a></code> since some operation on the counter is performed without locks. Note that item counting is an essential part of the set algorithm, so dummy counter like <code><a class="el" href="classcds_1_1atomicity_1_1empty__item__counter.html" title="Empty item counter. ">atomicity::empty_item_counter</a></code> is not suitable.</li>
<li><code><a class="el" href="structcds_1_1opt_1_1allocator.html" title="[type-option] Option setter for an allocator ">cds::opt::allocator</a></code> - the allocator type using for memory allocation of bucket table and lock array. Default is <a class="el" href="user__setup_2allocator_8h.html#ad5fb7e3cbe8cf24295f0ea3c165a2d82">CDS_DEFAULT_ALLOCATOR</a>.</li>
<li><code><a class="el" href="structcds_1_1opt_1_1resizing__policy.html" title="Resizing policy option. ">cds::opt::resizing_policy</a></code> - the resizing policy - a functor that decides when to resize the hash set. Default option value depends on bucket container type: for sequential containers like <code>boost::intrusive::list</code> the resizing policy is <code><a class="el" href="namespacecds_1_1container_1_1striped__set.html#a0a7761cda5122caa1ea5f22ac7182e65" title="Load factor based resizing policy. ">cds::container::striped_set::load_factor_resizing&lt;4&gt;</a> </code>; for other type of containers like <code>boost::intrusive::set</code> the resizing policy is <a class="el" href="namespacecds_1_1container_1_1striped__set.html#a1a6926eacdbf9fb4fc264d6d85d353c2" title="Dummy resizing policy. ">cds::container::striped_set::no_resizing</a>. See <a class="el" href="group__cds__striped__resizing__policy.html">available resizing policy</a>. Note that the choose of resizing policy depends of <code>Container</code> type: for sequential containers like <code>boost::intrusive::list</code> the right policy can significantly improve performance. For other, non-sequential types of <code>Container</code> (like a <code>boost::intrusive::set</code>) the resizing policy is not so important.</li>
<li><p class="startli"><code><a class="el" href="structcds_1_1opt_1_1buffer.html" title="[type-option] Option setter for user-provided plain buffer ">cds::opt::buffer</a></code> - a buffer type used only for <code>boost::intrusive::unordered_set</code>. Default is <code>cds::opt::v::static_buffer&lt; cds::any_type, 256 &gt; </code>.</p>
<p class="startli"><code><a class="el" href="structcds_1_1opt_1_1compare.html" title="[type-option] Option setter for key comparing ">opt::compare</a></code> or <code><a class="el" href="structcds_1_1opt_1_1less.html" title="[type-option] Option setter for less predicate ">opt::less</a></code> options are used in some <code>Container</code> class for ordering. <code>opt::compare</code> option has the highest priority: if <code>opt::compare</code> is specified, <code>opt::less</code> is not used.</p>
<p class="startli">You can pass other option that would be passed to <code>adapt</code> metafunction, see below.</p>
</li>
</ul>
<p><b>Internal details</b></p>
<p>The <code>StripedSet</code> class cannot utilize the <code>Container</code> specified directly, but only its adapted variant which supports an unified interface. Internally, the adaptation is made via <code><a class="el" href="classcds_1_1intrusive_1_1striped__set_1_1adapt.html" title="Default adapter for intrusive striped/refinable hash set. ">intrusive::striped_set::adapt</a></code> metafunction that wraps bucket container and provides the unified bucket interface suitable for <code>StripedSet</code>. Such adaptation is completely transparent for you - you don't need to call <code>adapt</code> metafunction directly, <code>StripedSet</code> class's internal machinery itself invokes appropriate <code>adapt</code> metafunction specialization to adjust your <code>Container</code> container class to <code>StripedSet</code> bucket's internal interface. All you need is to include a right header before <code>striped_set.h</code>.</p>
<p>By default, <code>intrusive::striped_set::adapt&lt;AnyContainer, OptionPack&gt; </code> metafunction does not make any wrapping to <code>AnyContainer</code>, so, the result <code><a class="el" href="classcds_1_1intrusive_1_1striped__set_1_1adapt.html#a30978a526c21debf20879b4e0e552759" title="adapted container type ">intrusive::striped_set::adapt&lt;AnyContainer, OptionPack&gt;::type</a> </code> is the same as <code>AnyContainer</code>. However, there are a lot of specializations of <code>intrusive::striped_set::adapt</code> for <code>boost::intrusive</code> containers, see table below. Any of this specialization wraps corresponding container making it suitable for the set's bucket. Remember, you should include the proper header file for <code>adapt</code> <b>before</b> including <code>striped_set.h</code>.</p>
<dl class="section note"><dt>Note</dt><dd>It is important to specify <code>boost::intrusive::constant_time_size&lt;true&gt;</code> option for all <code>boost::intrusive</code> container that supports this option. Fast item counting feature is essential part of <code>StripedSet</code> resizing algorithm.</dd></dl>
<table class="doxtable">
<tr>
<th>Container </th><th>.h-file for <code>adapt</code>  </th><th>Example </th><th>Notes  </th></tr>
<tr>
<td><code>boost::intrusive::list</code>  </td><td><code>&lt;cds/intrusive/striped_set/boost_list.h&gt;</code> </td><td><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;cds/intrusive/striped_set/boost_list.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;cds/intrusive/striped_set.h&gt;</span></div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="classcds_1_1intrusive_1_1_striped_set.html">cds::intrusive::StripedSet</a>&lt;</div>
<div class="line">boost::intrusive::list&lt;T, boost::intrusive::constant_time_size&lt;true&gt; &gt;,</div>
<div class="line">    <a class="code" href="structcds_1_1opt_1_1less.html">cds::opt::less&lt; std::less&lt;T&gt;</a> &gt;</div>
<div class="line">&gt; striped_set;</div>
</div><!-- fragment -->  </td><td>The list is ordered. Template argument pack <code>Options</code> <b>must</b> contain <a class="el" href="structcds_1_1opt_1_1less.html" title="[type-option] Option setter for less predicate ">cds::opt::less</a> or <a class="el" href="structcds_1_1opt_1_1compare.html" title="[type-option] Option setter for key comparing ">cds::opt::compare</a> for type <code>T</code> stored in the list   </td></tr>
<tr>
<td><code>boost::intrusive::slist</code>  </td><td><code>&lt;cds/intrusive/striped_set/boost_slist.h&gt;</code> </td><td><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;cds/intrusive/striped_set/boost_slist.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;cds/intrusive/striped_set.h&gt;</span></div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="classcds_1_1intrusive_1_1_striped_set.html">cds::intrusive::StripedSet</a>&lt;</div>
<div class="line">    boost::intrusive::slist&lt;T, boost::intrusive::constant_time_size&lt;true&gt; &gt;,</div>
<div class="line">    <a class="code" href="structcds_1_1opt_1_1less.html">cds::opt::less&lt; std::less&lt;T&gt;</a> &gt;</div>
<div class="line">&gt; striped_set;</div>
</div><!-- fragment -->  </td><td>The list is ordered. Template argument pack <code>Options</code> <b>must</b> contain <code><a class="el" href="structcds_1_1opt_1_1less.html" title="[type-option] Option setter for less predicate ">cds::opt::less</a></code> or <code><a class="el" href="structcds_1_1opt_1_1compare.html" title="[type-option] Option setter for key comparing ">cds::opt::compare</a></code> for type <code>T</code> stored in the list   </td></tr>
<tr>
<td><code>boost::intrusive::set</code>  </td><td><code>&lt;cds/intrusive/striped_set/boost_set.h&gt;</code> </td><td><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;cds/intrusive/striped_set/boost_set.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;cds/intrusive/striped_set.h&gt;</span></div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="classcds_1_1intrusive_1_1_striped_set.html">cds::intrusive::StripedSet</a>&lt;</div>
<div class="line">    boost::intrusive::set&lt;T, boost::intrusive::constant_time_size&lt;true&gt; &gt;</div>
<div class="line">&gt; striped_set;</div>
</div><!-- fragment -->  </td><td>Note that <code>boost::intrusive::compare</code> option using in <code>boost::intrusive::set</code> should support <code>T</code> type stored in the set and any type <code>Q</code> that you can use in <code><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#a93f0b317f12dd1db7b57ac7f9c4c68b2" title="Deletes the item from the set. ">erase()</a></code> and <code><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#af54fb6ea73d499f07611f75973244685" title="Find the key val. ">find()</a></code> member functions.   </td></tr>
<tr>
<td><code>boost::intrusive::unordered_set</code>  </td><td><code>&lt;cds/intrusive/striped_set/boost_unordered_set.h&gt;</code> </td><td><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;cds/intrusive/striped_set/boost_unordered_set.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;cds/intrusive/striped_set.h&gt;</span></div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="classcds_1_1intrusive_1_1_striped_set.html">cds::intrusive::StripedSet</a>&lt;</div>
<div class="line">    boost::intrusive::unordered_set&lt;T</div>
<div class="line">        ,boost::intrusive::constant_time_size&lt;true&gt;</div>
<div class="line">        ,boost::intrusive::hash&lt; user_provided_hash_functor &gt;</div>
<div class="line">    &gt;</div>
<div class="line">&gt; striped_set;</div>
</div><!-- fragment -->  </td><td><p class="starttd">You should provide two different hash function <code>h1</code> and <code>h2</code> - one for <code>boost::intrusive::unordered_set</code> and other for <code>StripedSet</code>. For the best result, <code>h1</code> and <code>h2</code> must be orthogonal i.e. <code>h1(X) != h2(X)</code> for any value <code>X</code> </p>
<p class="endtd">The option <code><a class="el" href="structcds_1_1opt_1_1buffer.html" title="[type-option] Option setter for user-provided plain buffer ">opt::buffer</a></code> is used for <code>boost::intrusive::bucket_traits</code>. Default is <code> cds::opt::v::static_buffer&lt; cds::any_type, 256 &gt; </code>. The resizing policy should correlate with the buffer capacity. The default resizing policy is <code><a class="el" href="namespacecds_1_1container_1_1striped__set.html#a0a7761cda5122caa1ea5f22ac7182e65" title="Load factor based resizing policy. ">cds::container::striped_set::load_factor_resizing&lt;256&gt;</a> </code> what gives load factor 1 for default bucket buffer that is the best for <code>boost::intrusive::unordered_set</code>.   </p>
</td></tr>
<tr>
<td><code>boost::intrusive::avl_set</code>  </td><td><code>&lt;cds/intrusive/striped_set/boost_avl_set.h&gt;</code> </td><td><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;cds/intrusive/striped_set/boost_avl_set.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;cds/intrusive/striped_set.h&gt;</span></div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="classcds_1_1intrusive_1_1_striped_set.html">cds::intrusive::StripedSet</a>&lt;</div>
<div class="line">    boost::intrusive::avl_set&lt;T, boost::intrusive::constant_time_size&lt;true&gt; &gt;</div>
<div class="line">&gt; striped_set;</div>
</div><!-- fragment -->  </td><td>Note that <code>boost::intrusive::compare</code> option using in <code>boost::intrusive::avl_set</code> should support <code>T</code> type stored in the set and any type <code>Q</code> that you can use in <code><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#a93f0b317f12dd1db7b57ac7f9c4c68b2" title="Deletes the item from the set. ">erase()</a></code> and <code><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#af54fb6ea73d499f07611f75973244685" title="Find the key val. ">find()</a></code> member functions.   </td></tr>
<tr>
<td><code>boost::intrusive::sg_set</code>  </td><td><code>&lt;cds/intrusive/striped_set/boost_sg_set.h&gt;</code> </td><td><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;cds/intrusive/striped_set/boost_sg_set.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;cds/intrusive/striped_set.h&gt;</span></div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="classcds_1_1intrusive_1_1_striped_set.html">cds::intrusive::StripedSet</a>&lt;</div>
<div class="line">    boost::intrusive::sg_set&lt;T, boost::intrusive::constant_time_size&lt;true&gt; &gt;</div>
<div class="line">&gt; striped_set;</div>
</div><!-- fragment -->  </td><td>Note that <code>boost::intrusive::compare</code> option using in <code>boost::intrusive::sg_set</code> should support <code>T</code> type stored in the set and any type <code>Q</code> that you can use in <code><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#a93f0b317f12dd1db7b57ac7f9c4c68b2" title="Deletes the item from the set. ">erase()</a></code> and <code><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#af54fb6ea73d499f07611f75973244685" title="Find the key val. ">find()</a></code> member functions.   </td></tr>
<tr>
<td><code>boost::intrusive::splay_set</code>  </td><td><code>&lt;cds/intrusive/striped_set/boost_splay_set.h&gt;</code> </td><td><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;cds/intrusive/striped_set/boost_splay_set.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;cds/intrusive/striped_set.h&gt;</span></div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="classcds_1_1intrusive_1_1_striped_set.html">cds::intrusive::StripedSet</a>&lt;</div>
<div class="line">    boost::intrusive::splay_set&lt;T, boost::intrusive::constant_time_size&lt;true&gt; &gt;</div>
<div class="line">&gt; striped_set;</div>
</div><!-- fragment -->  </td><td>Note that <code>boost::intrusive::compare</code> option using in <code>boost::intrusive::splay_set</code> should support <code>T</code> type stored in the set and any type <code>Q</code> that you can use in <code><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#a93f0b317f12dd1db7b57ac7f9c4c68b2" title="Deletes the item from the set. ">erase()</a></code> and <code><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#af54fb6ea73d499f07611f75973244685" title="Find the key val. ">find()</a></code> member functions.   </td></tr>
<tr>
<td><code>boost::intrusive::treap_set</code>  </td><td><code>&lt;cds/intrusive/striped_set/boost_treap_set.h&gt;</code> </td><td><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;cds/intrusive/striped_set/boost_treap_set.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;cds/intrusive/striped_set.h&gt;</span></div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="classcds_1_1intrusive_1_1_striped_set.html">cds::intrusive::StripedSet</a>&lt;</div>
<div class="line">    boost::intrusive::treap_set&lt;T, boost::intrusive::constant_time_size&lt;true&gt; &gt;</div>
<div class="line">&gt; striped_set;</div>
</div><!-- fragment -->  </td><td>Note that <code>boost::intrusive::compare</code> option using in <code>boost::intrusive::treap_set</code> should support <code>T</code> type stored in the set and any type <code>Q</code> that you can use in <code><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#a93f0b317f12dd1db7b57ac7f9c4c68b2" title="Deletes the item from the set. ">erase()</a></code> and <code><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#af54fb6ea73d499f07611f75973244685" title="Find the key val. ">find()</a></code> member functions.   </td></tr>
</table>
<p>You can use another intrusive container type as striped set's bucket. Suppose, you have a container class <code>MyBestContainer</code> and you want to integrate it with <code><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html" title="Striped hash set. ">StripedSet</a></code> as bucket type. There are two possibility:</p><ul>
<li>either your <code>MyBestContainer</code> class has native support of bucket's interface; in this case, you can use default <code><a class="el" href="classcds_1_1intrusive_1_1striped__set_1_1adapt.html" title="Default adapter for intrusive striped/refinable hash set. ">intrusive::striped_set::adapt</a></code> metafunction;</li>
<li>or your <code>MyBestContainer</code> class does not support bucket's interface, which means, that you should create a specialization of <code>cds::intrusive::striped_set::adapt&lt;MyBestContainer&gt; </code> metafunction providing necessary interface.</li>
</ul>
<p>The <code>intrusive::striped_set::adapt&lt; Container, OptionPack &gt;</code> metafunction has two template argument:</p><ul>
<li><code>Container</code> is the class that should be used as the bucket, for example, <code>boost::intrusive::list&lt; T &gt;</code>.</li>
<li><code>OptionPack</code> is the packed options from <code>StripedSet</code> declaration. The <code>adapt</code> metafunction can use any option from <code>OptionPack</code> for its internal use. For example, a <code>compare</code> option can be passed to <code>adapt</code> metafunction via <code>OptionPack</code> argument of <code>StripedSet</code> declaration.</li>
</ul>
<p>See <code><a class="el" href="classcds_1_1intrusive_1_1striped__set_1_1adapt.html" title="Default adapter for intrusive striped/refinable hash set. ">intrusive::striped_set::adapt</a></code> metafunction for the description of interface that the bucket container must provide to be <code>StripedSet</code> compatible. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a1a8ca33aa2ce383440759a0cf0a177e1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container, typename... Options&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html">cds::intrusive::StripedSet</a>&lt; Container, Options &gt;::<a class="el" href="classcds_1_1intrusive_1_1_striped_set.html">StripedSet</a> </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nCapacity</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Ctor with initial capacity specified. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nCapacity</td><td>Initial size of bucket table and lock array. Must be power of two, the minimum is 16. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab742138d7bfcfb5ad100bff319baac1a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container, typename... Options&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html">cds::intrusive::StripedSet</a>&lt; Container, Options &gt;::<a class="el" href="classcds_1_1intrusive_1_1_striped_set.html">StripedSet</a> </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nCapacity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#a73e9218d8f7724ddc07c1b41c8d91e7f">resizing_policy</a> const &amp;&#160;</td>
          <td class="paramname"><em>resizingPolicy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Ctor with resizing policy (copy semantics) </p>
<p>This constructor initializes m_ResizingPolicy member with copy of <code>resizingPolicy</code> parameter </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nCapacity</td><td>Initial size of bucket table and lock array. Must be power of two, the minimum is 16. </td></tr>
    <tr><td class="paramname">resizingPolicy</td><td>Resizing policy </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9f6cceace08ecb8ccae4c1c0c7841f88"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container, typename... Options&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html">cds::intrusive::StripedSet</a>&lt; Container, Options &gt;::<a class="el" href="classcds_1_1intrusive_1_1_striped_set.html">StripedSet</a> </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nCapacity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#a73e9218d8f7724ddc07c1b41c8d91e7f">resizing_policy</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>resizingPolicy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Ctor with resizing policy (move semantics) </p>
<p>This constructor initializes m_ResizingPolicy member moving <code>resizingPolicy</code> parameter Move semantics is used. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nCapacity</td><td>Initial size of bucket table and lock array. Must be power of two, the minimum is 16. </td></tr>
    <tr><td class="paramname">resizingPolicy</td><td>Resizing policy </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a3eb93bedca5734685f3564c15b8d5a57"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container, typename... Options&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classcds_1_1intrusive_1_1_striped_set.html">cds::intrusive::StripedSet</a>&lt; Container, Options &gt;::bucket_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the size of hash table. </p>
<p>The hash table size is non-constant and can be increased via resizing. </p>

</div>
</div>
<a class="anchor" id="a8c5b7ec995eb6c9ab0de511b4848c356"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container, typename... Options&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcds_1_1intrusive_1_1_striped_set.html">cds::intrusive::StripedSet</a>&lt; Container, Options &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clears the set. </p>
<p>The function unlinks all items from the set. </p>

</div>
</div>
<a class="anchor" id="a922615dc212b034f6946253747c92567"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container, typename... Options&gt; </div>
<div class="memtemplate">
template&lt;typename Disposer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcds_1_1intrusive_1_1_striped_set.html">cds::intrusive::StripedSet</a>&lt; Container, Options &gt;::clear_and_dispose </td>
          <td>(</td>
          <td class="paramtype">Disposer&#160;</td>
          <td class="paramname"><em>disposer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clears the set and calls <code>disposer</code> for each item. </p>
<p>The function unlinks all items from the set calling <code>disposer</code> for each item. <code>Disposer</code> functor interface is: </p><div class="fragment"><div class="line"><span class="keyword">struct </span>Disposer{</div>
<div class="line">    <span class="keywordtype">void</span> operator()( <a class="code" href="classcds_1_1intrusive_1_1_striped_set.html#a999c16c7efc7a140c386cf8089d43f7b">value_type</a> * p );</div>
<div class="line">};</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a5e681eacb6163d341cacf39607e1471c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container, typename... Options&gt; </div>
<div class="memtemplate">
template&lt;typename Q &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1intrusive_1_1_striped_set.html">cds::intrusive::StripedSet</a>&lt; Container, Options &gt;::contains </td>
          <td>(</td>
          <td class="paramtype">Q const &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether the set contains <code>key</code>. </p>
<p>The function searches the item with key equal to <code>key</code> and returns <code>true</code> if it is found, and <code>false</code> otherwise.</p>
<p>Note the hash functor specified for class <code>Traits</code> template parameter should accept a parameter of type <code>Q</code> that can be not the same as <code>value_type</code>. Otherwise, you may use <code><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#aeec51f0495dce5375e33dbdad5129488" title="Checks whether the set contains key using pred predicate for searching. ">contains( Q const&amp;, Less pred )</a></code> functions with explicit predicate for key comparing. </p>

</div>
</div>
<a class="anchor" id="aeec51f0495dce5375e33dbdad5129488"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container, typename... Options&gt; </div>
<div class="memtemplate">
template&lt;typename Q , typename Less &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1intrusive_1_1_striped_set.html">cds::intrusive::StripedSet</a>&lt; Container, Options &gt;::contains </td>
          <td>(</td>
          <td class="paramtype">Q const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Less&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether the set contains <code>key</code> using <code>pred</code> predicate for searching. </p>
<p>The function is an analog of <code>contains( key )</code> but <code>pred</code> is used for key comparing. <code>Less</code> functor has the interface like <code>std::less</code>. <code>Less</code> must imply the same element order as the comparator used for building the set. </p>

</div>
</div>
<a class="anchor" id="abb5f9adf6fbe7822d3e00454b0ed44af"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container, typename... Options&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1intrusive_1_1_striped_set.html">cds::intrusive::StripedSet</a>&lt; Container, Options &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the set is empty. </p>
<p>Emptiness is checked by item counting: if item count is zero then the set is empty. </p>

</div>
</div>
<a class="anchor" id="a93f0b317f12dd1db7b57ac7f9c4c68b2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container, typename... Options&gt; </div>
<div class="memtemplate">
template&lt;typename Q &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#a999c16c7efc7a140c386cf8089d43f7b">value_type</a>* <a class="el" href="classcds_1_1intrusive_1_1_striped_set.html">cds::intrusive::StripedSet</a>&lt; Container, Options &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">Q const &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deletes the item from the set. </p>
<p><a class="anchor" id="cds_intrusive_StripedSet_erase"></a>The function searches an item with key equal to <code>val</code> in the set, unlinks it from the set, and returns a pointer to unlinked item.</p>
<p>If the item with key equal to <code>val</code> is not found the function return <code>nullptr</code>.</p>
<p>Note the hash functor should accept a parameter of type <code>Q</code> that can be not the same as <code>value_type</code>. </p>

</div>
</div>
<a class="anchor" id="a4d0800c569994d8548264435b032b1e6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container, typename... Options&gt; </div>
<div class="memtemplate">
template&lt;typename Q , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#a999c16c7efc7a140c386cf8089d43f7b">value_type</a>* <a class="el" href="classcds_1_1intrusive_1_1_striped_set.html">cds::intrusive::StripedSet</a>&lt; Container, Options &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">Q const &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deletes the item from the set. </p>
<p><a class="anchor" id="cds_intrusive_StripedSet_erase_func"></a> The function searches an item with key equal to <code>val</code> in the set, call <code>f</code> functor with item found, unlinks it from the set, and returns a pointer to unlinked item.</p>
<p>The <code>Func</code> interface is </p><div class="fragment"><div class="line"><span class="keyword">struct </span>functor {</div>
<div class="line">    <span class="keywordtype">void</span> operator()( <a class="code" href="classcds_1_1intrusive_1_1_striped_set.html#a999c16c7efc7a140c386cf8089d43f7b">value_type</a> <span class="keyword">const</span>&amp; item );</div>
<div class="line">};</div>
</div><!-- fragment --><p>If the item with key equal to <code>val</code> is not found the function return <code>false</code>.</p>
<p>Note the hash functor should accept a parameter of type <code>Q</code> that can be not the same as <code>value_type</code>. </p>

</div>
</div>
<a class="anchor" id="a2f556ecd285484def76ab232f515e2af"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container, typename... Options&gt; </div>
<div class="memtemplate">
template&lt;typename Q , typename Less &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#a999c16c7efc7a140c386cf8089d43f7b">value_type</a>* <a class="el" href="classcds_1_1intrusive_1_1_striped_set.html">cds::intrusive::StripedSet</a>&lt; Container, Options &gt;::erase_with </td>
          <td>(</td>
          <td class="paramtype">Q const &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Less&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deletes the item from the set using <code>pred</code> predicate for searching. </p>
<p>The function is an analog of <a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#cds_intrusive_StripedSet_erase">erase(Q const&amp;)</a> but <code>pred</code> is used for key comparing <code>Less</code> has the interface like <code>std::less</code>. <code>pred</code> must imply the same element order as the comparator used for building the set. </p>

</div>
</div>
<a class="anchor" id="ae449671e2a1b7bfda93312d17b2a85cd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container, typename... Options&gt; </div>
<div class="memtemplate">
template&lt;typename Q , typename Less , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#a999c16c7efc7a140c386cf8089d43f7b">value_type</a>* <a class="el" href="classcds_1_1intrusive_1_1_striped_set.html">cds::intrusive::StripedSet</a>&lt; Container, Options &gt;::erase_with </td>
          <td>(</td>
          <td class="paramtype">Q const &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Less&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deletes the item from the set using <code>pred</code> predicate for searching. </p>
<p>The function is an analog of <a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#cds_intrusive_StripedSet_erase_func">erase(Q const&amp;, Func)</a> but <code>pred</code> is used for key comparing <code>Less</code> has the interface like <code>std::less</code>. <code>pred</code> must imply the same element order as the comparator used for building the set. </p>

</div>
</div>
<a class="anchor" id="af54fb6ea73d499f07611f75973244685"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container, typename... Options&gt; </div>
<div class="memtemplate">
template&lt;typename Q , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1intrusive_1_1_striped_set.html">cds::intrusive::StripedSet</a>&lt; Container, Options &gt;::find </td>
          <td>(</td>
          <td class="paramtype">Q &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the key <code>val</code>. </p>
<p><a class="anchor" id="cds_intrusive_StripedSet_find_func"></a>The function searches the item with key equal to <code>val</code> and calls the functor <code>f</code> for item found. The interface of <code>Func</code> functor is: </p><div class="fragment"><div class="line"><span class="keyword">struct </span>functor {</div>
<div class="line">    <span class="keywordtype">void</span> operator()( <a class="code" href="classcds_1_1intrusive_1_1_striped_set.html#a999c16c7efc7a140c386cf8089d43f7b">value_type</a>&amp; item, Q&amp; val );</div>
<div class="line">};</div>
</div><!-- fragment --><p> where <code>item</code> is the item found, <code>val</code> is the <code>find</code> function argument.</p>
<p>The functor may change non-key fields of <code>item</code>.</p>
<p>The <code>val</code> argument is non-const since it can be used as <code>f</code> functor destination i.e., the functor may modify both arguments.</p>
<p>Note the hash functor specified for class <code>Traits</code> template parameter should accept a parameter of type <code>Q</code> that can be not the same as <code>value_type</code>.</p>
<p>The function returns <code>true</code> if <code>val</code> is found, <code>false</code> otherwise. </p>

</div>
</div>
<a class="anchor" id="a1d1c82507b338a1f5e835117652f48d2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container, typename... Options&gt; </div>
<div class="memtemplate">
template&lt;typename Q , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1intrusive_1_1_striped_set.html">cds::intrusive::StripedSet</a>&lt; Container, Options &gt;::find </td>
          <td>(</td>
          <td class="paramtype">Q const &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the key <code>val</code>. </p>
<p><a class="anchor" id="cds_intrusive_StripedSet_find_cfunc"></a>The function searches the item with key equal to <code>val</code> and calls the functor <code>f</code> for item found. The interface of <code>Func</code> functor is: </p><div class="fragment"><div class="line"><span class="keyword">struct </span>functor {</div>
<div class="line">    <span class="keywordtype">void</span> operator()( <a class="code" href="classcds_1_1intrusive_1_1_striped_set.html#a999c16c7efc7a140c386cf8089d43f7b">value_type</a>&amp; item, Q <span class="keyword">const</span>&amp; val );</div>
<div class="line">};</div>
</div><!-- fragment --><p> where <code>item</code> is the item found, <code>val</code> is the <code>find</code> function argument.</p>
<p>The functor may change non-key fields of <code>item</code>.</p>
<p>The <code>val</code> argument is non-const since it can be used as <code>f</code> functor destination i.e., the functor may modify both arguments.</p>
<p>The function returns <code>true</code> if <code>val</code> is found, <code>false</code> otherwise. </p>

</div>
</div>
<a class="anchor" id="af47d38de7746c0701b794c02d7cc79bd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container, typename... Options&gt; </div>
<div class="memtemplate">
template&lt;typename Q , typename Less , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1intrusive_1_1_striped_set.html">cds::intrusive::StripedSet</a>&lt; Container, Options &gt;::find_with </td>
          <td>(</td>
          <td class="paramtype">Q &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Less&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the key <code>val</code> using <code>pred</code> predicate. </p>
<p>The function is an analog of <a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#cds_intrusive_StripedSet_find_func">find(Q&amp;, Func)</a> but <code>pred</code> is used for key comparing <code>Less</code> has the interface like <code>std::less</code>. <code>pred</code> must imply the same element order as the comparator used for building the set. </p>

</div>
</div>
<a class="anchor" id="a4947957c41d99bd6d75ce5b04a975bf5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container, typename... Options&gt; </div>
<div class="memtemplate">
template&lt;typename Q , typename Less , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1intrusive_1_1_striped_set.html">cds::intrusive::StripedSet</a>&lt; Container, Options &gt;::find_with </td>
          <td>(</td>
          <td class="paramtype">Q const &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Less&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the key <code>val</code> using <code>pred</code> predicate. </p>
<p>The function is an analog of <a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#cds_intrusive_StripedSet_find_cfunc">find(Q const&amp;, Func)</a> but <code>pred</code> is used for key comparing <code>Less</code> has the interface like <code>std::less</code>. <code>pred</code> must imply the same element order as the comparator used for building the set. </p>

</div>
</div>
<a class="anchor" id="a9596e3aea5464a77437d6d8cdfc288f5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container, typename... Options&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1intrusive_1_1_striped_set.html">cds::intrusive::StripedSet</a>&lt; Container, Options &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#a999c16c7efc7a140c386cf8089d43f7b">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts new node. </p>
<p>The function inserts <code>val</code> in the set if it does not contain an item with key equal to <code>val</code>.</p>
<p>Returns <code>true</code> if <code>val</code> is placed into the set, <code>false</code> otherwise. </p>

</div>
</div>
<a class="anchor" id="a4e8e96d52afa3d2c265c269af1a1ba3c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container, typename... Options&gt; </div>
<div class="memtemplate">
template&lt;typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1intrusive_1_1_striped_set.html">cds::intrusive::StripedSet</a>&lt; Container, Options &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#a999c16c7efc7a140c386cf8089d43f7b">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts new node. </p>
<p>The function allows to split creating of new item into two part:</p><ul>
<li>create item with key only</li>
<li>insert new item into the set</li>
<li>if inserting is success, calls <code>f</code> functor to initialize value-field of <code>val</code>.</li>
</ul>
<p>The functor signature is: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> func( <a class="code" href="classcds_1_1intrusive_1_1_striped_set.html#a999c16c7efc7a140c386cf8089d43f7b">value_type</a>&amp; val );</div>
</div><!-- fragment --><p> where <code>val</code> is the item inserted. </p>

</div>
</div>
<a class="anchor" id="adbc4dd64160d03646b1f7c163f95369e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container, typename... Options&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1intrusive_1_1_striped_set.html">cds::intrusive::StripedSet</a>&lt; Container, Options &gt;::unlink </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#a999c16c7efc7a140c386cf8089d43f7b">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unlink the item <code>val</code> from the set. </p>
<p>The function searches the item <code>val</code> in the set and unlink it if it is found and is equal to <code>val</code> (here, the equality means that <code>val</code> belongs to the set: if <code>item</code> is an item found then unlink is successful iif <code>&amp;val == &amp;item</code>)</p>
<p>The function returns <code>true</code> if success and <code>false</code> otherwise. </p>

</div>
</div>
<a class="anchor" id="a432eb9fc2f0cf92fcf3a3b22ef6d8510"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container, typename... Options&gt; </div>
<div class="memtemplate">
template&lt;typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;bool, bool&gt; <a class="el" href="classcds_1_1intrusive_1_1_striped_set.html">cds::intrusive::StripedSet</a>&lt; Container, Options &gt;::update </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#a999c16c7efc7a140c386cf8089d43f7b">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bAllowInsert</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Updates the node. </p>
<p>The operation performs inserting or changing data with lock-free manner.</p>
<p>If the item <code>val</code> is not found in the set, then <code>val</code> is inserted iff <code>bAllowInsert</code> is <code>true</code>. Otherwise, the functor <code>func</code> is called with item found. The functor signature is: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> func( <span class="keywordtype">bool</span> bNew, <a class="code" href="classcds_1_1intrusive_1_1_striped_set.html#a999c16c7efc7a140c386cf8089d43f7b">value_type</a>&amp; item, <a class="code" href="classcds_1_1intrusive_1_1_striped_set.html#a999c16c7efc7a140c386cf8089d43f7b">value_type</a>&amp; val );</div>
</div><!-- fragment --><p> with arguments:</p><ul>
<li><code>bNew</code> - <code>true</code> if the item has been inserted, <code>false</code> otherwise</li>
<li><code>item</code> - item of the set</li>
<li><code>val</code> - argument <code>val</code> passed into the <code><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#a432eb9fc2f0cf92fcf3a3b22ef6d8510" title="Updates the node. ">update()</a></code> function If new item has been inserted (i.e. <code>bNew</code> is <code>true</code>) then <code>item</code> and <code>val</code> arguments refers to the same thing.</li>
</ul>
<p>The functor may change non-key fields of the <code>item</code>.</p>
<p>Returns std::pair&lt;bool, bool&gt; where <code>first</code> is <code>true</code> if operation is successfull, <code>second</code> is <code>true</code> if new item has been added or <code>false</code> if the item with <code>val</code> already is in the set. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>cds/intrusive/striped_set.h</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<hr/>
<div align="right">
  <b>cds</b> <b>2.1.0</b> 
  Developed by <i>Maxim Khizhinsky aka khizmax</i> 2007 - 2015
  <br/>
  <i>Autogenerated Wed Jan 6 2016 16:00:45 by Doxygen 1.8.10</i>
</div>
</body>
</html>
