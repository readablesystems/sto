<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>cds: cds::intrusive::TreiberStack&lt; GC, T, Traits &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">cds
   &#160;<span id="projectnumber">2.1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="classes.html"><span>Data&#160;Structure&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Data&#160;Fields</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classcds_1_1intrusive_1_1_treiber_stack.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-attribs">Protected Attributes</a>  </div>
  <div class="headertitle">
<div class="title">cds::intrusive::TreiberStack&lt; GC, T, Traits &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__cds__intrusive__containers.html">Intrusive containers</a> &raquo; <a class="el" href="group__cds__intrusive__stack.html">Stack</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Treiber intrusive stack.  
 <a href="classcds_1_1intrusive_1_1_treiber_stack.html#details">More...</a></p>

<p><code>#include &lt;cds/intrusive/treiber_stack.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcds_1_1intrusive_1_1_treiber_stack_1_1rebind.html">rebind</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rebind template arguments.  <a href="structcds_1_1intrusive_1_1_treiber_stack_1_1rebind.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a531fe25cb5ed51c621c7b63e43f4a3d7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a531fe25cb5ed51c621c7b63e43f4a3d7"></a>
typedef GC&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_treiber_stack.html#a531fe25cb5ed51c621c7b63e43f4a3d7">gc</a></td></tr>
<tr class="memdesc:a531fe25cb5ed51c621c7b63e43f4a3d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Garbage collector. <br /></td></tr>
<tr class="separator:a531fe25cb5ed51c621c7b63e43f4a3d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee1bd2833bdf4dc85f54d64901d265ae"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aee1bd2833bdf4dc85f54d64901d265ae"></a>
typedef T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_treiber_stack.html#aee1bd2833bdf4dc85f54d64901d265ae">value_type</a></td></tr>
<tr class="memdesc:aee1bd2833bdf4dc85f54d64901d265ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">type of value stored in the stack <br /></td></tr>
<tr class="separator:aee1bd2833bdf4dc85f54d64901d265ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a917ba9ff1f9ed5b9cb8cf6001a768d7f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a917ba9ff1f9ed5b9cb8cf6001a768d7f"></a>
typedef Traits&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_treiber_stack.html#a917ba9ff1f9ed5b9cb8cf6001a768d7f">traits</a></td></tr>
<tr class="memdesc:a917ba9ff1f9ed5b9cb8cf6001a768d7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stack traits. <br /></td></tr>
<tr class="separator:a917ba9ff1f9ed5b9cb8cf6001a768d7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac84abbfc3a7ebdeaed4f7d73a83348fe"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac84abbfc3a7ebdeaed4f7d73a83348fe"></a>
typedef traits::hook&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_treiber_stack.html#ac84abbfc3a7ebdeaed4f7d73a83348fe">hook</a></td></tr>
<tr class="memdesc:ac84abbfc3a7ebdeaed4f7d73a83348fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">hook type <br /></td></tr>
<tr class="separator:ac84abbfc3a7ebdeaed4f7d73a83348fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77ee8331576531e9756f952d7c5a905e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a77ee8331576531e9756f952d7c5a905e"></a>
typedef hook::node_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_treiber_stack.html#a77ee8331576531e9756f952d7c5a905e">node_type</a></td></tr>
<tr class="memdesc:a77ee8331576531e9756f952d7c5a905e"><td class="mdescLeft">&#160;</td><td class="mdescRight">node type <br /></td></tr>
<tr class="separator:a77ee8331576531e9756f952d7c5a905e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9d7f1321553b7eb252ff1769266f317"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad9d7f1321553b7eb252ff1769266f317"></a>
typedef traits::disposer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_treiber_stack.html#ad9d7f1321553b7eb252ff1769266f317">disposer</a></td></tr>
<tr class="memdesc:ad9d7f1321553b7eb252ff1769266f317"><td class="mdescLeft">&#160;</td><td class="mdescRight">disposer used <br /></td></tr>
<tr class="separator:ad9d7f1321553b7eb252ff1769266f317"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c208918b78849e66fd1a0aa98c5214f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4c208918b78849e66fd1a0aa98c5214f"></a>
typedef <a class="el" href="structcds_1_1intrusive_1_1get__node__traits.html">get_node_traits</a>&lt; <a class="el" href="classcds_1_1intrusive_1_1_treiber_stack.html#aee1bd2833bdf4dc85f54d64901d265ae">value_type</a>, <a class="el" href="classcds_1_1intrusive_1_1_treiber_stack.html#a77ee8331576531e9756f952d7c5a905e">node_type</a>, <a class="el" href="classcds_1_1intrusive_1_1_treiber_stack.html#ac84abbfc3a7ebdeaed4f7d73a83348fe">hook</a> &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_treiber_stack.html#a4c208918b78849e66fd1a0aa98c5214f">node_traits</a></td></tr>
<tr class="memdesc:a4c208918b78849e66fd1a0aa98c5214f"><td class="mdescLeft">&#160;</td><td class="mdescRight">node traits <br /></td></tr>
<tr class="separator:a4c208918b78849e66fd1a0aa98c5214f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85089aa1d7225211eca83cb8dd32cb36"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a85089aa1d7225211eca83cb8dd32cb36"></a>
typedef <a class="el" href="structcds_1_1intrusive_1_1single__link_1_1get__link__checker.html">single_link::get_link_checker</a>&lt; <a class="el" href="classcds_1_1intrusive_1_1_treiber_stack.html#a77ee8331576531e9756f952d7c5a905e">node_type</a>, traits::link_checker &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_treiber_stack.html#a85089aa1d7225211eca83cb8dd32cb36">link_checker</a></td></tr>
<tr class="memdesc:a85089aa1d7225211eca83cb8dd32cb36"><td class="mdescLeft">&#160;</td><td class="mdescRight">link checker <br /></td></tr>
<tr class="separator:a85089aa1d7225211eca83cb8dd32cb36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e4f23df9404aaf7841c626a59c0f813"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7e4f23df9404aaf7841c626a59c0f813"></a>
typedef traits::memory_model&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_treiber_stack.html#a7e4f23df9404aaf7841c626a59c0f813">memory_model</a></td></tr>
<tr class="memdesc:a7e4f23df9404aaf7841c626a59c0f813"><td class="mdescLeft">&#160;</td><td class="mdescRight">Memory ordering. See <code><a class="el" href="structcds_1_1opt_1_1memory__model.html" title="[type-option] Option setter for C++ memory model ">cds::opt::memory_model</a></code> option. <br /></td></tr>
<tr class="separator:a7e4f23df9404aaf7841c626a59c0f813"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeda5439ce75482d3d219bc1d786570d7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aeda5439ce75482d3d219bc1d786570d7"></a>
typedef traits::item_counter&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_treiber_stack.html#aeda5439ce75482d3d219bc1d786570d7">item_counter</a></td></tr>
<tr class="memdesc:aeda5439ce75482d3d219bc1d786570d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Item counter class. <br /></td></tr>
<tr class="separator:aeda5439ce75482d3d219bc1d786570d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b7dcb3915fb65dca03eab0e8384cab1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9b7dcb3915fb65dca03eab0e8384cab1"></a>
typedef traits::stat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_treiber_stack.html#a9b7dcb3915fb65dca03eab0e8384cab1">stat</a></td></tr>
<tr class="memdesc:a9b7dcb3915fb65dca03eab0e8384cab1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal statistics. <br /></td></tr>
<tr class="separator:a9b7dcb3915fb65dca03eab0e8384cab1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa58beb40fd71bb9f6c0258dd750ea1c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaa58beb40fd71bb9f6c0258dd750ea1c"></a>
typedef traits::back_off&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_treiber_stack.html#aaa58beb40fd71bb9f6c0258dd750ea1c">back_off</a></td></tr>
<tr class="memdesc:aaa58beb40fd71bb9f6c0258dd750ea1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">back-off strategy <br /></td></tr>
<tr class="separator:aaa58beb40fd71bb9f6c0258dd750ea1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69ade015558560e53928e17efcc5522e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a69ade015558560e53928e17efcc5522e"></a>
typedef traits::elimination_backoff&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_treiber_stack.html#a69ade015558560e53928e17efcc5522e">elimination_backoff_type</a></td></tr>
<tr class="memdesc:a69ade015558560e53928e17efcc5522e"><td class="mdescLeft">&#160;</td><td class="mdescRight">back-off strategy used to wait for elimination <br /></td></tr>
<tr class="separator:a69ade015558560e53928e17efcc5522e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3452433cc559f0fa0993d1c901e381e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad3452433cc559f0fa0993d1c901e381e"></a>
typedef traits::lock_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_treiber_stack.html#ad3452433cc559f0fa0993d1c901e381e">elimination_lock_type</a></td></tr>
<tr class="memdesc:ad3452433cc559f0fa0993d1c901e381e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lock type used in elimination back-off. <br /></td></tr>
<tr class="separator:ad3452433cc559f0fa0993d1c901e381e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b070432d429445840dbb6027aaad99e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6b070432d429445840dbb6027aaad99e"></a>
typedef traits::random_engine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_treiber_stack.html#a6b070432d429445840dbb6027aaad99e">elimination_random_engine</a></td></tr>
<tr class="memdesc:a6b070432d429445840dbb6027aaad99e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Random engine used in elimination back-off. <br /></td></tr>
<tr class="separator:a6b070432d429445840dbb6027aaad99e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ae5c0bd3fac8df16e630ead43ec951bb8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae5c0bd3fac8df16e630ead43ec951bb8"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_treiber_stack.html#ae5c0bd3fac8df16e630ead43ec951bb8">TreiberStack</a> ()</td></tr>
<tr class="memdesc:ae5c0bd3fac8df16e630ead43ec951bb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs empty stack. <br /></td></tr>
<tr class="separator:ae5c0bd3fac8df16e630ead43ec951bb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8346c46c34eeebd748e27b8128b7877"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_treiber_stack.html#af8346c46c34eeebd748e27b8128b7877">TreiberStack</a> (size_t nCollisionCapacity)</td></tr>
<tr class="memdesc:af8346c46c34eeebd748e27b8128b7877"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs empty stack and initializes elimination back-off data.  <a href="#af8346c46c34eeebd748e27b8128b7877">More...</a><br /></td></tr>
<tr class="separator:af8346c46c34eeebd748e27b8128b7877"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0a01f938ae0db8f855ab0af05068a30"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa0a01f938ae0db8f855ab0af05068a30"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_treiber_stack.html#aa0a01f938ae0db8f855ab0af05068a30">TreiberStack</a> (<a class="el" href="classcds_1_1intrusive_1_1_treiber_stack.html">TreiberStack</a> const &amp;)=delete</td></tr>
<tr class="memdesc:aa0a01f938ae0db8f855ab0af05068a30"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>TreiberStack</code> is not copy-constructible <br /></td></tr>
<tr class="separator:aa0a01f938ae0db8f855ab0af05068a30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d961105780d533a0f78d6633aaccc92"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1d961105780d533a0f78d6633aaccc92"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_treiber_stack.html#a1d961105780d533a0f78d6633aaccc92">~TreiberStack</a> ()</td></tr>
<tr class="memdesc:a1d961105780d533a0f78d6633aaccc92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor calls <a class="el" href="classcds_1_1intrusive_1_1_treiber_stack.html#cds_intrusive_TreiberStack_clear">clear</a> member function. <br /></td></tr>
<tr class="separator:a1d961105780d533a0f78d6633aaccc92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8abbf13d54786fd1264bb749de767d13"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_treiber_stack.html#a8abbf13d54786fd1264bb749de767d13">push</a> (<a class="el" href="classcds_1_1intrusive_1_1_treiber_stack.html#aee1bd2833bdf4dc85f54d64901d265ae">value_type</a> &amp;val)</td></tr>
<tr class="memdesc:a8abbf13d54786fd1264bb749de767d13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Push the item <code>val</code> on the stack.  <a href="#a8abbf13d54786fd1264bb749de767d13">More...</a><br /></td></tr>
<tr class="separator:a8abbf13d54786fd1264bb749de767d13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae87f09d2df1ef1954a99b334575029ea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1intrusive_1_1_treiber_stack.html#aee1bd2833bdf4dc85f54d64901d265ae">value_type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_treiber_stack.html#ae87f09d2df1ef1954a99b334575029ea">pop</a> ()</td></tr>
<tr class="memdesc:ae87f09d2df1ef1954a99b334575029ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pop an item from the stack.  <a href="#ae87f09d2df1ef1954a99b334575029ea">More...</a><br /></td></tr>
<tr class="separator:ae87f09d2df1ef1954a99b334575029ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adacf358421348acf186672843deb4185"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adacf358421348acf186672843deb4185"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_treiber_stack.html#adacf358421348acf186672843deb4185">empty</a> () const </td></tr>
<tr class="memdesc:adacf358421348acf186672843deb4185"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if stack is empty. <br /></td></tr>
<tr class="separator:adacf358421348acf186672843deb4185"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34937a52801400187ecf9f611456047f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_treiber_stack.html#a34937a52801400187ecf9f611456047f">clear</a> ()</td></tr>
<tr class="memdesc:a34937a52801400187ecf9f611456047f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the stack.  <a href="#a34937a52801400187ecf9f611456047f">More...</a><br /></td></tr>
<tr class="separator:a34937a52801400187ecf9f611456047f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b7e86739b3125d56b2dfa7acfa9e395"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_treiber_stack.html#a2b7e86739b3125d56b2dfa7acfa9e395">size</a> () const </td></tr>
<tr class="memdesc:a2b7e86739b3125d56b2dfa7acfa9e395"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns stack's item count.  <a href="#a2b7e86739b3125d56b2dfa7acfa9e395">More...</a><br /></td></tr>
<tr class="separator:a2b7e86739b3125d56b2dfa7acfa9e395"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d1bf6fd15a076225f246e6c3fb454d9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4d1bf6fd15a076225f246e6c3fb454d9"></a>
<a class="el" href="classcds_1_1intrusive_1_1_treiber_stack.html#a9b7dcb3915fb65dca03eab0e8384cab1">stat</a> const &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_treiber_stack.html#a4d1bf6fd15a076225f246e6c3fb454d9">statistics</a> () const </td></tr>
<tr class="memdesc:a4d1bf6fd15a076225f246e6c3fb454d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns reference to internal statistics. <br /></td></tr>
<tr class="separator:a4d1bf6fd15a076225f246e6c3fb454d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:aa5afe150821effa3c159d5d566e2482e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa5afe150821effa3c159d5d566e2482e"></a>
static constexpr const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_treiber_stack.html#aa5afe150821effa3c159d5d566e2482e">enable_elimination</a> = traits::enable_elimination</td></tr>
<tr class="memdesc:aa5afe150821effa3c159d5d566e2482e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Elimination back-off is enabled or not. <br /></td></tr>
<tr class="separator:aa5afe150821effa3c159d5d566e2482e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:ae0347761f0161a3fbcf3535886ffb3c7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae0347761f0161a3fbcf3535886ffb3c7"></a>
node_type::atomic_node_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_treiber_stack.html#ae0347761f0161a3fbcf3535886ffb3c7">m_Top</a></td></tr>
<tr class="memdesc:ae0347761f0161a3fbcf3535886ffb3c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Top of the stack. <br /></td></tr>
<tr class="separator:ae0347761f0161a3fbcf3535886ffb3c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6af55483d14d92cb08ef31cb47d92ce9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6af55483d14d92cb08ef31cb47d92ce9"></a>
<a class="el" href="classcds_1_1intrusive_1_1_treiber_stack.html#aeda5439ce75482d3d219bc1d786570d7">item_counter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_treiber_stack.html#a6af55483d14d92cb08ef31cb47d92ce9">m_ItemCounter</a></td></tr>
<tr class="memdesc:a6af55483d14d92cb08ef31cb47d92ce9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Item counter. <br /></td></tr>
<tr class="separator:a6af55483d14d92cb08ef31cb47d92ce9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3951bd3d1c0381bb6ad16dc8c44ee774"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3951bd3d1c0381bb6ad16dc8c44ee774"></a>
<a class="el" href="classcds_1_1intrusive_1_1_treiber_stack.html#a9b7dcb3915fb65dca03eab0e8384cab1">stat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_treiber_stack.html#a3951bd3d1c0381bb6ad16dc8c44ee774">m_stat</a></td></tr>
<tr class="memdesc:a3951bd3d1c0381bb6ad16dc8c44ee774"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal statistics. <br /></td></tr>
<tr class="separator:a3951bd3d1c0381bb6ad16dc8c44ee774"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename GC, typename T, typename Traits = treiber_stack::traits&gt;<br />
class cds::intrusive::TreiberStack&lt; GC, T, Traits &gt;</h3>

<p>Treiber intrusive stack. </p>
<p>Intrusive implementation of well-known Treiber's stack algorithm:</p><ul>
<li>R. K. Treiber. Systems programming: Coping with parallelism. Technical Report RJ 5118, IBM Almaden Research Center, April 1986.</li>
</ul>
<p><a class="el" href="namespacecds_1_1algo_1_1elimination.html#cds_elimination_description">Elimination back-off technique</a> can be used optionally. The idea of elimination algorithm is taken from:</p><ul>
<li>[2004] Danny Hendler, Nir Shavit, Lena Yerushalmi "A Scalable Lock-free Stack Algorithm"</li>
</ul>
<p>The elimination algorithm uses a single elimination array as a back-off schema on a shared lock-free stack. If the threads fail on the stack, they attempt to eliminate on the array, and if they fail in eliminating, they attempt to access the stack again and so on.</p>
<dl class="section note"><dt>Note</dt><dd>Hendler's et al paper describes a lock-free implementation of elimination back-off which is quite complex. The main difficulty is the managing life-time of elimination record. Our implementation uses simplified lock-based (spin-based) approach which allows the elimination record allocation on thread's stack. This approach demonstrates sufficient performance under high load.</dd></dl>
<p>Template arguments:</p><ul>
<li><code>GC</code> - garbage collector type: <code><a class="el" href="classcds_1_1gc_1_1_h_p.html" title="Hazard Pointer garbage collector. ">gc::HP</a></code>, <code><a class="el" href="classcds_1_1gc_1_1_d_h_p.html" title="Dynamic Hazard Pointer garbage collector. ">gc::DHP</a></code>. Garbage collecting schema must be the same as <code><a class="el" href="namespacecds_1_1intrusive_1_1treiber__stack.html#a1014666e538dbf5fcd4da9c4c7139d61" title="Stack node. ">treiber_stack::node</a></code> GC.</li>
<li><code>T</code> - a type the stack contains. A value of type <code>T</code> must be derived from <code><a class="el" href="namespacecds_1_1intrusive_1_1treiber__stack.html#a1014666e538dbf5fcd4da9c4c7139d61" title="Stack node. ">treiber_stack::node</a></code> for <code><a class="el" href="namespacecds_1_1intrusive_1_1treiber__stack.html#aeaaa2231740910a2063eb389dee944da" title="Base hook. ">treiber_stack::base_hook</a></code>, or it should have a member of type <code>treiber_stack::node</code> for <code><a class="el" href="namespacecds_1_1intrusive_1_1treiber__stack.html#a390b5427eb7e4e2bbdd2c79854bbdb5f" title="Member hook. ">treiber_stack::member_hook</a></code>, or it should be convertible to <code>treiber_stack::node</code> for <code><a class="el" href="namespacecds_1_1intrusive_1_1treiber__stack.html#a3f2f5d8f411e7106ce42a5478ad7d049" title="Traits hook. ">treiber_stack::traits_hook</a></code>.</li>
<li><code>Traits</code> - stack traits, default is <code><a class="el" href="structcds_1_1intrusive_1_1treiber__stack_1_1traits.html" title="TreiberStack default type traits. ">treiber_stack::traits</a></code>. You can use <code><a class="el" href="structcds_1_1intrusive_1_1treiber__stack_1_1make__traits.html" title="Metafunction converting option list to treiber_stack::traits. ">treiber_stack::make_traits</a></code> metafunction to make your traits or just derive your traits from <code>treiber_stack::traits</code>: <div class="fragment"><div class="line"><span class="keyword">struct </span>myTraits: <span class="keyword">public</span> <a class="code" href="structcds_1_1intrusive_1_1treiber__stack_1_1traits.html">cds::intrusive::treiber_stack::traits</a> {</div>
<div class="line">    <span class="keyword">typedef</span> <a class="code" href="structcds_1_1intrusive_1_1treiber__stack_1_1stat.html">cds::intrusive::treiber_stack::stat&lt;&gt;</a> <a class="code" href="classcds_1_1intrusive_1_1_treiber_stack.html#a9b7dcb3915fb65dca03eab0e8384cab1">stat</a>;</div>
<div class="line">};</div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="classcds_1_1intrusive_1_1_treiber_stack.html">cds::intrusive::TreiberStack&lt; cds::gc::HP, Foo, myTraits &gt;</a> myStack;</div>
<div class="line"></div>
<div class="line"><span class="comment">// Equivalent make_traits example:</span></div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="classcds_1_1intrusive_1_1_treiber_stack.html">cds::intrusive::TreiberStack</a>&lt; cds::gc::HP, Foo,</div>
<div class="line">    <span class="keyword">typename</span> <a class="code" href="structcds_1_1intrusive_1_1treiber__stack_1_1make__traits.html">cds::intrusive::treiber_stack::make_traits</a>&lt;</div>
<div class="line">        <a class="code" href="structcds_1_1opt_1_1stat.html">cds::opt::stat&lt; cds::intrusive::treiber_stack::stat&lt;&gt;</a> &gt;</div>
<div class="line">    &gt;::type</div>
<div class="line">&gt; myStack;</div>
</div><!-- fragment --></li>
</ul>
<dl class="section note"><dt>Note</dt><dd>Be careful when you want destroy an item popped, see <a class="el" href="namespacecds_1_1intrusive.html#cds_intrusive_item_destroying">Destroying items of intrusive containers</a>.</dd></dl>
<p><a class="anchor" id="cds_intrusive_TreiberStack_examples"></a></p><dl class="section user"><dt>Examples</dt><dd></dd></dl>
<p>Example of how to use <code><a class="el" href="namespacecds_1_1intrusive_1_1treiber__stack.html#aeaaa2231740910a2063eb389dee944da" title="Base hook. ">treiber_stack::base_hook</a></code>. Your class that objects will be pushed on <code>TreiberStack</code> should be based on <code><a class="el" href="namespacecds_1_1intrusive_1_1treiber__stack.html#a1014666e538dbf5fcd4da9c4c7139d61" title="Stack node. ">treiber_stack::node</a></code> class </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;cds/intrusive/treiber_stack.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;cds/gc/hp.h&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">namespace </span>ci = <a class="code" href="namespacecds_1_1intrusive.html">cds::intrusive</a>;</div>
<div class="line"><span class="keyword">typedef</span> cds::gc::HP <a class="code" href="classcds_1_1intrusive_1_1_treiber_stack.html#a531fe25cb5ed51c621c7b63e43f4a3d7">gc</a>;</div>
<div class="line"></div>
<div class="line"><span class="keyword">struct </span>myData: <span class="keyword">public</span> ci::treiber_stack::node&lt; gc &gt;</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="comment">// Stack type</span></div>
<div class="line"><span class="keyword">typedef</span> ci::TreiberStack&lt; <a class="code" href="classcds_1_1intrusive_1_1_treiber_stack.html#a531fe25cb5ed51c621c7b63e43f4a3d7">gc</a>,</div>
<div class="line">    myData,</div>
<div class="line">    <span class="keyword">typename</span> <a class="code" href="structcds_1_1intrusive_1_1treiber__stack_1_1make__traits.html">cds::intrusive::treiber_stack::make_traits</a>&lt;</div>
<div class="line">        ci::opt::hook&lt; ci::treiber_stack::base_hook&lt; gc &gt; &gt;</div>
<div class="line">    &gt;::type</div>
<div class="line">&gt; stack_t;</div>
<div class="line"></div>
<div class="line"><span class="comment">// Stack with elimination back-off enabled</span></div>
<div class="line"><span class="keyword">typedef</span> ci::TreiberStack&lt; <a class="code" href="classcds_1_1intrusive_1_1_treiber_stack.html#a531fe25cb5ed51c621c7b63e43f4a3d7">gc</a>,</div>
<div class="line">    myData,</div>
<div class="line">    <span class="keyword">typename</span> ci::treiber_stack::make_traits&lt;</div>
<div class="line">        ci::opt::hook&lt; ci::treiber_stack::base_hook&lt; gc &gt; &gt;,</div>
<div class="line">        <a class="code" href="structcds_1_1opt_1_1enable__elimination.html">cds::opt::enable_elimination&lt; true &gt;</a></div>
<div class="line">    &gt;::type</div>
<div class="line">&gt; elimination_stack_t;</div>
</div><!-- fragment --><p>Example of how to use <code><a class="el" href="namespacecds_1_1intrusive_1_1treiber__stack.html#aeaaa2231740910a2063eb389dee944da" title="Base hook. ">treiber_stack::base_hook</a></code> with different tags. </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;cds/intrusive/treiber_stack.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;cds/gc/hp.h&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">namespace </span>ci = <a class="code" href="namespacecds_1_1intrusive.html">cds::intrusive</a>;</div>
<div class="line"><span class="keyword">typedef</span> cds::gc::HP <a class="code" href="classcds_1_1intrusive_1_1_treiber_stack.html#a531fe25cb5ed51c621c7b63e43f4a3d7">gc</a>;</div>
<div class="line"></div>
<div class="line"><span class="comment">// It is not necessary to declare complete type for tags</span></div>
<div class="line"><span class="keyword">struct </span>tag1;</div>
<div class="line"><span class="keyword">struct </span>tag2;</div>
<div class="line"></div>
<div class="line"><span class="keyword">struct </span>myData</div>
<div class="line">    : <span class="keyword">public</span> ci::treiber_stack::node&lt; gc, tag1 &gt;</div>
<div class="line">    , <span class="keyword">public</span> ci::treiber_stack::node&lt; gc, tag2 &gt;</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keyword">typedef</span> ci::TreiberStack&lt; <a class="code" href="classcds_1_1intrusive_1_1_treiber_stack.html#a531fe25cb5ed51c621c7b63e43f4a3d7">gc</a>,</div>
<div class="line">    myData,</div>
<div class="line">    <span class="keyword">typename</span> ci::treiber_stack::make_traits&lt;</div>
<div class="line">        ci::opt::hook&lt; ci::treiber_stack::base_hook&lt; gc, tag1 &gt; &gt;</div>
<div class="line">    &gt;::type</div>
<div class="line">&gt; stack1_t;</div>
<div class="line"></div>
<div class="line"><span class="keyword">typedef</span> ci::TreiberStack&lt; <a class="code" href="classcds_1_1intrusive_1_1_treiber_stack.html#a531fe25cb5ed51c621c7b63e43f4a3d7">gc</a>,</div>
<div class="line">    myData,</div>
<div class="line">    <span class="keyword">typename</span> ci::treiber_stack::make_traits&lt;</div>
<div class="line">        ci::opt::hook&lt; ci::treiber_stack::base_hook&lt; gc, tag2 &gt; &gt;</div>
<div class="line">    &gt;::type</div>
<div class="line">&gt; stack2_t;</div>
<div class="line"></div>
<div class="line"><span class="comment">// You may add myData objects into stack1_t and stack2_t independently</span></div>
<div class="line"><span class="keywordtype">void</span> foo() {</div>
<div class="line">    stack1_t    s1;</div>
<div class="line">    stack2_t    s2;</div>
<div class="line"></div>
<div class="line">    myData i1, i2;</div>
<div class="line">    s1.push( i1 );</div>
<div class="line">    s2.push( i2 );</div>
<div class="line">    s2.push( i1 )   ;   <span class="comment">// i1 is now contained in s1 and s2.</span></div>
<div class="line"></div>
<div class="line">    myData * p;</div>
<div class="line"></div>
<div class="line">    p = s1.pop()    ;   <span class="comment">// pop i1 from s1</span></div>
<div class="line">    p = s1.pop()    ;   <span class="comment">// p == nullptr, s1 is empty</span></div>
<div class="line">    p = s2.pop()    ;   <span class="comment">// pop i1 from s2</span></div>
<div class="line">    p = s2.pop()    ;   <span class="comment">// pop i2 from s2</span></div>
<div class="line">    p = s2.pop()    ;   <span class="comment">// p == nullptr, s2 is empty</span></div>
<div class="line">}</div>
</div><!-- fragment --><p>Example of how to use <code><a class="el" href="namespacecds_1_1intrusive_1_1treiber__stack.html#a390b5427eb7e4e2bbdd2c79854bbdb5f" title="Member hook. ">treiber_stack::member_hook</a></code>. Your class should have a member of type <code><a class="el" href="namespacecds_1_1intrusive_1_1treiber__stack.html#a1014666e538dbf5fcd4da9c4c7139d61" title="Stack node. ">treiber_stack::node</a></code> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;stddef.h&gt;</span>     <span class="comment">// offsetof macro</span></div>
<div class="line"><span class="preprocessor">#include &lt;cds/intrusive/treiber_stack.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;cds/gc/hp.h&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">namespace </span>ci = <a class="code" href="namespacecds_1_1intrusive.html">cds::intrusive</a>;</div>
<div class="line"><span class="keyword">typedef</span> cds::gc::HP <a class="code" href="classcds_1_1intrusive_1_1_treiber_stack.html#a531fe25cb5ed51c621c7b63e43f4a3d7">gc</a>;</div>
<div class="line"></div>
<div class="line"><span class="keyword">struct </span>myData</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line">    ci::treiber_stack::node&lt; gc &gt;      member_hook_;</div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keyword">typedef</span> ci::TreiberStack&lt; <a class="code" href="classcds_1_1intrusive_1_1_treiber_stack.html#a531fe25cb5ed51c621c7b63e43f4a3d7">gc</a>,</div>
<div class="line">    myData,</div>
<div class="line">    <span class="keyword">typename</span> ci::treiber_stack::make_traits&lt;</div>
<div class="line">        ci::opt::hook&lt; ci::treiber_stack::member_hook&lt; offsetof(myData, member_hook_), gc &gt;&gt;</div>
<div class="line">    &gt;::type</div>
<div class="line">&gt; stack_t;</div>
</div><!-- fragment --> </div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="af8346c46c34eeebd748e27b8128b7877"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GC, typename T, typename Traits = treiber_stack::traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1intrusive_1_1_treiber_stack.html">cds::intrusive::TreiberStack</a>&lt; GC, T, Traits &gt;::<a class="el" href="classcds_1_1intrusive_1_1_treiber_stack.html">TreiberStack</a> </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nCollisionCapacity</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs empty stack and initializes elimination back-off data. </p>
<p>This form should be used if you use elimination back-off with dynamically allocated collision array, i.e <code>Options</code>... contains cds::opt::buffer&lt; cds::opt::v::dynamic_buffer &gt;. <code>nCollisionCapacity</code> parameter specifies the capacity of collision array. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a34937a52801400187ecf9f611456047f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GC, typename T, typename Traits = treiber_stack::traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcds_1_1intrusive_1_1_treiber_stack.html">cds::intrusive::TreiberStack</a>&lt; GC, T, Traits &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear the stack. </p>
<p><a class="anchor" id="cds_intrusive_TreiberStack_clear"></a>For each removed item the disposer is called.</p>
<dl class="section note"><dt>Note</dt><dd>It is possible that after <code><a class="el" href="classcds_1_1intrusive_1_1_treiber_stack.html#a34937a52801400187ecf9f611456047f" title="Clear the stack. ">clear()</a></code> the <code><a class="el" href="classcds_1_1intrusive_1_1_treiber_stack.html#adacf358421348acf186672843deb4185" title="Check if stack is empty. ">empty()</a></code> returns <code>false</code> if some other thread pushes an item into the stack during <code>clear</code> works </dd></dl>

</div>
</div>
<a class="anchor" id="ae87f09d2df1ef1954a99b334575029ea"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GC, typename T, typename Traits = treiber_stack::traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1intrusive_1_1_treiber_stack.html#aee1bd2833bdf4dc85f54d64901d265ae">value_type</a>* <a class="el" href="classcds_1_1intrusive_1_1_treiber_stack.html">cds::intrusive::TreiberStack</a>&lt; GC, T, Traits &gt;::pop </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pop an item from the stack. </p>
<p>If stack is empty, returns <code>nullptr</code>. The disposer is <b>not</b> called for popped item. See <a class="el" href="namespacecds_1_1intrusive.html#cds_intrusive_item_destroying">Destroying items of intrusive containers</a>. </p>

</div>
</div>
<a class="anchor" id="a8abbf13d54786fd1264bb749de767d13"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GC, typename T, typename Traits = treiber_stack::traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1intrusive_1_1_treiber_stack.html">cds::intrusive::TreiberStack</a>&lt; GC, T, Traits &gt;::push </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcds_1_1intrusive_1_1_treiber_stack.html#aee1bd2833bdf4dc85f54d64901d265ae">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Push the item <code>val</code> on the stack. </p>
<p>No copying is made since it is intrusive stack. </p>

</div>
</div>
<a class="anchor" id="a2b7e86739b3125d56b2dfa7acfa9e395"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GC, typename T, typename Traits = treiber_stack::traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classcds_1_1intrusive_1_1_treiber_stack.html">cds::intrusive::TreiberStack</a>&lt; GC, T, Traits &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns stack's item count. </p>
<p>The value returned depends on <a class="el" href="structcds_1_1opt_1_1item__counter.html" title="[type-option] Option setter for item counting ">opt::item_counter</a> option. For <a class="el" href="classcds_1_1atomicity_1_1empty__item__counter.html" title="Empty item counter. ">atomicity::empty_item_counter</a>, this function always returns 0.</p>
<dl class="section warning"><dt>Warning</dt><dd>Even if you use real item counter and it returns 0, this fact is not mean that the stack is empty. To check emptyness use <a class="el" href="classcds_1_1intrusive_1_1_treiber_stack.html#adacf358421348acf186672843deb4185">empty()</a> method. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>cds/intrusive/treiber_stack.h</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<hr/>
<div align="right">
  <b>cds</b> <b>2.1.0</b> 
  Developed by <i>Maxim Khizhinsky aka khizmax</i> 2007 - 2015
  <br/>
  <i>Autogenerated Wed Jan 6 2016 16:00:45 by Doxygen 1.8.10</i>
</div>
</body>
</html>
